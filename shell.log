2017-12-13 17:37:33 - // include directory, this will be replaced by the kernel
2017-12-13 17:37:33 - #I "C:\\Users\\misadmin\\Desktop\\F sharp notebook"
2017-12-13 17:37:33 - // load base dlls
2017-12-13 17:37:33 - #r "IfSharp.Kernel.dll"
2017-12-13 17:37:33 - #r "NetMQ.dll"
2017-12-13 17:37:33 - // open the global functions and methods
2017-12-13 17:37:33 - open IfSharp.Kernel
2017-12-13 17:37:33 - open IfSharp.Kernel.Globals
2017-12-13 17:37:39 - F# Interactive for F# 4.1
2017-12-13 17:37:39 - Freely distributed under the Apache 2.0 Open Source License
2017-12-13 17:37:39 - For help type #help;;
2017-12-13 17:37:39 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2017-12-13 17:37:39 -   seq []
2017-12-13 17:37:39 - --> Added 'C:\Users\misadmin\Desktop\F sharp notebook' to library include path
2017-12-13 17:37:39 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2017-12-13 17:37:39 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\NetMQ.dll' (file may be locked by F# Interactive process)
2017-12-13 17:37:40 - Unknown content type on shell. msg_type is `comm_info_request`
2017-12-14 15:45:52 - let isDivisible (dividend:int) (divisor:int) : int = 
2017-12-14 15:45:52 -     if dividend % divisor = 0 then
2017-12-14 15:45:52 -         dividend % divisor
2017-12-14 15:45:52 -     else
2017-12-14 15:45:52 -         0
2017-12-14 15:45:52 - let test (maxInt:int) (num:int) : bool = 
2017-12-14 15:45:52 -     if num <= maxInt/2 then 
2017-12-14 15:45:52 -         true 
2017-12-14 15:45:52 -     else 
2017-12-14 15:45:52 -         false
2017-12-14 15:45:52 - let filterList (maxInt:int) (data:list<int>) : list<int> =
2017-12-14 15:45:52 -     List.filter (test maxInt) data 
2017-12-14 15:45:52 - let helper1 (maxInt:int) (data:list<int>) : int =
2017-12-14 15:45:52 -     data
2017-12-14 15:45:52 -     |> List.map (isDivisible maxInt)
2017-12-14 15:45:52 -     |> List.sum 
2017-12-14 15:45:52 -     
2017-12-14 15:45:52 - let folder ((answer, oldFilter):int*list<int>) (maxInt:int) : int*list<int> =
2017-12-14 15:45:52 -     let newFilter = filterList maxInt oldFilter
2017-12-14 15:45:52 -     
2017-12-14 15:45:52 -     newFilter
2017-12-14 15:45:52 -     |> (helper1 maxInt)
2017-12-14 15:45:52 -     |> (fun (additional:int) : int*list<int> -> ((answer + additional), newFilter))
2017-12-14 15:45:52 -     
2017-12-14 15:45:52 - let solveRow (input:list<int>) : int = 
2017-12-14 15:45:52 -     let startInt = input.Head
2017-12-14 15:45:52 -     
2017-12-14 15:45:52 -     input
2017-12-14 15:45:52 -     |> List.fold folder (startInt, input) 
2017-12-14 15:45:52 -     |> (fun (answer, _) -> answer)
2017-12-14 15:45:52 -     
2017-12-14 15:45:52 - let adventOfCode2Part2 (rows:int) (data:string) = 
2017-12-14 15:45:52 -     let dataCleaner (input:string) : list<list<int>> = 
2017-12-14 15:45:52 -         input
2017-12-14 15:45:52 -         |> stringSplit 
2017-12-14 15:45:52 -         |> Array.toList
2017-12-14 15:45:52 -         |> List.map (fun x -> System.Int32.Parse x) 
2017-12-14 15:45:52 -         |> separateBy rows
2017-12-14 15:45:52 -         |> List.map (List.sortDescending)
2017-12-14 15:45:52 -         |> List.map solveRow 
2017-12-14 15:45:52 -         |> List.sum 
2017-12-14 15:45:52 - Unexpected symbol ':' in lambda expression. Expected '->' or other token.
2017-12-14 15:45:52 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2017-12-14 15:46:19 - let isDivisible (dividend:int) (divisor:int) : int = 
2017-12-14 15:46:19 -     if dividend % divisor = 0 then
2017-12-14 15:46:19 -         dividend % divisor
2017-12-14 15:46:19 -     else
2017-12-14 15:46:19 -         0
2017-12-14 15:46:19 - let test (maxInt:int) (num:int) : bool = 
2017-12-14 15:46:19 -     if num <= maxInt/2 then 
2017-12-14 15:46:19 -         true 
2017-12-14 15:46:19 -     else 
2017-12-14 15:46:19 -         false
2017-12-14 15:46:19 - let filterList (maxInt:int) (data:list<int>) : list<int> =
2017-12-14 15:46:19 -     List.filter (test maxInt) data 
2017-12-14 15:46:19 - let helper1 (maxInt:int) (data:list<int>) : int =
2017-12-14 15:46:19 -     data
2017-12-14 15:46:19 -     |> List.map (isDivisible maxInt)
2017-12-14 15:46:19 -     |> List.sum 
2017-12-14 15:46:19 -     
2017-12-14 15:46:19 - let folder ((answer, oldFilter):int*list<int>) (maxInt:int) : int*list<int> =
2017-12-14 15:46:19 -     let newFilter = filterList maxInt oldFilter
2017-12-14 15:46:19 -     
2017-12-14 15:46:19 -     newFilter
2017-12-14 15:46:19 -     |> (helper1 maxInt)
2017-12-14 15:46:19 -     |> (fun additional -> ((answer + additional), newFilter))
2017-12-14 15:46:19 -     
2017-12-14 15:46:19 - let solveRow (input:list<int>) : int = 
2017-12-14 15:46:19 -     let startInt = input.Head
2017-12-14 15:46:19 -     
2017-12-14 15:46:19 -     input
2017-12-14 15:46:19 -     |> List.fold folder (startInt, input) 
2017-12-14 15:46:19 -     |> (fun (answer, _) -> answer)
2017-12-14 15:46:19 -     
2017-12-14 15:46:19 - let adventOfCode2Part2 (rows:int) (data:string) = 
2017-12-14 15:46:19 -     let dataCleaner (input:string) : list<list<int>> = 
2017-12-14 15:46:19 -         input
2017-12-14 15:46:19 -         |> stringSplit 
2017-12-14 15:46:19 -         |> Array.toList
2017-12-14 15:46:19 -         |> List.map (fun x -> System.Int32.Parse x) 
2017-12-14 15:46:19 -         |> separateBy rows
2017-12-14 15:46:19 -         |> List.map (List.sortDescending)
2017-12-14 15:46:19 -         |> List.map solveRow 
2017-12-14 15:46:19 -         |> List.sum 
2017-12-14 15:46:19 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2017-12-14 15:46:33 - let isDivisible (dividend:int) (divisor:int) : int = 
2017-12-14 15:46:33 -     if dividend % divisor = 0 then
2017-12-14 15:46:33 -         dividend % divisor
2017-12-14 15:46:33 -     else
2017-12-14 15:46:33 -         0
2017-12-14 15:46:41 - let test (maxInt:int) (num:int) : bool = 
2017-12-14 15:46:41 -     if num <= maxInt/2 then 
2017-12-14 15:46:41 -         true 
2017-12-14 15:46:41 -     else 
2017-12-14 15:46:41 -         false
2017-12-14 15:47:00 - let helper1 (maxInt:int) (data:list<int>) : int =
2017-12-14 15:47:00 -     data
2017-12-14 15:47:00 -     |> List.map (isDivisible maxInt)
2017-12-14 15:47:00 -     |> List.sum 
2017-12-14 15:47:06 -    
2017-12-14 15:47:06 - let folder ((answer, oldFilter):int*list<int>) (maxInt:int) : int*list<int> =
2017-12-14 15:47:06 -     let newFilter = filterList maxInt oldFilter
2017-12-14 15:47:06 -     
2017-12-14 15:47:06 -     newFilter
2017-12-14 15:47:06 -     |> (helper1 maxInt)
2017-12-14 15:47:06 -     |> (fun additional -> ((answer + additional), newFilter))
2017-12-14 15:47:06 -     
2017-12-14 15:47:06 - The value or constructor 'filterList' is not defined. Maybe you want one of the following:
2017-12-14 15:47:06 -    File
2017-12-14 15:47:28 - let filterList (maxInt:int) (data:list<int>) : list<int> =
2017-12-14 15:47:28 -     List.filter (test maxInt) data 
2017-12-14 15:47:35 -    
2017-12-14 15:47:35 - let folder ((answer, oldFilter):int*list<int>) (maxInt:int) : int*list<int> =
2017-12-14 15:47:35 -     let newFilter = filterList maxInt oldFilter
2017-12-14 15:47:35 -     
2017-12-14 15:47:35 -     newFilter
2017-12-14 15:47:35 -     |> (helper1 maxInt)
2017-12-14 15:47:35 -     |> (fun additional -> ((answer + additional), newFilter))
2017-12-14 15:47:35 -     
2017-12-14 15:47:38 - let solveRow (input:list<int>) : int = 
2017-12-14 15:47:38 -     let startInt = input.Head
2017-12-14 15:47:38 -     
2017-12-14 15:47:38 -     input
2017-12-14 15:47:38 -     |> List.fold folder (startInt, input) 
2017-12-14 15:47:38 -     |> (fun (answer, _) -> answer)
2017-12-14 15:47:41 - let adventOfCode2Part2 (rows:int) (data:string) = 
2017-12-14 15:47:41 -     let dataCleaner (input:string) : list<list<int>> = 
2017-12-14 15:47:41 -         input
2017-12-14 15:47:41 -         |> stringSplit 
2017-12-14 15:47:41 -         |> Array.toList
2017-12-14 15:47:41 -         |> List.map (fun x -> System.Int32.Parse x) 
2017-12-14 15:47:41 -         |> separateBy rows
2017-12-14 15:47:41 -         |> List.map (List.sortDescending)
2017-12-14 15:47:41 -         |> List.map solveRow 
2017-12-14 15:47:41 -         |> List.sum 
2017-12-14 15:47:41 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2017-12-14 15:48:09 - let adventOfCode2Part2 (rows:int) (data:string) = 
2017-12-14 15:48:09 -     let dataCleaner (input:string) : list<list<int>> = 
2017-12-14 15:48:09 -         input
2017-12-14 15:48:09 -         |> stringSplit 
2017-12-14 15:48:09 -         |> Array.toList
2017-12-14 15:48:09 -         |> List.map (fun x -> System.Int32.Parse x) 
2017-12-14 15:48:09 -         |> separateBy rows
2017-12-14 15:48:09 -         |> List.map (List.sortDescending)
2017-12-14 15:48:09 -     
2017-12-14 15:48:09 -     data
2017-12-14 15:48:09 -         |> dataCleaner
2017-12-14 15:48:09 -         |> List.map solveRow 
2017-12-14 15:48:09 -         |> List.sum 
2017-12-14 15:48:09 - The value or constructor 'stringSplit' is not defined. Maybe you want one of the following:
2017-12-14 15:48:09 -    String
2017-12-14 15:48:09 -    string
2017-12-14 15:48:09 - The value or constructor 'separateBy' is not defined.
2017-12-14 15:48:14 - open System
2017-12-14 15:48:14 - let input = "121	59	141	21	120	67	58	49	22	46	56	112	53	111	104	130
2017-12-14 15:48:14 - 1926	1910	760	2055	28	2242	146	1485	163	976	1842	1982	137	1387	162	789
2017-12-14 15:48:14 - 4088	258	2060	1014	4420	177	4159	194	2794	4673	4092	681	174	2924	170	3548
2017-12-14 15:48:14 - 191	407	253	192	207	425	580	231	197	382	404	472	164	571	500	216
2017-12-14 15:48:14 - 4700	1161	168	5398	5227	5119	252	2552	4887	5060	1152	3297	847	4525	220	262
2017-12-14 15:48:14 - 2417	992	1445	184	554	2940	209	2574	2262	1911	2923	204	2273	2760	506	157
2017-12-14 15:48:14 - 644	155	638	78	385	408	152	360	588	618	313	126	172	220	217	161
2017-12-14 15:48:14 - 227	1047	117	500	1445	222	29	913	190	791	230	1281	1385	226	856	1380
2017-12-14 15:48:14 - 436	46	141	545	122	86	283	124	249	511	347	502	168	468	117	94
2017-12-14 15:48:14 - 2949	3286	2492	2145	1615	159	663	1158	154	939	166	2867	141	324	2862	641
2017-12-14 15:48:14 - 1394	151	90	548	767	1572	150	913	141	1646	154	1351	1506	1510	707	400
2017-12-14 15:48:14 - 646	178	1228	1229	270	167	161	1134	193	1312	1428	131	1457	719	1288	989
2017-12-14 15:48:14 - 1108	1042	93	140	822	124	1037	1075	125	941	1125	298	136	94	135	711
2017-12-14 15:48:14 - 112	2429	1987	2129	2557	1827	477	100	78	634	352	1637	588	77	1624	2500
2017-12-14 15:48:14 - 514	218	209	185	197	137	393	555	588	569	710	537	48	309	519	138
2017-12-14 15:48:14 - 1567	3246	4194	151	3112	903	1575	134	150	4184	3718	4077	180	4307	4097	1705"
2017-12-14 15:48:14 - let stringSplit (input:string) : string[] = 
2017-12-14 15:48:14 -     input.Split()
2017-12-14 15:48:14 - let rec separateBy (rowLength:int) (data: list<int>) : list<list<int>> = 
2017-12-14 15:48:14 -     match data with
2017-12-14 15:48:14 -     | [] -> []
2017-12-14 15:48:14 -     | _ ->
2017-12-14 15:48:14 -         let endPoint = rowLength - 1
2017-12-14 15:48:14 -         let arrayHead = data.[0..endPoint] 
2017-12-14 15:48:14 -         let arrayRest = data.[rowLength..]
2017-12-14 15:48:14 -         
2017-12-14 15:48:14 -         arrayHead :: (separateBy rowLength arrayRest)
2017-12-14 15:48:14 - let rowDiffer (row : list<int>) : int = 
2017-12-14 15:48:14 -     (Seq.max row) - (Seq.min row) 
2017-12-14 15:48:14 - let adventOfCode2 (rows:int) (data:string) = 
2017-12-14 15:48:14 -     data
2017-12-14 15:48:14 -         |> stringSplit 
2017-12-14 15:48:14 -         |> Array.toList
2017-12-14 15:48:14 -         |> List.map (fun x -> System.Int32.Parse x) // turns string numbers to integers. A bit more resilient than 'int'
2017-12-14 15:48:14 -         |> separateBy rows
2017-12-14 15:48:14 -         |> Seq.sumBy rowDiffer
2017-12-14 15:48:14 - adventOfCode2 16 input
2017-12-14 15:48:14 - let isDivisible (dividend:int) (divisor:int) : int = 
2017-12-14 15:48:14 -     if dividend % divisor = 0 then
2017-12-14 15:48:14 -         dividend % divisor
2017-12-14 15:48:14 -     else
2017-12-14 15:48:14 -         0
2017-12-14 15:48:14 - let test (maxInt:int) (num:int) : bool = 
2017-12-14 15:48:14 -     if num <= maxInt/2 then 
2017-12-14 15:48:14 -         true 
2017-12-14 15:48:14 -     else 
2017-12-14 15:48:14 -         false
2017-12-14 15:48:14 - let filterList (maxInt:int) (data:list<int>) : list<int> =
2017-12-14 15:48:14 -     List.filter (test maxInt) data 
2017-12-14 15:48:14 - let helper1 (maxInt:int) (data:list<int>) : int =
2017-12-14 15:48:14 -     data
2017-12-14 15:48:14 -     |> List.map (isDivisible maxInt)
2017-12-14 15:48:14 -     |> List.sum 
2017-12-14 15:48:14 -    
2017-12-14 15:48:14 - let folder ((answer, oldFilter):int*list<int>) (maxInt:int) : int*list<int> =
2017-12-14 15:48:14 -     let newFilter = filterList maxInt oldFilter
2017-12-14 15:48:14 -     
2017-12-14 15:48:14 -     newFilter
2017-12-14 15:48:14 -     |> (helper1 maxInt)
2017-12-14 15:48:14 -     |> (fun additional -> ((answer + additional), newFilter))
2017-12-14 15:48:14 -     
2017-12-14 15:48:14 - let solveRow (input:list<int>) : int = 
2017-12-14 15:48:14 -     let startInt = input.Head
2017-12-14 15:48:14 -     
2017-12-14 15:48:14 -     input
2017-12-14 15:48:14 -     |> List.fold folder (startInt, input) 
2017-12-14 15:48:14 -     |> (fun (answer, _) -> answer)
2017-12-14 15:48:14 - let adventOfCode2Part2 (rows:int) (data:string) = 
2017-12-14 15:48:14 -     let dataCleaner (input:string) : list<list<int>> = 
2017-12-14 15:48:14 -         input
2017-12-14 15:48:14 -         |> stringSplit 
2017-12-14 15:48:14 -         |> Array.toList
2017-12-14 15:48:14 -         |> List.map (fun x -> System.Int32.Parse x) 
2017-12-14 15:48:14 -         |> separateBy rows
2017-12-14 15:48:14 -         |> List.map (List.sortDescending)
2017-12-14 15:48:14 -     
2017-12-14 15:48:14 -     data
2017-12-14 15:48:14 -         |> dataCleaner
2017-12-14 15:48:14 -         |> List.map solveRow 
2017-12-14 15:48:14 -         |> List.sum 
2017-12-14 15:49:07 - adventOdCode2Part2 fullInput
2017-12-14 15:49:07 - The value or constructor 'adventOdCode2Part2' is not defined. Maybe you want one of the following:
2017-12-14 15:49:07 -    adventOfCode2Part2
2017-12-14 15:49:07 -    adventOfCode2
2017-12-14 15:49:12 - adventOfCode2Part2 fullInput
2017-12-14 15:49:12 - The value or constructor 'fullInput' is not defined.
2017-12-14 15:49:16 - open System
2017-12-14 15:49:16 - let fullInput = "121	59	141	21	120	67	58	49	22	46	56	112	53	111	104	130
2017-12-14 15:49:16 - 1926	1910	760	2055	28	2242	146	1485	163	976	1842	1982	137	1387	162	789
2017-12-14 15:49:16 - 4088	258	2060	1014	4420	177	4159	194	2794	4673	4092	681	174	2924	170	3548
2017-12-14 15:49:16 - 191	407	253	192	207	425	580	231	197	382	404	472	164	571	500	216
2017-12-14 15:49:16 - 4700	1161	168	5398	5227	5119	252	2552	4887	5060	1152	3297	847	4525	220	262
2017-12-14 15:49:16 - 2417	992	1445	184	554	2940	209	2574	2262	1911	2923	204	2273	2760	506	157
2017-12-14 15:49:16 - 644	155	638	78	385	408	152	360	588	618	313	126	172	220	217	161
2017-12-14 15:49:16 - 227	1047	117	500	1445	222	29	913	190	791	230	1281	1385	226	856	1380
2017-12-14 15:49:16 - 436	46	141	545	122	86	283	124	249	511	347	502	168	468	117	94
2017-12-14 15:49:16 - 2949	3286	2492	2145	1615	159	663	1158	154	939	166	2867	141	324	2862	641
2017-12-14 15:49:16 - 1394	151	90	548	767	1572	150	913	141	1646	154	1351	1506	1510	707	400
2017-12-14 15:49:16 - 646	178	1228	1229	270	167	161	1134	193	1312	1428	131	1457	719	1288	989
2017-12-14 15:49:16 - 1108	1042	93	140	822	124	1037	1075	125	941	1125	298	136	94	135	711
2017-12-14 15:49:16 - 112	2429	1987	2129	2557	1827	477	100	78	634	352	1637	588	77	1624	2500
2017-12-14 15:49:16 - 514	218	209	185	197	137	393	555	588	569	710	537	48	309	519	138
2017-12-14 15:49:16 - 1567	3246	4194	151	3112	903	1575	134	150	4184	3718	4077	180	4307	4097	1705"
2017-12-14 15:49:16 - let stringSplit (input:string) : string[] = 
2017-12-14 15:49:16 -     input.Split()
2017-12-14 15:49:16 - let rec separateBy (rowLength:int) (data: list<int>) : list<list<int>> = 
2017-12-14 15:49:16 -     match data with
2017-12-14 15:49:16 -     | [] -> []
2017-12-14 15:49:16 -     | _ ->
2017-12-14 15:49:16 -         let endPoint = rowLength - 1
2017-12-14 15:49:16 -         let arrayHead = data.[0..endPoint] 
2017-12-14 15:49:16 -         let arrayRest = data.[rowLength..]
2017-12-14 15:49:16 -         
2017-12-14 15:49:16 -         arrayHead :: (separateBy rowLength arrayRest)
2017-12-14 15:49:16 - let rowDiffer (row : list<int>) : int = 
2017-12-14 15:49:16 -     (Seq.max row) - (Seq.min row) 
2017-12-14 15:49:16 - let adventOfCode2 (rows:int) (data:string) = 
2017-12-14 15:49:16 -     data
2017-12-14 15:49:16 -         |> stringSplit 
2017-12-14 15:49:16 -         |> Array.toList
2017-12-14 15:49:16 -         |> List.map (fun x -> System.Int32.Parse x) // turns string numbers to integers. A bit more resilient than 'int'
2017-12-14 15:49:16 -         |> separateBy rows
2017-12-14 15:49:16 -         |> Seq.sumBy rowDiffer
2017-12-14 15:49:16 - adventOfCode2 16 fullInput
2017-12-14 15:49:16 - let isDivisible (dividend:int) (divisor:int) : int = 
2017-12-14 15:49:16 -     if dividend % divisor = 0 then
2017-12-14 15:49:16 -         dividend % divisor
2017-12-14 15:49:16 -     else
2017-12-14 15:49:16 -         0
2017-12-14 15:49:16 - let test (maxInt:int) (num:int) : bool = 
2017-12-14 15:49:16 -     if num <= maxInt/2 then 
2017-12-14 15:49:16 -         true 
2017-12-14 15:49:16 -     else 
2017-12-14 15:49:16 -         false
2017-12-14 15:49:16 - let filterList (maxInt:int) (data:list<int>) : list<int> =
2017-12-14 15:49:16 -     List.filter (test maxInt) data 
2017-12-14 15:49:16 - let helper1 (maxInt:int) (data:list<int>) : int =
2017-12-14 15:49:16 -     data
2017-12-14 15:49:16 -     |> List.map (isDivisible maxInt)
2017-12-14 15:49:16 -     |> List.sum 
2017-12-14 15:49:16 -    
2017-12-14 15:49:16 - let folder ((answer, oldFilter):int*list<int>) (maxInt:int) : int*list<int> =
2017-12-14 15:49:16 -     let newFilter = filterList maxInt oldFilter
2017-12-14 15:49:16 -     
2017-12-14 15:49:16 -     newFilter
2017-12-14 15:49:16 -     |> (helper1 maxInt)
2017-12-14 15:49:16 -     |> (fun additional -> ((answer + additional), newFilter))
2017-12-14 15:49:16 -     
2017-12-14 15:49:16 - let solveRow (input:list<int>) : int = 
2017-12-14 15:49:16 -     let startInt = input.Head
2017-12-14 15:49:16 -     
2017-12-14 15:49:16 -     input
2017-12-14 15:49:16 -     |> List.fold folder (startInt, input) 
2017-12-14 15:49:16 -     |> (fun (answer, _) -> answer)
2017-12-14 15:49:16 - let adventOfCode2Part2 (rows:int) (data:string) = 
2017-12-14 15:49:16 -     let dataCleaner (input:string) : list<list<int>> = 
2017-12-14 15:49:16 -         input
2017-12-14 15:49:16 -         |> stringSplit 
2017-12-14 15:49:16 -         |> Array.toList
2017-12-14 15:49:16 -         |> List.map (fun x -> System.Int32.Parse x) 
2017-12-14 15:49:16 -         |> separateBy rows
2017-12-14 15:49:16 -         |> List.map (List.sortDescending)
2017-12-14 15:49:16 -     
2017-12-14 15:49:16 -     data
2017-12-14 15:49:16 -         |> dataCleaner
2017-12-14 15:49:16 -         |> List.map solveRow 
2017-12-14 15:49:16 -         |> List.sum 
2017-12-14 15:49:16 - adventOfCode2Part2 fullInput
2017-12-14 15:49:16 - This expression was expected to have type
2017-12-14 15:49:16 -     'int'    
2017-12-14 15:49:16 - but here has type
2017-12-14 15:49:16 -     'string'    
2017-12-14 15:49:44 - adventOfCode2Part2 16 fullInput
2017-12-14 15:51:32 - let dataCleaner (input:string) : list<list<int>> = 
2017-12-14 15:51:32 -         input
2017-12-14 15:51:32 -         |> stringSplit 
2017-12-14 15:51:32 -         |> Array.toList
2017-12-14 15:51:32 -         |> List.map (fun x -> System.Int32.Parse x) 
2017-12-14 15:51:32 -         |> separateBy rows
2017-12-14 15:51:32 -         |> List.map (List.sortDescending)
2017-12-14 15:51:32 - The value or constructor 'rows' is not defined.
2017-12-14 15:52:15 - let adventOfCode2Part2 (rows:int) (data:string) = 
2017-12-14 15:52:15 -     data
2017-12-14 15:52:15 -         |> dataCleaner rows
2017-12-14 15:52:15 -         |> List.map solveRow 
2017-12-14 15:52:15 -         |> List.sum 
2017-12-14 15:52:15 - The value or constructor 'dataCleaner' is not defined. Maybe you want one of the following:
2017-12-14 15:52:15 -    Data
2017-12-14 15:52:15 -    data
2017-12-14 15:52:17 - let dataCleaner (rows:int) (input:string) : list<list<int>> = 
2017-12-14 15:52:17 -         input
2017-12-14 15:52:17 -         |> stringSplit 
2017-12-14 15:52:17 -         |> Array.toList
2017-12-14 15:52:17 -         |> List.map (fun x -> System.Int32.Parse x) 
2017-12-14 15:52:17 -         |> separateBy rows
2017-12-14 15:52:17 -         |> List.map (List.sortDescending)
2017-12-14 15:52:20 - let adventOfCode2Part2 (rows:int) (data:string) = 
2017-12-14 15:52:20 -     data
2017-12-14 15:52:20 -         |> dataCleaner rows
2017-12-14 15:52:20 -         |> List.map solveRow 
2017-12-14 15:52:20 -         |> List.sum 
2017-12-14 15:52:30 - dataCleaner 16 fullInput
2017-12-14 15:53:06 - List.map solveRow (dataCleaner 16 fullInput)
2017-12-14 15:53:31 - open System
2017-12-14 15:53:31 - let fullInput = "121	59	141	21	120	67	58	49	22	46	56	112	53	111	104	130
2017-12-14 15:53:31 - 1926	1910	760	2055	28	2242	146	1485	163	976	1842	1982	137	1387	162	789
2017-12-14 15:53:31 - 4088	258	2060	1014	4420	177	4159	194	2794	4673	4092	681	174	2924	170	3548
2017-12-14 15:53:31 - 191	407	253	192	207	425	580	231	197	382	404	472	164	571	500	216
2017-12-14 15:53:31 - 4700	1161	168	5398	5227	5119	252	2552	4887	5060	1152	3297	847	4525	220	262
2017-12-14 15:53:31 - 2417	992	1445	184	554	2940	209	2574	2262	1911	2923	204	2273	2760	506	157
2017-12-14 15:53:31 - 644	155	638	78	385	408	152	360	588	618	313	126	172	220	217	161
2017-12-14 15:53:31 - 227	1047	117	500	1445	222	29	913	190	791	230	1281	1385	226	856	1380
2017-12-14 15:53:31 - 436	46	141	545	122	86	283	124	249	511	347	502	168	468	117	94
2017-12-14 15:53:31 - 2949	3286	2492	2145	1615	159	663	1158	154	939	166	2867	141	324	2862	641
2017-12-14 15:53:31 - 1394	151	90	548	767	1572	150	913	141	1646	154	1351	1506	1510	707	400
2017-12-14 15:53:31 - 646	178	1228	1229	270	167	161	1134	193	1312	1428	131	1457	719	1288	989
2017-12-14 15:53:31 - 1108	1042	93	140	822	124	1037	1075	125	941	1125	298	136	94	135	711
2017-12-14 15:53:31 - 112	2429	1987	2129	2557	1827	477	100	78	634	352	1637	588	77	1624	2500
2017-12-14 15:53:31 - 514	218	209	185	197	137	393	555	588	569	710	537	48	309	519	138
2017-12-14 15:53:31 - 1567	3246	4194	151	3112	903	1575	134	150	4184	3718	4077	180	4307	4097	1705"
2017-12-14 15:53:31 - let stringSplit (input:string) : string[] = 
2017-12-14 15:53:31 -     input.Split()
2017-12-14 15:53:31 - let rec separateBy (rowLength:int) (data: list<int>) : list<list<int>> = 
2017-12-14 15:53:31 -     match data with
2017-12-14 15:53:31 -     | [] -> []
2017-12-14 15:53:31 -     | _ ->
2017-12-14 15:53:31 -         let endPoint = rowLength - 1
2017-12-14 15:53:31 -         let arrayHead = data.[0..endPoint] 
2017-12-14 15:53:31 -         let arrayRest = data.[rowLength..]
2017-12-14 15:53:31 -         
2017-12-14 15:53:31 -         arrayHead :: (separateBy rowLength arrayRest)
2017-12-14 15:53:31 - let rowDiffer (row : list<int>) : int = 
2017-12-14 15:53:31 -     (Seq.max row) - (Seq.min row) 
2017-12-14 15:53:31 - let adventOfCode2 (rows:int) (data:string) = 
2017-12-14 15:53:31 -     data
2017-12-14 15:53:31 -         |> stringSplit 
2017-12-14 15:53:31 -         |> Array.toList
2017-12-14 15:53:31 -         |> List.map (fun x -> System.Int32.Parse x) // turns string numbers to integers. A bit more resilient than 'int'
2017-12-14 15:53:31 -         |> separateBy rows
2017-12-14 15:53:31 -         |> Seq.sumBy rowDiffer
2017-12-14 15:53:31 - adventOfCode2 16 fullInput
2017-12-14 15:53:31 - let isDivisible (dividend:int) (divisor:int) : int = 
2017-12-14 15:53:31 -     if dividend % divisor = 0 then
2017-12-14 15:53:31 -         (dividend % divisor)
2017-12-14 15:53:31 -     else
2017-12-14 15:53:31 -         0
2017-12-14 15:53:31 - let test (maxInt:int) (num:int) : bool = 
2017-12-14 15:53:31 -     if num <= maxInt/2 then 
2017-12-14 15:53:31 -         true 
2017-12-14 15:53:31 -     else 
2017-12-14 15:53:31 -         false
2017-12-14 15:53:31 - let filterList (maxInt:int) (data:list<int>) : list<int> =
2017-12-14 15:53:31 -     List.filter (test maxInt) data 
2017-12-14 15:53:32 - let helper1 (maxInt:int) (data:list<int>) : int =
2017-12-14 15:53:32 -     data
2017-12-14 15:53:32 -     |> List.map (isDivisible maxInt)
2017-12-14 15:53:32 -     |> List.sum 
2017-12-14 15:53:32 -    
2017-12-14 15:53:32 - let folder ((answer, oldFilter):int*list<int>) (maxInt:int) : int*list<int> =
2017-12-14 15:53:32 -     let newFilter = filterList maxInt oldFilter
2017-12-14 15:53:32 -     
2017-12-14 15:53:32 -     newFilter
2017-12-14 15:53:32 -     |> (helper1 maxInt)
2017-12-14 15:53:32 -     |> (fun additional -> ((answer + additional), newFilter))
2017-12-14 15:53:32 -     
2017-12-14 15:53:32 - let solveRow (input:list<int>) : int = 
2017-12-14 15:53:32 -     let startInt = input.Head
2017-12-14 15:53:32 -     
2017-12-14 15:53:32 -     input
2017-12-14 15:53:32 -     |> List.fold folder (startInt, input) 
2017-12-14 15:53:32 -     |> (fun (answer, _) -> answer)
2017-12-14 15:53:32 - let dataCleaner (rows:int) (input:string) : list<list<int>> = 
2017-12-14 15:53:32 -         input
2017-12-14 15:53:32 -         |> stringSplit 
2017-12-14 15:53:32 -         |> Array.toList
2017-12-14 15:53:32 -         |> List.map (fun x -> System.Int32.Parse x) 
2017-12-14 15:53:32 -         |> separateBy rows
2017-12-14 15:53:32 -         |> List.map (List.sortDescending)
2017-12-14 15:53:32 - let adventOfCode2Part2 (rows:int) (data:string) = 
2017-12-14 15:53:32 -     data
2017-12-14 15:53:32 -         |> dataCleaner rows
2017-12-14 15:53:32 -         |> List.map solveRow 
2017-12-14 15:53:32 -         |> List.sum 
2017-12-14 15:53:32 - List.map solveRow (dataCleaner 16 fullInput)
2017-12-14 15:54:10 - dataCleaner 16 fullInput
2017-12-14 15:54:24 - List.map solveRow (dataCleaner 16 fullInput)
2017-12-14 15:55:54 - open System
2017-12-14 15:55:54 - let fullInput = "121	59	141	21	120	67	58	49	22	46	56	112	53	111	104	130
2017-12-14 15:55:54 - 1926	1910	760	2055	28	2242	146	1485	163	976	1842	1982	137	1387	162	789
2017-12-14 15:55:54 - 4088	258	2060	1014	4420	177	4159	194	2794	4673	4092	681	174	2924	170	3548
2017-12-14 15:55:54 - 191	407	253	192	207	425	580	231	197	382	404	472	164	571	500	216
2017-12-14 15:55:54 - 4700	1161	168	5398	5227	5119	252	2552	4887	5060	1152	3297	847	4525	220	262
2017-12-14 15:55:54 - 2417	992	1445	184	554	2940	209	2574	2262	1911	2923	204	2273	2760	506	157
2017-12-14 15:55:54 - 644	155	638	78	385	408	152	360	588	618	313	126	172	220	217	161
2017-12-14 15:55:54 - 227	1047	117	500	1445	222	29	913	190	791	230	1281	1385	226	856	1380
2017-12-14 15:55:54 - 436	46	141	545	122	86	283	124	249	511	347	502	168	468	117	94
2017-12-14 15:55:54 - 2949	3286	2492	2145	1615	159	663	1158	154	939	166	2867	141	324	2862	641
2017-12-14 15:55:54 - 1394	151	90	548	767	1572	150	913	141	1646	154	1351	1506	1510	707	400
2017-12-14 15:55:54 - 646	178	1228	1229	270	167	161	1134	193	1312	1428	131	1457	719	1288	989
2017-12-14 15:55:54 - 1108	1042	93	140	822	124	1037	1075	125	941	1125	298	136	94	135	711
2017-12-14 15:55:54 - 112	2429	1987	2129	2557	1827	477	100	78	634	352	1637	588	77	1624	2500
2017-12-14 15:55:54 - 514	218	209	185	197	137	393	555	588	569	710	537	48	309	519	138
2017-12-14 15:55:54 - 1567	3246	4194	151	3112	903	1575	134	150	4184	3718	4077	180	4307	4097	1705"
2017-12-14 15:55:54 - let stringSplit (input:string) : string[] = 
2017-12-14 15:55:54 -     input.Split()
2017-12-14 15:55:54 - let rec separateBy (rowLength:int) (data: list<int>) : list<list<int>> = 
2017-12-14 15:55:54 -     match data with
2017-12-14 15:55:54 -     | [] -> []
2017-12-14 15:55:54 -     | _ ->
2017-12-14 15:55:54 -         let endPoint = rowLength - 1
2017-12-14 15:55:54 -         let arrayHead = data.[0..endPoint] 
2017-12-14 15:55:54 -         let arrayRest = data.[rowLength..]
2017-12-14 15:55:54 -         
2017-12-14 15:55:54 -         arrayHead :: (separateBy rowLength arrayRest)
2017-12-14 15:55:54 - let rowDiffer (row : list<int>) : int = 
2017-12-14 15:55:54 -     (Seq.max row) - (Seq.min row) 
2017-12-14 15:55:54 - let adventOfCode2 (rows:int) (data:string) = 
2017-12-14 15:55:54 -     data
2017-12-14 15:55:54 -         |> stringSplit 
2017-12-14 15:55:54 -         |> Array.toList
2017-12-14 15:55:54 -         |> List.map (fun x -> System.Int32.Parse x) // turns string numbers to integers. A bit more resilient than 'int'
2017-12-14 15:55:54 -         |> separateBy rows
2017-12-14 15:55:54 -         |> Seq.sumBy rowDiffer
2017-12-14 15:55:54 - adventOfCode2 16 fullInput
2017-12-14 15:55:54 - let isDivisible (dividend:int) (divisor:int) : int = 
2017-12-14 15:55:54 -     if dividend % divisor = 0 then
2017-12-14 15:55:54 -         (dividend / divisor)
2017-12-14 15:55:54 -     else
2017-12-14 15:55:54 -         0
2017-12-14 15:55:54 - let test (maxInt:int) (num:int) : bool = 
2017-12-14 15:55:54 -     if num <= maxInt/2 then 
2017-12-14 15:55:54 -         true 
2017-12-14 15:55:54 -     else 
2017-12-14 15:55:54 -         false
2017-12-14 15:55:54 - let filterList (maxInt:int) (data:list<int>) : list<int> =
2017-12-14 15:55:54 -     List.filter (test maxInt) data 
2017-12-14 15:55:54 - let helper1 (maxInt:int) (data:list<int>) : int =
2017-12-14 15:55:54 -     data
2017-12-14 15:55:54 -     |> List.map (isDivisible maxInt)
2017-12-14 15:55:54 -     |> List.sum 
2017-12-14 15:55:54 -    
2017-12-14 15:55:54 - let folder ((answer, oldFilter):int*list<int>) (maxInt:int) : int*list<int> =
2017-12-14 15:55:54 -     let newFilter = filterList maxInt oldFilter
2017-12-14 15:55:54 -     
2017-12-14 15:55:54 -     newFilter
2017-12-14 15:55:54 -     |> (helper1 maxInt)
2017-12-14 15:55:54 -     |> (fun additional -> ((answer + additional), newFilter))
2017-12-14 15:55:54 -     
2017-12-14 15:55:54 - let solveRow (input:list<int>) : int = 
2017-12-14 15:55:54 -     let startInt = input.Head
2017-12-14 15:55:54 -     
2017-12-14 15:55:54 -     input
2017-12-14 15:55:54 -     |> List.fold folder (startInt, input) 
2017-12-14 15:55:54 -     |> (fun (answer, _) -> answer)
2017-12-14 15:55:55 - let dataCleaner (rows:int) (input:string) : list<list<int>> = 
2017-12-14 15:55:55 -         input
2017-12-14 15:55:55 -         |> stringSplit 
2017-12-14 15:55:55 -         |> Array.toList
2017-12-14 15:55:55 -         |> List.map (fun x -> System.Int32.Parse x) 
2017-12-14 15:55:55 -         |> separateBy rows
2017-12-14 15:55:55 -         |> List.map (List.sortDescending)
2017-12-14 15:55:55 - let adventOfCode2Part2 (rows:int) (data:string) = 
2017-12-14 15:55:55 -     data
2017-12-14 15:55:55 -         |> dataCleaner rows
2017-12-14 15:55:55 -         |> List.map solveRow 
2017-12-14 15:55:55 -         |> List.sum 
2017-12-14 15:55:55 - List.map solveRow (dataCleaner 16 fullInput)
2017-12-14 15:57:14 - //List.map solveRow (dataCleaner 16 fullInput)
2017-12-14 15:57:14 - //dataCleaner 16 fullInput
2017-12-14 15:57:14 - isDivisible 8 4
2017-12-14 15:57:18 - //List.map solveRow (dataCleaner 16 fullInput)
2017-12-14 15:57:18 - //dataCleaner 16 fullInput
2017-12-14 15:57:18 - isDivisible 8 5
2017-12-14 15:57:23 - //List.map solveRow (dataCleaner 16 fullInput)
2017-12-14 15:57:23 - //dataCleaner 16 fullInput
2017-12-14 15:57:23 - isDivisible 8 8
2017-12-14 15:57:29 - //List.map solveRow (dataCleaner 16 fullInput)
2017-12-14 15:57:29 - //dataCleaner 16 fullInput
2017-12-14 15:57:29 - isDivisible 8 24
2017-12-14 15:58:14 - //List.map solveRow (dataCleaner 16 fullInput)
2017-12-14 15:58:14 - //dataCleaner 16 fullInput
2017-12-14 15:58:14 - //isDivisible 8 24
2017-12-14 15:58:14 - filterList 12 [1;2;3;4;5;6;7;8]
2017-12-14 15:58:26 - //List.map solveRow (dataCleaner 16 fullInput)
2017-12-14 15:58:26 - //dataCleaner 16 fullInput
2017-12-14 15:58:26 - //isDivisible 8 24
2017-12-14 15:58:26 - filterList 4 [1;2;3;4;5;6;7;8]
2017-12-14 15:58:33 - //List.map solveRow (dataCleaner 16 fullInput)
2017-12-14 15:58:33 - //dataCleaner 16 fullInput
2017-12-14 15:58:33 - //isDivisible 8 24
2017-12-14 15:58:33 - filterList 11 [1;2;3;4;5;6;7;8]
2017-12-14 16:00:21 - //List.map solveRow (dataCleaner 16 fullInput)
2017-12-14 16:00:21 - (dataCleaner 16 fullInput) |> List.head |> solveRow
2017-12-14 16:00:21 - //isDivisible 8 24
2017-12-14 16:00:21 - //filterList 11 [1;2;3;4;5;6;7;8]
2017-12-14 16:02:24 - //List.map solveRow (dataCleaner 16 fullInput)
2017-12-14 16:02:24 - (dataCleaner 16 fullInput) |> List.head |> (helper1 141)
2017-12-14 16:02:24 - //isDivisible 8 24
2017-12-14 16:02:24 - //filterList 11 [1;2;3;4;5;6;7;8]
2017-12-14 16:04:24 - //List.map solveRow (dataCleaner 16 fullInput)
2017-12-14 16:04:24 - //(dataCleaner 16 fullInput) |> List.head |> (helper1 141)
2017-12-14 16:04:24 - //isDivisible 8 24
2017-12-14 16:04:24 - //filterList 11 [1;2;3;4;5;6;7;8]
2017-12-14 16:04:24 - adventOfCode2Part2 16 fullInput
2017-12-14 16:04:28 - open System
2017-12-14 16:04:28 - let fullInput = "121	59	141	21	120	67	58	49	22	46	56	112	53	111	104	130
2017-12-14 16:04:28 - 1926	1910	760	2055	28	2242	146	1485	163	976	1842	1982	137	1387	162	789
2017-12-14 16:04:28 - 4088	258	2060	1014	4420	177	4159	194	2794	4673	4092	681	174	2924	170	3548
2017-12-14 16:04:28 - 191	407	253	192	207	425	580	231	197	382	404	472	164	571	500	216
2017-12-14 16:04:28 - 4700	1161	168	5398	5227	5119	252	2552	4887	5060	1152	3297	847	4525	220	262
2017-12-14 16:04:28 - 2417	992	1445	184	554	2940	209	2574	2262	1911	2923	204	2273	2760	506	157
2017-12-14 16:04:28 - 644	155	638	78	385	408	152	360	588	618	313	126	172	220	217	161
2017-12-14 16:04:28 - 227	1047	117	500	1445	222	29	913	190	791	230	1281	1385	226	856	1380
2017-12-14 16:04:28 - 436	46	141	545	122	86	283	124	249	511	347	502	168	468	117	94
2017-12-14 16:04:28 - 2949	3286	2492	2145	1615	159	663	1158	154	939	166	2867	141	324	2862	641
2017-12-14 16:04:28 - 1394	151	90	548	767	1572	150	913	141	1646	154	1351	1506	1510	707	400
2017-12-14 16:04:28 - 646	178	1228	1229	270	167	161	1134	193	1312	1428	131	1457	719	1288	989
2017-12-14 16:04:28 - 1108	1042	93	140	822	124	1037	1075	125	941	1125	298	136	94	135	711
2017-12-14 16:04:28 - 112	2429	1987	2129	2557	1827	477	100	78	634	352	1637	588	77	1624	2500
2017-12-14 16:04:28 - 514	218	209	185	197	137	393	555	588	569	710	537	48	309	519	138
2017-12-14 16:04:28 - 1567	3246	4194	151	3112	903	1575	134	150	4184	3718	4077	180	4307	4097	1705"
2017-12-14 16:04:28 - let stringSplit (input:string) : string[] = 
2017-12-14 16:04:28 -     input.Split()
2017-12-14 16:04:28 - let rec separateBy (rowLength:int) (data: list<int>) : list<list<int>> = 
2017-12-14 16:04:28 -     match data with
2017-12-14 16:04:28 -     | [] -> []
2017-12-14 16:04:28 -     | _ ->
2017-12-14 16:04:28 -         let endPoint = rowLength - 1
2017-12-14 16:04:28 -         let arrayHead = data.[0..endPoint] 
2017-12-14 16:04:28 -         let arrayRest = data.[rowLength..]
2017-12-14 16:04:28 -         
2017-12-14 16:04:28 -         arrayHead :: (separateBy rowLength arrayRest)
2017-12-14 16:04:28 - let rowDiffer (row : list<int>) : int = 
2017-12-14 16:04:28 -     (Seq.max row) - (Seq.min row) 
2017-12-14 16:04:28 - let adventOfCode2 (rows:int) (data:string) = 
2017-12-14 16:04:28 -     data
2017-12-14 16:04:28 -         |> stringSplit 
2017-12-14 16:04:28 -         |> Array.toList
2017-12-14 16:04:28 -         |> List.map (fun x -> System.Int32.Parse x) // turns string numbers to integers. A bit more resilient than 'int'
2017-12-14 16:04:28 -         |> separateBy rows
2017-12-14 16:04:28 -         |> Seq.sumBy rowDiffer
2017-12-14 16:04:28 - adventOfCode2 16 fullInput
2017-12-14 16:04:28 - let isDivisible (dividend:int) (divisor:int) : int = 
2017-12-14 16:04:28 -     if dividend % divisor = 0 then
2017-12-14 16:04:28 -         (dividend / divisor)
2017-12-14 16:04:28 -     else
2017-12-14 16:04:28 -         0
2017-12-14 16:04:28 - let test (maxInt:int) (num:int) : bool = 
2017-12-14 16:04:28 -     if num <= maxInt/2 then 
2017-12-14 16:04:28 -         true 
2017-12-14 16:04:28 -     else 
2017-12-14 16:04:28 -         false
2017-12-14 16:04:28 - let filterList (maxInt:int) (data:list<int>) : list<int> =
2017-12-14 16:04:28 -     List.filter (test maxInt) data 
2017-12-14 16:04:28 - let helper1 (maxInt:int) (data:list<int>) : int =
2017-12-14 16:04:28 -     data
2017-12-14 16:04:28 -     |> List.map (isDivisible maxInt)
2017-12-14 16:04:28 -     |> List.sum 
2017-12-14 16:04:28 -    
2017-12-14 16:04:28 - let folder ((answer, oldFilter):int*list<int>) (maxInt:int) : int*list<int> =
2017-12-14 16:04:28 -     let newFilter = filterList maxInt oldFilter
2017-12-14 16:04:28 -     
2017-12-14 16:04:28 -     newFilter
2017-12-14 16:04:28 -     |> (helper1 maxInt)
2017-12-14 16:04:28 -     |> (fun additional -> ((answer + additional), newFilter))
2017-12-14 16:04:28 -     
2017-12-14 16:04:28 - let solveRow (input:list<int>) : int = 
2017-12-14 16:04:28 -     let startInt = input.Head
2017-12-14 16:04:28 -     
2017-12-14 16:04:28 -     input
2017-12-14 16:04:28 -     |> List.fold folder (0, input) 
2017-12-14 16:04:28 -     |> (fun (answer, _) -> answer)
2017-12-14 16:04:28 - let dataCleaner (rows:int) (input:string) : list<list<int>> = 
2017-12-14 16:04:28 -         input
2017-12-14 16:04:28 -         |> stringSplit 
2017-12-14 16:04:28 -         |> Array.toList
2017-12-14 16:04:28 -         |> List.map (fun x -> System.Int32.Parse x) 
2017-12-14 16:04:28 -         |> separateBy rows
2017-12-14 16:04:28 -         |> List.map (List.sortDescending)
2017-12-14 16:04:28 - let adventOfCode2Part2 (rows:int) (data:string) = 
2017-12-14 16:04:28 -     data
2017-12-14 16:04:28 -         |> dataCleaner rows
2017-12-14 16:04:28 -         |> List.map solveRow 
2017-12-14 16:04:28 -         |> List.sum 
2017-12-14 16:04:28 - //List.map solveRow (dataCleaner 16 fullInput)
2017-12-14 16:04:28 - //(dataCleaner 16 fullInput) |> List.head |> (helper1 141)
2017-12-14 16:04:28 - //isDivisible 8 24
2017-12-14 16:04:28 - //filterList 11 [1;2;3;4;5;6;7;8]
2017-12-14 16:04:28 - adventOfCode2Part2 16 fullInput
2017-12-14 16:05:28 - let divideFactors (dividend:int) (divisor:int) : int = 
2017-12-14 16:05:28 -     if dividend % divisor = 0 then
2017-12-14 16:05:28 -         (dividend / divisor)
2017-12-14 16:05:28 -     else
2017-12-14 16:05:28 -         0
2017-12-14 16:25:52 - let dataCleaner (rows:int) (input:string) : list<list<int>> = 
2017-12-14 16:25:52 -         input
2017-12-14 16:25:52 -         |> stringSplit 
2017-12-14 16:25:52 -         |> Array.toList
2017-12-14 16:25:52 -         |> List.map (fun x -> System.Int32.Parse x) 
2017-12-14 16:25:52 -         |> separateBy rows
2017-12-14 16:25:52 -         
2017-12-14 16:25:52 - dataCleaner 16 fullInput
2017-12-14 16:33:18 - let adventOfCode2 (rows:int) (data:string) = 
2017-12-14 16:33:18 -     data
2017-12-14 16:33:18 -         |> dataCleaner rows
2017-12-14 16:33:18 -         |> Seq.sumBy rowDiffer
2017-12-14 16:33:18 - adventOfCode2 16 fullInput
2017-12-14 16:33:24 - open System
2017-12-14 16:33:24 - let fullInput = "121	59	141	21	120	67	58	49	22	46	56	112	53	111	104	130
2017-12-14 16:33:24 - 1926	1910	760	2055	28	2242	146	1485	163	976	1842	1982	137	1387	162	789
2017-12-14 16:33:24 - 4088	258	2060	1014	4420	177	4159	194	2794	4673	4092	681	174	2924	170	3548
2017-12-14 16:33:24 - 191	407	253	192	207	425	580	231	197	382	404	472	164	571	500	216
2017-12-14 16:33:24 - 4700	1161	168	5398	5227	5119	252	2552	4887	5060	1152	3297	847	4525	220	262
2017-12-14 16:33:24 - 2417	992	1445	184	554	2940	209	2574	2262	1911	2923	204	2273	2760	506	157
2017-12-14 16:33:24 - 644	155	638	78	385	408	152	360	588	618	313	126	172	220	217	161
2017-12-14 16:33:24 - 227	1047	117	500	1445	222	29	913	190	791	230	1281	1385	226	856	1380
2017-12-14 16:33:24 - 436	46	141	545	122	86	283	124	249	511	347	502	168	468	117	94
2017-12-14 16:33:24 - 2949	3286	2492	2145	1615	159	663	1158	154	939	166	2867	141	324	2862	641
2017-12-14 16:33:24 - 1394	151	90	548	767	1572	150	913	141	1646	154	1351	1506	1510	707	400
2017-12-14 16:33:24 - 646	178	1228	1229	270	167	161	1134	193	1312	1428	131	1457	719	1288	989
2017-12-14 16:33:24 - 1108	1042	93	140	822	124	1037	1075	125	941	1125	298	136	94	135	711
2017-12-14 16:33:24 - 112	2429	1987	2129	2557	1827	477	100	78	634	352	1637	588	77	1624	2500
2017-12-14 16:33:24 - 514	218	209	185	197	137	393	555	588	569	710	537	48	309	519	138
2017-12-14 16:33:24 - 1567	3246	4194	151	3112	903	1575	134	150	4184	3718	4077	180	4307	4097	1705"
2017-12-14 16:33:24 - let stringSplit (input:string) : string[] = 
2017-12-14 16:33:24 -     input.Split()
2017-12-14 16:33:24 - let rec separateBy (rowLength:int) (data: list<int>) : list<list<int>> = 
2017-12-14 16:33:24 -     match data with
2017-12-14 16:33:24 -     | [] -> []
2017-12-14 16:33:24 -     | _ ->
2017-12-14 16:33:24 -         let endPoint = rowLength - 1
2017-12-14 16:33:24 -         let arrayHead = data.[0..endPoint] 
2017-12-14 16:33:24 -         let arrayRest = data.[rowLength..]
2017-12-14 16:33:24 -         
2017-12-14 16:33:24 -         arrayHead :: (separateBy rowLength arrayRest)
2017-12-14 16:33:24 - let dataCleaner (rows:int) (input:string) : list<list<int>> = 
2017-12-14 16:33:24 -     input
2017-12-14 16:33:24 -         |> stringSplit 
2017-12-14 16:33:24 -         |> Array.toList
2017-12-14 16:33:24 -         |> List.map (fun x -> System.Int32.Parse x) 
2017-12-14 16:33:24 -         |> separateBy rows
2017-12-14 16:33:24 -         
2017-12-14 16:33:24 - dataCleaner 16 fullInput
2017-12-14 16:33:24 - let rowDiffer (row : list<int>) : int = 
2017-12-14 16:33:24 -     (Seq.max row) - (Seq.min row) 
2017-12-14 16:33:24 - let adventOfCode2 (rows:int) (data:string) = 
2017-12-14 16:33:24 -     data
2017-12-14 16:33:24 -         |> dataCleaner rows
2017-12-14 16:33:24 -         |> Seq.sumBy rowDiffer
2017-12-14 16:33:24 - adventOfCode2 16 fullInput
2017-12-14 16:33:24 - let divideFactors (dividend:int) (divisor:int) : int = 
2017-12-14 16:33:24 -     if dividend % divisor = 0 then
2017-12-14 16:33:24 -         (dividend / divisor)
2017-12-14 16:33:24 -     else
2017-12-14 16:33:24 -         0
2017-12-14 16:33:24 - let potentialFactor (maxInt:int) (num:int) : bool = 
2017-12-14 16:33:24 -     if num <= maxInt/2 then 
2017-12-14 16:33:24 -         true 
2017-12-14 16:33:24 -     else 
2017-12-14 16:33:24 -         false
2017-12-14 16:33:24 - let filterList (maxInt:int) (data:list<int>) : list<int> =
2017-12-14 16:33:24 -     List.filter (potentialFactor maxInt) data 
2017-12-14 16:33:24 - let helper1 (maxInt:int) (data:list<int>) : int =
2017-12-14 16:33:24 -     data
2017-12-14 16:33:24 -     |> List.map (divideFactors maxInt)
2017-12-14 16:33:24 -     |> List.sum 
2017-12-14 16:33:24 -    
2017-12-14 16:33:24 - let folder ((answer, oldFilter):int*list<int>) (maxInt:int) : int*list<int> =
2017-12-14 16:33:24 -     let newFilter = filterList maxInt oldFilter
2017-12-14 16:33:24 -     
2017-12-14 16:33:24 -     newFilter
2017-12-14 16:33:24 -     |> (helper1 maxInt)
2017-12-14 16:33:24 -     |> (fun additional -> ((answer + additional), newFilter))
2017-12-14 16:33:24 -     
2017-12-14 16:33:24 - let solveRow (input:list<int>) : int = 
2017-12-14 16:33:24 -     let startInt = input.Head
2017-12-14 16:33:24 -     
2017-12-14 16:33:24 -     input
2017-12-14 16:33:24 -     |> List.fold folder (0, input) 
2017-12-14 16:33:24 -     |> (fun (answer, _) -> answer)
2017-12-14 16:33:24 - let adventOfCode2Part2 (rows:int) (data:string) = 
2017-12-14 16:33:24 -     data
2017-12-14 16:33:24 -         |> dataCleaner rows
2017-12-14 16:33:24 -         |> List.map (List.sortDescending)
2017-12-14 16:33:24 -         |> List.map solveRow 
2017-12-14 16:33:24 -         |> List.sum 
2017-12-14 16:33:24 - adventOfCode2Part2 16 fullInput
2017-12-14 18:13:45 - open System
2017-12-14 18:13:45 - let fullInput = "121	59	141	21	120	67	58	49	22	46	56	112	53	111	104	130
2017-12-14 18:13:45 - 1926	1910	760	2055	28	2242	146	1485	163	976	1842	1982	137	1387	162	789
2017-12-14 18:13:45 - 4088	258	2060	1014	4420	177	4159	194	2794	4673	4092	681	174	2924	170	3548
2017-12-14 18:13:45 - 191	407	253	192	207	425	580	231	197	382	404	472	164	571	500	216
2017-12-14 18:13:45 - 4700	1161	168	5398	5227	5119	252	2552	4887	5060	1152	3297	847	4525	220	262
2017-12-14 18:13:45 - 2417	992	1445	184	554	2940	209	2574	2262	1911	2923	204	2273	2760	506	157
2017-12-14 18:13:45 - 644	155	638	78	385	408	152	360	588	618	313	126	172	220	217	161
2017-12-14 18:13:45 - 227	1047	117	500	1445	222	29	913	190	791	230	1281	1385	226	856	1380
2017-12-14 18:13:45 - 436	46	141	545	122	86	283	124	249	511	347	502	168	468	117	94
2017-12-14 18:13:45 - 2949	3286	2492	2145	1615	159	663	1158	154	939	166	2867	141	324	2862	641
2017-12-14 18:13:45 - 1394	151	90	548	767	1572	150	913	141	1646	154	1351	1506	1510	707	400
2017-12-14 18:13:45 - 646	178	1228	1229	270	167	161	1134	193	1312	1428	131	1457	719	1288	989
2017-12-14 18:13:45 - 1108	1042	93	140	822	124	1037	1075	125	941	1125	298	136	94	135	711
2017-12-14 18:13:45 - 112	2429	1987	2129	2557	1827	477	100	78	634	352	1637	588	77	1624	2500
2017-12-14 18:13:45 - 514	218	209	185	197	137	393	555	588	569	710	537	48	309	519	138
2017-12-14 18:13:45 - 1567	3246	4194	151	3112	903	1575	134	150	4184	3718	4077	180	4307	4097	1705"
2017-12-14 18:13:45 - let stringSplit (input:string) : string[] = 
2017-12-14 18:13:45 -     input.Split()
2017-12-14 18:13:45 - let rec separateBy (rowLength:int) (data: list<int>) : list<list<int>> = 
2017-12-14 18:13:45 -     match data with
2017-12-14 18:13:45 -     | [] -> []
2017-12-14 18:13:45 -     | _ ->
2017-12-14 18:13:45 -         let endPoint = rowLength - 1
2017-12-14 18:13:45 -         let arrayHead = data.[0..endPoint] 
2017-12-14 18:13:45 -         let arrayRest = data.[rowLength..]
2017-12-14 18:13:45 -         
2017-12-14 18:13:45 -         arrayHead :: (separateBy rowLength arrayRest)
2017-12-14 18:13:45 - let dataCleaner (rows:int) (input:string) : list<list<int>> = 
2017-12-14 18:13:45 -     input
2017-12-14 18:13:45 -         |> stringSplit 
2017-12-14 18:13:45 -         |> Array.toList
2017-12-14 18:13:45 -         |> List.map (fun x -> System.Int32.Parse x) 
2017-12-14 18:13:45 -         |> separateBy rows
2017-12-14 18:13:45 -         
2017-12-14 18:13:45 - dataCleaner 16 fullInput
2017-12-14 18:13:46 - let rowDiffer (row : list<int>) : int = 
2017-12-14 18:13:46 -     (Seq.max row) - (Seq.min row) 
2017-12-14 18:13:46 - let adventOfCode2 (rows:int) (data:string) = 
2017-12-14 18:13:46 -     data
2017-12-14 18:13:46 -         |> dataCleaner rows
2017-12-14 18:13:46 -         |> Seq.sumBy rowDiffer
2017-12-14 18:13:46 - adventOfCode2 16 fullInput
2017-12-14 18:13:46 - let divideFactors (dividend:int) (divisor:int) : int = 
2017-12-14 18:13:46 -     if dividend % divisor = 0 then
2017-12-14 18:13:46 -         (dividend / divisor)
2017-12-14 18:13:46 -     else
2017-12-14 18:13:46 -         0
2017-12-14 18:13:46 - let potentialFactor (maxInt:int) (num:int) : bool = 
2017-12-14 18:13:46 -     if num <= maxInt/2 then 
2017-12-14 18:13:46 -         true 
2017-12-14 18:13:46 -     else 
2017-12-14 18:13:46 -         false
2017-12-14 18:13:46 - let filterList (maxInt:int) (data:list<int>) : list<int> =
2017-12-14 18:13:46 -     List.filter (potentialFactor maxInt) data 
2017-12-14 18:13:46 - let helper1 (maxInt:int) (data:list<int>) : int =
2017-12-14 18:13:46 -     data
2017-12-14 18:13:46 -     |> List.map (divideFactors maxInt)
2017-12-14 18:13:46 -     |> List.sum 
2017-12-14 18:13:46 -    
2017-12-14 18:13:46 - let folder ((answer, oldFilter):int*list<int>) (maxInt:int) : int*list<int> =
2017-12-14 18:13:46 -     let newFilter = filterList maxInt oldFilter
2017-12-14 18:13:46 -     
2017-12-14 18:13:46 -     newFilter
2017-12-14 18:13:46 -     |> (helper1 maxInt)
2017-12-14 18:13:46 -     |> (fun additional -> ((answer + additional), newFilter))
2017-12-14 18:13:46 -     
2017-12-14 18:13:46 - let solveRow (input:list<int>) : int = 
2017-12-14 18:13:46 -     let startInt = input.Head
2017-12-14 18:13:46 -     
2017-12-14 18:13:46 -     input
2017-12-14 18:13:46 -     |> List.fold folder (0, input) 
2017-12-14 18:13:46 -     |> (fun (answer, _) -> answer)
2017-12-14 18:13:46 - let adventOfCode2Part2 (rows:int) (data:string) = 
2017-12-14 18:13:46 -     data
2017-12-14 18:13:46 -         |> dataCleaner rows
2017-12-14 18:13:46 -         |> List.map (List.sortDescending)
2017-12-14 18:13:46 -         |> List.map solveRow 
2017-12-14 18:13:46 -         |> List.sum 
2017-12-14 18:13:46 - adventOfCode2Part2 16 fullInput
2017-12-14 18:13:54 - shutdown request
2017-12-14 18:13:58 - // include directory, this will be replaced by the kernel
2017-12-14 18:13:58 - #I "C:\\Users\\misadmin\\Desktop\\F sharp notebook"
2017-12-14 18:13:58 - // load base dlls
2017-12-14 18:13:58 - #r "IfSharp.Kernel.dll"
2017-12-14 18:13:58 - #r "NetMQ.dll"
2017-12-14 18:13:58 - // open the global functions and methods
2017-12-14 18:13:58 - open IfSharp.Kernel
2017-12-14 18:13:58 - open IfSharp.Kernel.Globals
2017-12-14 18:14:05 - F# Interactive for F# 4.1
2017-12-14 18:14:05 - Freely distributed under the Apache 2.0 Open Source License
2017-12-14 18:14:05 - For help type #help;;
2017-12-14 18:14:05 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2017-12-14 18:14:05 -   seq []
2017-12-14 18:14:05 - --> Added 'C:\Users\misadmin\Desktop\F sharp notebook' to library include path
2017-12-14 18:14:05 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2017-12-14 18:14:05 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\NetMQ.dll' (file may be locked by F# Interactive process)
2017-12-14 18:14:06 - open System
2017-12-14 18:14:06 - let fullInput = "121	59	141	21	120	67	58	49	22	46	56	112	53	111	104	130
2017-12-14 18:14:06 - 1926	1910	760	2055	28	2242	146	1485	163	976	1842	1982	137	1387	162	789
2017-12-14 18:14:06 - 4088	258	2060	1014	4420	177	4159	194	2794	4673	4092	681	174	2924	170	3548
2017-12-14 18:14:06 - 191	407	253	192	207	425	580	231	197	382	404	472	164	571	500	216
2017-12-14 18:14:06 - 4700	1161	168	5398	5227	5119	252	2552	4887	5060	1152	3297	847	4525	220	262
2017-12-14 18:14:06 - 2417	992	1445	184	554	2940	209	2574	2262	1911	2923	204	2273	2760	506	157
2017-12-14 18:14:06 - 644	155	638	78	385	408	152	360	588	618	313	126	172	220	217	161
2017-12-14 18:14:06 - 227	1047	117	500	1445	222	29	913	190	791	230	1281	1385	226	856	1380
2017-12-14 18:14:06 - 436	46	141	545	122	86	283	124	249	511	347	502	168	468	117	94
2017-12-14 18:14:06 - 2949	3286	2492	2145	1615	159	663	1158	154	939	166	2867	141	324	2862	641
2017-12-14 18:14:06 - 1394	151	90	548	767	1572	150	913	141	1646	154	1351	1506	1510	707	400
2017-12-14 18:14:06 - 646	178	1228	1229	270	167	161	1134	193	1312	1428	131	1457	719	1288	989
2017-12-14 18:14:06 - 1108	1042	93	140	822	124	1037	1075	125	941	1125	298	136	94	135	711
2017-12-14 18:14:06 - 112	2429	1987	2129	2557	1827	477	100	78	634	352	1637	588	77	1624	2500
2017-12-14 18:14:06 - 514	218	209	185	197	137	393	555	588	569	710	537	48	309	519	138
2017-12-14 18:14:06 - 1567	3246	4194	151	3112	903	1575	134	150	4184	3718	4077	180	4307	4097	1705"
2017-12-14 18:14:06 - let stringSplit (input:string) : string[] = 
2017-12-14 18:14:06 -     input.Split()
2017-12-14 18:14:06 - let rec separateBy (rowLength:int) (data: list<int>) : list<list<int>> = 
2017-12-14 18:14:06 -     match data with
2017-12-14 18:14:06 -     | [] -> []
2017-12-14 18:14:06 -     | _ ->
2017-12-14 18:14:06 -         let endPoint = rowLength - 1
2017-12-14 18:14:06 -         let arrayHead = data.[0..endPoint] 
2017-12-14 18:14:06 -         let arrayRest = data.[rowLength..]
2017-12-14 18:14:06 -         
2017-12-14 18:14:06 -         arrayHead :: (separateBy rowLength arrayRest)
2017-12-14 18:14:07 - let dataCleaner (rows:int) (input:string) : list<list<int>> = 
2017-12-14 18:14:07 -     input
2017-12-14 18:14:07 -         |> stringSplit 
2017-12-14 18:14:07 -         |> Array.toList
2017-12-14 18:14:07 -         |> List.map (fun x -> System.Int32.Parse x) 
2017-12-14 18:14:07 -         |> separateBy rows
2017-12-14 18:14:07 -         
2017-12-14 18:14:07 - dataCleaner 16 fullInput
2017-12-14 18:14:07 - let rowDiffer (row : list<int>) : int = 
2017-12-14 18:14:07 -     (Seq.max row) - (Seq.min row) 
2017-12-14 18:14:07 - let adventOfCode2 (rows:int) (data:string) = 
2017-12-14 18:14:07 -     data
2017-12-14 18:14:07 -         |> dataCleaner rows
2017-12-14 18:14:07 -         |> Seq.sumBy rowDiffer
2017-12-14 18:14:07 - adventOfCode2 16 fullInput
2017-12-14 18:14:07 - let divideFactors (dividend:int) (divisor:int) : int = 
2017-12-14 18:14:07 -     if dividend % divisor = 0 then
2017-12-14 18:14:07 -         (dividend / divisor)
2017-12-14 18:14:07 -     else
2017-12-14 18:14:07 -         0
2017-12-14 18:14:07 - let potentialFactor (maxInt:int) (num:int) : bool = 
2017-12-14 18:14:07 -     if num <= maxInt/2 then 
2017-12-14 18:14:07 -         true 
2017-12-14 18:14:07 -     else 
2017-12-14 18:14:07 -         false
2017-12-14 18:14:07 - let filterList (maxInt:int) (data:list<int>) : list<int> =
2017-12-14 18:14:07 -     List.filter (potentialFactor maxInt) data 
2017-12-14 18:14:07 - let helper1 (maxInt:int) (data:list<int>) : int =
2017-12-14 18:14:07 -     data
2017-12-14 18:14:07 -     |> List.map (divideFactors maxInt)
2017-12-14 18:14:07 -     |> List.sum 
2017-12-14 18:14:08 -    
2017-12-14 18:14:08 - let folder ((answer, oldFilter):int*list<int>) (maxInt:int) : int*list<int> =
2017-12-14 18:14:08 -     let newFilter = filterList maxInt oldFilter
2017-12-14 18:14:08 -     
2017-12-14 18:14:08 -     newFilter
2017-12-14 18:14:08 -     |> (helper1 maxInt)
2017-12-14 18:14:08 -     |> (fun additional -> ((answer + additional), newFilter))
2017-12-14 18:14:08 -     
2017-12-14 18:14:08 - let solveRow (input:list<int>) : int = 
2017-12-14 18:14:08 -     let startInt = input.Head
2017-12-14 18:14:08 -     
2017-12-14 18:14:08 -     input
2017-12-14 18:14:08 -     |> List.fold folder (0, input) 
2017-12-14 18:14:08 -     |> (fun (answer, _) -> answer)
2017-12-14 18:14:08 - let adventOfCode2Part2 (rows:int) (data:string) = 
2017-12-14 18:14:08 -     data
2017-12-14 18:14:08 -         |> dataCleaner rows
2017-12-14 18:14:08 -         |> List.map (List.sortDescending)
2017-12-14 18:14:08 -         |> List.map solveRow 
2017-12-14 18:14:08 -         |> List.sum 
2017-12-14 18:14:08 - adventOfCode2Part2 16 fullInput
2017-12-14 18:42:17 - shutdown request
2017-12-14 18:42:20 - // include directory, this will be replaced by the kernel
2017-12-14 18:42:20 - #I "C:\\Users\\misadmin\\Desktop\\F sharp notebook"
2017-12-14 18:42:20 - // load base dlls
2017-12-14 18:42:20 - #r "IfSharp.Kernel.dll"
2017-12-14 18:42:20 - #r "NetMQ.dll"
2017-12-14 18:42:20 - // open the global functions and methods
2017-12-14 18:42:20 - open IfSharp.Kernel
2017-12-14 18:42:20 - open IfSharp.Kernel.Globals
2017-12-14 18:42:26 - F# Interactive for F# 4.1
2017-12-14 18:42:26 - Freely distributed under the Apache 2.0 Open Source License
2017-12-14 18:42:26 - For help type #help;;
2017-12-14 18:42:26 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2017-12-14 18:42:26 -   seq []
2017-12-14 18:42:26 - --> Added 'C:\Users\misadmin\Desktop\F sharp notebook' to library include path
2017-12-14 18:42:26 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2017-12-14 18:42:26 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\NetMQ.dll' (file may be locked by F# Interactive process)
2017-12-14 18:42:26 - open System
2017-12-14 18:42:26 - let fullInput = "121	59	141	21	120	67	58	49	22	46	56	112	53	111	104	130
2017-12-14 18:42:26 - 1926	1910	760	2055	28	2242	146	1485	163	976	1842	1982	137	1387	162	789
2017-12-14 18:42:26 - 4088	258	2060	1014	4420	177	4159	194	2794	4673	4092	681	174	2924	170	3548
2017-12-14 18:42:26 - 191	407	253	192	207	425	580	231	197	382	404	472	164	571	500	216
2017-12-14 18:42:26 - 4700	1161	168	5398	5227	5119	252	2552	4887	5060	1152	3297	847	4525	220	262
2017-12-14 18:42:26 - 2417	992	1445	184	554	2940	209	2574	2262	1911	2923	204	2273	2760	506	157
2017-12-14 18:42:26 - 644	155	638	78	385	408	152	360	588	618	313	126	172	220	217	161
2017-12-14 18:42:26 - 227	1047	117	500	1445	222	29	913	190	791	230	1281	1385	226	856	1380
2017-12-14 18:42:26 - 436	46	141	545	122	86	283	124	249	511	347	502	168	468	117	94
2017-12-14 18:42:26 - 2949	3286	2492	2145	1615	159	663	1158	154	939	166	2867	141	324	2862	641
2017-12-14 18:42:26 - 1394	151	90	548	767	1572	150	913	141	1646	154	1351	1506	1510	707	400
2017-12-14 18:42:26 - 646	178	1228	1229	270	167	161	1134	193	1312	1428	131	1457	719	1288	989
2017-12-14 18:42:26 - 1108	1042	93	140	822	124	1037	1075	125	941	1125	298	136	94	135	711
2017-12-14 18:42:26 - 112	2429	1987	2129	2557	1827	477	100	78	634	352	1637	588	77	1624	2500
2017-12-14 18:42:26 - 514	218	209	185	197	137	393	555	588	569	710	537	48	309	519	138
2017-12-14 18:42:26 - 1567	3246	4194	151	3112	903	1575	134	150	4184	3718	4077	180	4307	4097	1705"
2017-12-14 18:42:27 - let stringSplit (input:string) : string[] = 
2017-12-14 18:42:27 -     input.Split()
2017-12-14 18:42:27 - let rec separateBy (rowLength:int) (data: list<int>) : list<list<int>> = 
2017-12-14 18:42:27 -     match data with
2017-12-14 18:42:27 -     | [] -> []
2017-12-14 18:42:27 -     | _ ->
2017-12-14 18:42:27 -         let endPoint = rowLength - 1
2017-12-14 18:42:27 -         let arrayHead = data.[0..endPoint] 
2017-12-14 18:42:27 -         let arrayRest = data.[rowLength..]
2017-12-14 18:42:27 -         
2017-12-14 18:42:27 -         arrayHead :: (separateBy rowLength arrayRest)
2017-12-14 18:42:27 - let dataCleaner (rows:int) (input:string) : list<list<int>> = 
2017-12-14 18:42:27 -     input
2017-12-14 18:42:27 -         |> stringSplit 
2017-12-14 18:42:27 -         |> Array.toList
2017-12-14 18:42:27 -         |> List.map (fun x -> System.Int32.Parse x) 
2017-12-14 18:42:27 -         |> separateBy rows
2017-12-14 18:42:27 -         
2017-12-14 18:42:27 - dataCleaner 16 fullInput
2017-12-14 18:42:28 - let rowDiffer (row : list<int>) : int = 
2017-12-14 18:42:28 -     (Seq.max row) - (Seq.min row) 
2017-12-14 18:42:28 - let adventOfCode2 (rows:int) (data:string) = 
2017-12-14 18:42:28 -     data
2017-12-14 18:42:28 -         |> dataCleaner rows
2017-12-14 18:42:28 -         |> Seq.sumBy rowDiffer
2017-12-14 18:42:28 - adventOfCode2 16 fullInput
2017-12-14 18:42:28 - let divideFactors (dividend:int) (divisor:int) : int = 
2017-12-14 18:42:28 -     if dividend % divisor = 0 then
2017-12-14 18:42:28 -         (dividend / divisor)
2017-12-14 18:42:28 -     else
2017-12-14 18:42:28 -         0
2017-12-14 18:42:28 - let potentialFactor (maxInt:int) (num:int) : bool = 
2017-12-14 18:42:28 -     if num <= maxInt/2 then 
2017-12-14 18:42:28 -         true 
2017-12-14 18:42:28 -     else 
2017-12-14 18:42:28 -         false
2017-12-14 18:42:28 - let filterList (maxInt:int) (data:list<int>) : list<int> =
2017-12-14 18:42:28 -     List.filter (potentialFactor maxInt) data 
2017-12-14 18:42:28 - let helper1 (maxInt:int) (data:list<int>) : int =
2017-12-14 18:42:28 -     data
2017-12-14 18:42:28 -     |> List.map (divideFactors maxInt)
2017-12-14 18:42:28 -     |> List.sum 
2017-12-14 18:42:28 -    
2017-12-14 18:42:28 - let folder ((answer, oldFilter):int*list<int>) (maxInt:int) : int*list<int> =
2017-12-14 18:42:28 -     let newFilter = filterList maxInt oldFilter
2017-12-14 18:42:28 -     
2017-12-14 18:42:28 -     newFilter
2017-12-14 18:42:28 -     |> (helper1 maxInt)
2017-12-14 18:42:28 -     |> (fun additional -> ((answer + additional), newFilter))
2017-12-14 18:42:28 -     
2017-12-14 18:42:28 - let solveRow (input:list<int>) : int = 
2017-12-14 18:42:28 -     let startInt = input.Head
2017-12-14 18:42:28 -     
2017-12-14 18:42:28 -     input
2017-12-14 18:42:28 -     |> List.fold folder (0, input) 
2017-12-14 18:42:28 -     |> (fun (answer, _) -> answer)
2017-12-14 18:42:28 - let adventOfCode2Part2 (rows:int) (data:string) = 
2017-12-14 18:42:28 -     data
2017-12-14 18:42:28 -         |> dataCleaner rows
2017-12-14 18:42:28 -         |> List.map (List.sortDescending)
2017-12-14 18:42:28 -         |> List.map solveRow 
2017-12-14 18:42:28 -         |> List.sum 
2017-12-14 18:42:28 - adventOfCode2Part2 16 fullInput
2017-12-18 09:32:37 - // include directory, this will be replaced by the kernel
2017-12-18 09:32:37 - #I "C:\\Users\\misadmin\\Desktop\\F sharp notebook"
2017-12-18 09:32:37 - // load base dlls
2017-12-18 09:32:37 - #r "IfSharp.Kernel.dll"
2017-12-18 09:32:37 - #r "NetMQ.dll"
2017-12-18 09:32:37 - // open the global functions and methods
2017-12-18 09:32:37 - open IfSharp.Kernel
2017-12-18 09:32:37 - open IfSharp.Kernel.Globals
2017-12-18 09:32:43 - F# Interactive for F# 4.1
2017-12-18 09:32:43 - Freely distributed under the Apache 2.0 Open Source License
2017-12-18 09:32:43 - For help type #help;;
2017-12-18 09:32:43 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2017-12-18 09:32:43 -   seq []
2017-12-18 09:32:43 - --> Added 'C:\Users\misadmin\Desktop\F sharp notebook' to library include path
2017-12-18 09:32:43 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2017-12-18 09:32:43 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\NetMQ.dll' (file may be locked by F# Interactive process)
2017-12-18 09:32:46 - Unknown content type on shell. msg_type is `comm_info_request`
2017-12-18 09:42:25 - let generateSquare (max:int) (min:int): int list = 
2017-12-18 09:42:25 -     List.append [(max-1):min] [min+1:max]
2017-12-18 09:42:25 -     |> List.head
2017-12-18 09:42:25 -         
2017-12-18 09:42:25 - Unexpected symbol ':' in expression. Expected ']' or other token.
2017-12-18 09:42:25 - Unmatched '['
2017-12-18 09:42:36 - let generateSquare (max:int) (min:int): int list = 
2017-12-18 09:42:36 -     List.append [(max-1):min] [(min+1):max]
2017-12-18 09:42:36 -     |> List.head
2017-12-18 09:42:36 -         
2017-12-18 09:42:36 - Unexpected symbol ':' in expression. Expected ']' or other token.
2017-12-18 09:42:36 - Unmatched '['
2017-12-18 09:43:01 - let generateSquare (max:int) (min:int): int list = 
2017-12-18 09:43:01 -     List.append [(max-1)..min] [(min+1)..max]
2017-12-18 09:43:01 -     |> List.head
2017-12-18 09:43:01 -         
2017-12-18 09:43:01 - Type mismatch. Expecting a
2017-12-18 09:43:01 -     'int list -> int list'    
2017-12-18 09:43:01 - but given a
2017-12-18 09:43:01 -     'int list -> int'    
2017-12-18 09:43:01 - The type 'int list' does not match the type 'int'
2017-12-18 09:43:27 - let generateSquare (max:int) (min:int): int list = 
2017-12-18 09:43:27 -     List.append [(max-1)..min] [(min+1)..max]
2017-12-18 09:43:27 -     |> List.tail
2017-12-18 09:43:27 -         
2017-12-18 11:09:08 - let generateSquare (max:int) (min:int): int seq = 
2017-12-18 11:09:08 -     Seq.append {(max-1)..min} {(min+1)..max}
2017-12-18 11:09:08 -     |> Seq.tail
2017-12-18 11:09:08 -     |> Seq.ofList
2017-12-18 11:09:08 -     |> (fun x -> seq { for i in 1 to 4 do yield! x }
2017-12-18 11:09:08 - // let rec listGenerator ((goal:int), (accLen:int), (min:int), (max:int), (accList:int list)) : (int, int, int, int, int list) =
2017-12-18 11:09:08 - //     if goal = len then
2017-12-18 11:09:08 - //         (goal, len, min, max, [])
2017-12-18 11:09:08 - //     else 
2017-12-18 11:09:08 - //         let newSquare = generateSquare (max+2) (min+1)
2017-12-18 11:09:08 - //         let newLen = 
2017-12-18 11:09:08 - Unexpected keyword 'to' in expression. Expected '->' or other token.
2017-12-18 11:09:08 - Unmatched '('
2017-12-18 11:09:16 - let generateSquare (max:int) (min:int): int seq = 
2017-12-18 11:09:16 -     Seq.append {(max-1)..min} {(min+1)..max}
2017-12-18 11:09:16 -     |> Seq.tail
2017-12-18 11:09:16 -     |> Seq.ofList
2017-12-18 11:09:16 -     |> (fun x -> seq { for i in 1 to 4 do yield! x } )
2017-12-18 11:09:16 - // let rec listGenerator ((goal:int), (accLen:int), (min:int), (max:int), (accList:int list)) : (int, int, int, int, int list) =
2017-12-18 11:09:16 - //     if goal = len then
2017-12-18 11:09:16 - //         (goal, len, min, max, [])
2017-12-18 11:09:16 - //     else 
2017-12-18 11:09:16 - //         let newSquare = generateSquare (max+2) (min+1)
2017-12-18 11:09:16 - //         let newLen = 
2017-12-18 11:09:16 - Unexpected keyword 'to' in expression. Expected '->' or other token.
2017-12-18 11:10:16 - let generateSquare (max:int) (min:int): int seq = 
2017-12-18 11:10:16 -     Seq.append {(max-1)..min} {(min+1)..max}
2017-12-18 11:10:16 -     |> Seq.tail
2017-12-18 11:10:16 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 11:10:16 - // let rec listGenerator ((goal:int), (accLen:int), (min:int), (max:int), (accList:int list)) : (int, int, int, int, int list) =
2017-12-18 11:10:16 - //     if goal = len then
2017-12-18 11:10:16 - //         (goal, len, min, max, [])
2017-12-18 11:10:16 - //     else 
2017-12-18 11:10:16 - //         let newSquare = generateSquare (max+2) (min+1)
2017-12-18 11:10:16 - //         let newLen = 
2017-12-18 11:11:02 - let generateSquare (max:int) (min:int): int seq = 
2017-12-18 11:11:02 -     Seq.append {(max-1)..min} {(min+1)..max}
2017-12-18 11:11:02 -     |> Seq.tail
2017-12-18 11:11:02 -     |> (fun x -> seq { for i in 1..4 -> x } )
2017-12-18 11:11:02 - // let rec listGenerator ((goal:int), (accLen:int), (min:int), (max:int), (accList:int list)) : (int, int, int, int, int list) =
2017-12-18 11:11:02 - //     if goal = len then
2017-12-18 11:11:02 - //         (goal, len, min, max, [])
2017-12-18 11:11:02 - //     else 
2017-12-18 11:11:02 - //         let newSquare = generateSquare (max+2) (min+1)
2017-12-18 11:11:02 - //         let newLen = 
2017-12-18 11:11:02 - This expression was expected to have type
2017-12-18 11:11:02 -     'int'    
2017-12-18 11:11:02 - but here has type
2017-12-18 11:11:02 -     'seq<int>'    
2017-12-18 11:11:15 - let generateSquare (max:int) (min:int): int seq = 
2017-12-18 11:11:15 -     Seq.append {(max-1)..min} {(min+1)..max}
2017-12-18 11:11:15 -     |> Seq.tail
2017-12-18 11:11:15 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 11:11:15 - // let rec listGenerator ((goal:int), (accLen:int), (min:int), (max:int), (accList:int list)) : (int, int, int, int, int list) =
2017-12-18 11:11:15 - //     if goal = len then
2017-12-18 11:11:15 - //         (goal, len, min, max, [])
2017-12-18 11:11:15 - //     else 
2017-12-18 11:11:15 - //         let newSquare = generateSquare (max+2) (min+1)
2017-12-18 11:11:15 - //         let newLen = 
2017-12-18 11:11:31 - generateSquare 2 1
2017-12-18 11:11:40 - generateSquare 7 3
2017-12-18 11:11:58 - generateSquare 6 3
2017-12-18 11:11:59 - generateSquare 6 3
2017-12-18 11:12:23 - {6..3}
2017-12-18 11:12:51 - Seq.toList {6..3}
2017-12-18 11:12:55 - Seq.toList {6..3}
2017-12-18 11:13:05 - Seq.toList {1..4}
2017-12-18 11:13:14 - Seq.toList {4..1}
2017-12-18 11:14:42 - Seq.toList {4..(-1)..1}
2017-12-18 11:15:11 - generateSquare 6 3
2017-12-18 11:15:15 - let generateSquare (max:int) (min:int): int seq = 
2017-12-18 11:15:15 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 11:15:15 -     |> Seq.tail
2017-12-18 11:15:15 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 11:15:15 - // let rec listGenerator ((goal:int), (accLen:int), (min:int), (max:int), (accList:int list)) : (int, int, int, int, int list) =
2017-12-18 11:15:15 - //     if goal = len then
2017-12-18 11:15:15 - //         (goal, len, min, max, [])
2017-12-18 11:15:15 - //     else 
2017-12-18 11:15:15 - //         let newSquare = generateSquare (max+2) (min+1)
2017-12-18 11:15:15 - //         let newLen = 
2017-12-18 11:15:17 - generateSquare 6 3
2017-12-18 11:15:37 - generateSquare 6 3
2017-12-18 11:16:07 - let generateSquare (max:int) (min:int): int seq = 
2017-12-18 11:16:07 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 11:16:07 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 11:16:07 - // let rec listGenerator ((goal:int), (accLen:int), (min:int), (max:int), (accList:int list)) : (int, int, int, int, int list) =
2017-12-18 11:16:07 - //     if goal = len then
2017-12-18 11:16:07 - //         (goal, len, min, max, [])
2017-12-18 11:16:07 - //     else 
2017-12-18 11:16:07 - //         let newSquare = generateSquare (max+2) (min+1)
2017-12-18 11:16:07 - //         let newLen = 
2017-12-18 11:16:07 - generateSquare 6 3
2017-12-18 11:16:22 - generateSquare 6 3 |> Seq.toList
2017-12-18 11:22:06 - generateSquare 2 1 |> Seq.toList
2017-12-18 11:38:40 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 11:38:40 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 11:38:40 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 11:38:40 - let rec adventOfCode3 (goal, acc, min, max, accSeq) =
2017-12-18 11:38:40 -     match (goal = acc) with 
2017-12-18 11:38:40 -     | true -> (goal, acc, min, max, [])
2017-12-18 11:38:40 -     | false -> 
2017-12-18 11:38:40 -         let newSquare = generateSquare min max
2017-12-18 11:38:40 -         
2017-12-18 11:38:40 -         adventOfCode3 (goal, (acc + newSquare.length), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 11:38:40 -         
2017-12-18 11:38:40 - Type constraint mismatch. The type 
2017-12-18 11:38:40 -     'seq<int>'    
2017-12-18 11:38:40 - is not compatible with type
2017-12-18 11:38:40 -     'ObjectInfoReply'    
2017-12-18 11:39:02 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 11:39:02 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 11:39:02 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 11:39:02 - let rec adventOfCode3 (goal, acc, min, max, accSeq) =
2017-12-18 11:39:02 -     match (goal = acc) with 
2017-12-18 11:39:02 -     | true -> (goal, acc, min, max, [])
2017-12-18 11:39:02 -     | false -> 
2017-12-18 11:39:02 -         let newSquare = generateSquare min max
2017-12-18 11:39:02 -         
2017-12-18 11:39:02 -         adventOfCode3 (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 11:39:02 -         
2017-12-18 11:43:40 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 11:43:40 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 11:43:40 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 11:43:40 - let rec builder (goal, acc, min, max, accSeq) =
2017-12-18 11:43:40 -     match (goal <= acc) with 
2017-12-18 11:43:40 -     | true -> (goal, acc, min, max, [])
2017-12-18 11:43:40 -     | false -> 
2017-12-18 11:43:40 -         let newSquare = generateSquare min max
2017-12-18 11:43:40 -         
2017-12-18 11:43:40 -         builder (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 11:43:40 -         
2017-12-18 11:43:40 - let adventOfCode (goal:int) : int = 
2017-12-18 11:43:40 -     builder goal 0 1 2 []
2017-12-18 11:43:40 -     |> (func (_, _, _, _, manDistances) -> manDistances.[goal-1])
2017-12-18 11:43:40 - Unexpected symbol '_' in expression
2017-12-18 11:43:40 - Unmatched '('
2017-12-18 11:43:40 - Unexpected symbol '->' in binding. Expected incomplete structured construct at or before this point or other token.
2017-12-18 11:46:29 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 11:46:29 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 11:46:29 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 11:46:29 - let rec builder (goal, acc, min, max, accSeq) =
2017-12-18 11:46:29 -     match (goal <= acc) with 
2017-12-18 11:46:29 -     | true -> (goal, acc, min, max, accSeq)
2017-12-18 11:46:29 -     | _ -> 
2017-12-18 11:46:29 -         let newSquare = generateSquare min max
2017-12-18 11:46:29 -         builder (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 11:46:29 -         
2017-12-18 11:46:29 - let adventOfCode (goal:int) : int = 
2017-12-18 11:46:29 -     builder goal 0 1 2 []
2017-12-18 11:46:29 -     |> (func (_, _, _, _, manDistances) -> manDistances.[goal-1])
2017-12-18 11:46:29 - Unexpected symbol '_' in expression
2017-12-18 11:46:29 - Unmatched '('
2017-12-18 11:46:29 - Unexpected symbol '->' in binding. Expected incomplete structured construct at or before this point or other token.
2017-12-18 11:51:02 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 11:51:02 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 11:51:02 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 11:51:02 - let rec builder (goal, acc, min, max, accSeq) =
2017-12-18 11:51:02 -     match (goal <= acc) with 
2017-12-18 11:51:02 -     | true -> (goal, acc, min, max, accSeq)
2017-12-18 11:51:02 -     | _ -> 
2017-12-18 11:51:02 -         let newSquare = generateSquare min max
2017-12-18 11:51:02 -         builder (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 11:51:02 -         
2017-12-18 11:51:02 - let adventOfCode (goal:int) : int = 
2017-12-18 11:51:02 -     let extractor (_, _, _, _, manDistances) = 
2017-12-18 11:51:02 -         manDistances
2017-12-18 11:51:02 -         
2017-12-18 11:51:02 -     builder goal 0 1 2 []
2017-12-18 11:51:02 -     |> extractor[goal-1]
2017-12-18 11:51:02 - This value is not a function and cannot be applied
2017-12-18 11:51:02 - This expression was expected to have type
2017-12-18 11:51:02 -     'obj * obj * obj * obj * (obj -> int)'    
2017-12-18 11:51:02 - but here has type
2017-12-18 11:51:02 -     ''a list'    
2017-12-18 11:52:20 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 11:52:20 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 11:52:20 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 11:52:20 - let rec builder (goal, acc, min, max, accSeq) =
2017-12-18 11:52:20 -     match (goal <= acc) with 
2017-12-18 11:52:20 -     | true -> (goal, acc, min, max, accSeq)
2017-12-18 11:52:20 -     | _ -> 
2017-12-18 11:52:20 -         let newSquare = generateSquare min max
2017-12-18 11:52:20 -         builder (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 11:52:20 -         
2017-12-18 11:52:20 - let adventOfCode (goal:int) : int = 
2017-12-18 11:52:20 -     let extractor (_, _, _, _, manDistances) = 
2017-12-18 11:52:20 -         manDistances
2017-12-18 11:52:20 -         
2017-12-18 11:52:20 -     (builder (goal, 0, 1, 2, [])
2017-12-18 11:52:20 -     |> extractor.[goal-1]
2017-12-18 11:52:20 - Unmatched '('
2017-12-18 11:52:27 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 11:52:27 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 11:52:27 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 11:52:27 - let rec builder (goal, acc, min, max, accSeq) =
2017-12-18 11:52:27 -     match (goal <= acc) with 
2017-12-18 11:52:27 -     | true -> (goal, acc, min, max, accSeq)
2017-12-18 11:52:27 -     | _ -> 
2017-12-18 11:52:27 -         let newSquare = generateSquare min max
2017-12-18 11:52:27 -         builder (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 11:52:27 -         
2017-12-18 11:52:27 - let adventOfCode (goal:int) : int = 
2017-12-18 11:52:27 -     let extractor (_, _, _, _, manDistances) = 
2017-12-18 11:52:27 -         manDistances
2017-12-18 11:52:27 -         
2017-12-18 11:52:27 -     builder (goal, 0, 1, 2, [])
2017-12-18 11:52:27 -     |> extractor.[goal-1]
2017-12-18 11:52:27 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2017-12-18 11:52:33 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 11:52:33 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 11:52:33 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 11:52:33 - let rec builder (goal, acc, min, max, accSeq) =
2017-12-18 11:52:33 -     match (goal <= acc) with 
2017-12-18 11:52:33 -     | true -> (goal, acc, min, max, accSeq)
2017-12-18 11:52:33 -     | _ -> 
2017-12-18 11:52:33 -         let newSquare = generateSquare min max
2017-12-18 11:52:33 -         builder (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 11:52:33 -         
2017-12-18 11:52:33 - let adventOfCode (goal:int) : int = 
2017-12-18 11:52:33 -     let extractor (_, _, _, _, manDistances) = 
2017-12-18 11:52:33 -         manDistances
2017-12-18 11:52:33 -         
2017-12-18 11:52:33 -     builder (goal, 0, 1, 2, [])
2017-12-18 11:52:33 -     |> extractor[goal-1]
2017-12-18 11:52:33 - This expression was expected to have type
2017-12-18 11:52:33 -     'obj * obj * obj * obj * (int * int * int * int * seq<int> -> int)'    
2017-12-18 11:52:33 - but here has type
2017-12-18 11:52:33 -     ''a list'    
2017-12-18 11:54:44 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 11:54:44 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 11:54:44 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 11:54:44 - let rec builder (goal, acc, min, max, accSeq) =
2017-12-18 11:54:44 -     match (goal <= acc) with 
2017-12-18 11:54:44 -     | true -> (goal, acc, min, max, accSeq)
2017-12-18 11:54:44 -     | _ -> 
2017-12-18 11:54:44 -         let newSquare = generateSquare min max
2017-12-18 11:54:44 -         builder (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 11:54:44 -         
2017-12-18 11:54:44 - let adventOfCode (goal:int) : int = 
2017-12-18 11:54:44 -     let extractor (_, _, _, _, manDistances) = 
2017-12-18 11:54:44 -         manDistances
2017-12-18 11:54:44 -         
2017-12-18 11:54:44 -     builder (goal, 0, 1, 2, [])
2017-12-18 11:54:44 -     |> extractor
2017-12-18 11:54:44 -     |> (fun x -> x[goal-1])
2017-12-18 11:54:44 - This value is not a function and cannot be applied
2017-12-18 11:54:54 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 11:54:54 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 11:54:54 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 11:54:54 - let rec builder (goal, acc, min, max, accSeq) =
2017-12-18 11:54:54 -     match (goal <= acc) with 
2017-12-18 11:54:54 -     | true -> (goal, acc, min, max, accSeq)
2017-12-18 11:54:54 -     | _ -> 
2017-12-18 11:54:54 -         let newSquare = generateSquare min max
2017-12-18 11:54:54 -         builder (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 11:54:54 -         
2017-12-18 11:54:54 - let adventOfCode (goal:int) : int = 
2017-12-18 11:54:54 -     let extractor (_, _, _, _, manDistances) = 
2017-12-18 11:54:54 -         manDistances
2017-12-18 11:54:54 -         
2017-12-18 11:54:54 -     builder (goal, 0, 1, 2, [])
2017-12-18 11:54:54 -     |> extractor
2017-12-18 11:54:54 -     |> (fun x -> x.[goal-1])
2017-12-18 11:54:54 - The field, constructor or member 'Item' is not defined.
2017-12-18 11:55:08 - // include directory, this will be replaced by the kernel
2017-12-18 11:55:08 - #I "C:\\Users\\misadmin\\Desktop\\F sharp notebook"
2017-12-18 11:55:08 - // load base dlls
2017-12-18 11:55:08 - #r "IfSharp.Kernel.dll"
2017-12-18 11:55:08 - #r "NetMQ.dll"
2017-12-18 11:55:08 - // open the global functions and methods
2017-12-18 11:55:08 - open IfSharp.Kernel
2017-12-18 11:55:08 - open IfSharp.Kernel.Globals
2017-12-18 11:55:15 - F# Interactive for F# 4.1
2017-12-18 11:55:15 - Freely distributed under the Apache 2.0 Open Source License
2017-12-18 11:55:15 - For help type #help;;
2017-12-18 11:55:15 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2017-12-18 11:55:15 -   seq []
2017-12-18 11:55:15 - --> Added 'C:\Users\misadmin\Desktop\F sharp notebook' to library include path
2017-12-18 11:55:15 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2017-12-18 11:55:15 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\NetMQ.dll' (file may be locked by F# Interactive process)
2017-12-18 11:55:16 - Unknown content type on shell. msg_type is `comm_info_request`
2017-12-18 11:56:03 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 11:56:03 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 11:56:03 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 11:56:03 - let rec builder (goal, acc, min, max, accSeq) =
2017-12-18 11:56:03 -     match (goal <= acc) with 
2017-12-18 11:56:03 -     | true -> (goal, acc, min, max, accSeq)
2017-12-18 11:56:03 -     | _ -> 
2017-12-18 11:56:03 -         let newSquare = generateSquare min max
2017-12-18 11:56:03 -         builder (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 11:56:03 -         
2017-12-18 11:56:03 - let adventOfCode (goal:int) : int = 
2017-12-18 11:56:03 -     let extractor (_, _, _, _, manDistances) : int seq = 
2017-12-18 11:56:03 -         manDistances
2017-12-18 11:56:03 -         
2017-12-18 11:56:03 -     builder (goal, 0, 1, 2, [])
2017-12-18 11:56:03 -     |> extractor
2017-12-18 11:56:03 -     |> (fun x -> x.[goal-1])
2017-12-18 11:56:03 - The field, constructor or member 'Item' is not defined.
2017-12-18 12:04:38 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 12:04:38 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 12:04:38 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 12:04:38 - let rec squareBuilder (goal, acc, min, max, accSeq) =
2017-12-18 12:04:38 -     match (goal <= acc) with 
2017-12-18 12:04:38 -     | true -> (goal, acc, min, max, accSeq)
2017-12-18 12:04:38 -     | _ -> 
2017-12-18 12:04:38 -         let newSquare = generateSquare min max
2017-12-18 12:04:38 -         squareBuilder (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 12:04:38 -         
2017-12-18 12:04:38 - let adventOfCode (goal:int) : int = 
2017-12-18 12:04:38 -     let extractor (_, _, _, _, manDistances) : int seq = 
2017-12-18 12:04:38 -         manDistances
2017-12-18 12:04:38 -         
2017-12-18 12:04:38 -     squareBuilder (goal, 0, 1, 2, [])
2017-12-18 12:04:38 -     |> extractor
2017-12-18 12:04:38 -     |> Seq.toList
2017-12-18 12:04:38 -     
2017-12-18 12:04:38 - Type mismatch. Expecting a
2017-12-18 12:04:38 -     'seq<int> -> int'    
2017-12-18 12:04:38 - but given a
2017-12-18 12:04:38 -     'seq<int> -> int list'    
2017-12-18 12:04:38 - The type 'int' does not match the type 'int list'
2017-12-18 12:05:19 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 12:05:19 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 12:05:19 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 12:05:19 - let rec squareBuilder (goal, acc, min, max, accSeq) =
2017-12-18 12:05:19 -     match (goal <= acc) with 
2017-12-18 12:05:19 -     | true -> (goal, acc, min, max, accSeq)
2017-12-18 12:05:19 -     | _ -> 
2017-12-18 12:05:19 -         let newSquare = generateSquare min max
2017-12-18 12:05:19 -         squareBuilder (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 12:05:19 -         
2017-12-18 12:05:19 - let adventOfCode (goal:int) : int = 
2017-12-18 12:05:19 -     let extractor (_, _, _, _, manDistances) : seq<int> = 
2017-12-18 12:05:19 -         manDistances
2017-12-18 12:05:19 -         
2017-12-18 12:05:19 -     squareBuilder (goal, 0, 1, 2, [])
2017-12-18 12:05:19 -     |> extractor
2017-12-18 12:05:19 -     |> Seq.toList
2017-12-18 12:05:19 -     
2017-12-18 12:05:19 - Type mismatch. Expecting a
2017-12-18 12:05:19 -     'seq<int> -> int'    
2017-12-18 12:05:19 - but given a
2017-12-18 12:05:19 -     'seq<int> -> int list'    
2017-12-18 12:05:19 - The type 'int' does not match the type 'int list'
2017-12-18 12:06:59 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 12:06:59 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 12:06:59 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 12:06:59 - let rec squareBuilder (goal, acc, min, max, accSeq) =
2017-12-18 12:06:59 -     match (goal <= acc) with 
2017-12-18 12:06:59 -     | true -> (goal, acc, min, max, accSeq)
2017-12-18 12:06:59 -     | _ -> 
2017-12-18 12:06:59 -         let newSquare = generateSquare min max
2017-12-18 12:06:59 -         squareBuilder (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 12:06:59 -         
2017-12-18 12:06:59 - let adventOfCode (goal:int) : int = 
2017-12-18 12:06:59 -     let extractor (_, _, _, _, manDistances) : int seq = 
2017-12-18 12:06:59 -         manDistances
2017-12-18 12:06:59 -         
2017-12-18 12:06:59 -     squareBuilder (goal, 0, 1, 2, [])
2017-12-18 12:06:59 -     |> extractor
2017-12-18 12:06:59 -     |> Seq.toList
2017-12-18 12:06:59 -     |> (func distanceList -> distanceList.[goal-1])
2017-12-18 12:06:59 -     
2017-12-18 12:06:59 - Unexpected symbol '->' in expression
2017-12-18 12:07:09 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 12:07:09 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 12:07:09 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 12:07:09 - let rec squareBuilder (goal, acc, min, max, accSeq) =
2017-12-18 12:07:09 -     match (goal <= acc) with 
2017-12-18 12:07:09 -     | true -> (goal, acc, min, max, accSeq)
2017-12-18 12:07:09 -     | _ -> 
2017-12-18 12:07:09 -         let newSquare = generateSquare min max
2017-12-18 12:07:09 -         squareBuilder (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 12:07:09 -         
2017-12-18 12:07:09 - let adventOfCode (goal:int) : int = 
2017-12-18 12:07:09 -     let extractor (_, _, _, _, manDistances) : int seq = 
2017-12-18 12:07:09 -         manDistances
2017-12-18 12:07:09 -         
2017-12-18 12:07:09 -     squareBuilder (goal, 0, 1, 2, [])
2017-12-18 12:07:09 -     |> extractor
2017-12-18 12:07:09 -     |> Seq.toList
2017-12-18 12:07:09 -     |> (fun distanceList -> distanceList.[goal-1])
2017-12-18 12:07:09 -     
2017-12-18 12:07:35 - adventOfCode 277678
2017-12-18 12:09:09 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 12:09:09 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 12:09:09 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 12:09:09 - let rec squareBuilder (goal, acc, min, max, accSeq) =
2017-12-18 12:09:09 -     match (goal <= acc) with 
2017-12-18 12:09:09 -     | true -> (goal, acc, min, max, accSeq)
2017-12-18 12:09:09 -     | _ -> 
2017-12-18 12:09:09 -         let newSquare = generateSquare min max
2017-12-18 12:09:09 -         squareBuilder (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 12:09:09 -         
2017-12-18 12:09:09 - let adventOfCode (goal:int) : int = 
2017-12-18 12:09:09 -     let extractor (_, _, _, _, manDistances) : int seq = 
2017-12-18 12:09:09 -         manDistances
2017-12-18 12:09:09 -         
2017-12-18 12:09:09 -     squareBuilder (goal, 0, 1, 2, [])
2017-12-18 12:09:09 -     |> extractor
2017-12-18 12:09:09 -     |> Seq.toList
2017-12-18 12:09:09 -     |> (fun distanceList -> distanceList.[goal-2])
2017-12-18 12:09:09 -     
2017-12-18 12:09:09 - adventOfCode 277678
2017-12-18 12:14:35 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 12:14:35 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 12:14:35 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 12:14:35 - let rec squareBuilder2 (goal, acc, min, max, accSeq) =
2017-12-18 12:14:35 -     match (goal <= acc) with 
2017-12-18 12:14:35 -     | true -> (goal, acc, min, max, accSeq)
2017-12-18 12:14:35 -     | _ -> 
2017-12-18 12:14:35 -         let newSquare = generateSquare min max
2017-12-18 12:14:35 -         squareBuilder2 (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 12:14:35 -         
2017-12-18 12:14:35 - let adventOfCode (goal:int) : int = 
2017-12-18 12:14:35 -     let extractor (_, _, _, _, manDistances) : int seq = 
2017-12-18 12:14:35 -         manDistances
2017-12-18 12:14:35 -         
2017-12-18 12:14:35 -     squareBuilder2 (goal, 0, 1, 2, [])
2017-12-18 12:14:35 -     |> extractor
2017-12-18 12:14:35 -     |> Seq.toList
2017-12-18 12:14:35 -     |> (fun distanceList -> distanceList.[goal-2])
2017-12-18 12:14:35 - let rec squareBuilder ((goal, acc, min, max):int*int*int*int) : int seq =
2017-12-18 12:14:35 -     match (goal <= acc) with 
2017-12-18 12:14:35 -     | true -> Seq.empty
2017-12-18 12:14:35 -     | _ -> 
2017-12-18 12:14:35 -         let newSquare = generateSquare min max
2017-12-18 12:14:35 -         squareBuilder (goal, (acc + Seq.length newSquare), (min+1), (max+2))
2017-12-18 12:14:35 -         |> Seq.append newSquare 
2017-12-18 12:22:15 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 12:22:15 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 12:22:15 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 12:22:15 - // let rec squareBuilder2 (goal, acc, min, max, accSeq) =
2017-12-18 12:22:15 - //     match (goal <= acc) with 
2017-12-18 12:22:15 - //     | true -> (goal, acc, min, max, accSeq)
2017-12-18 12:22:15 - //     | _ -> 
2017-12-18 12:22:15 - //         let newSquare = generateSquare min max
2017-12-18 12:22:15 - //         squareBuilder2 (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 12:22:15 - let rec squareBuilder ((goal, acc, min, max):int*int*int*int) : int seq =
2017-12-18 12:22:15 -     match (goal <= acc) with 
2017-12-18 12:22:15 -     | true -> Seq.empty
2017-12-18 12:22:15 -     | _ -> 
2017-12-18 12:22:15 -         let newSquare = generateSquare min max
2017-12-18 12:22:15 -         squareBuilder (goal, (acc + Seq.length newSquare), (min+1), (max+2))
2017-12-18 12:22:15 -         |> Seq.append newSquare
2017-12-18 12:22:15 -         
2017-12-18 12:22:15 - // let adventOfCode2 (goal:int) : int = 
2017-12-18 12:22:15 - //     let extractor (_, _, _, _, manDistances) : int seq = 
2017-12-18 12:22:15 - //         manDistances
2017-12-18 12:22:15 -         
2017-12-18 12:22:15 - //     squareBuilder2 (goal, 0, 1, 2, [])
2017-12-18 12:22:15 - //     |> extractor
2017-12-18 12:22:15 - //     |> Seq.toList
2017-12-18 12:22:15 - //     |> (fun distanceList -> distanceList.[goal-2])
2017-12-18 12:22:15 - let adventOfCode (goal:int) : int = 
2017-12-18 12:22:15 -    
2017-12-18 12:22:15 -     squareBuilder (goal, 0, 1, 2)
2017-12-18 12:22:15 -     |> Seq.toList
2017-12-18 12:22:15 -     |> (fun distanceList -> distanceList.[goal-2])
2017-12-18 12:22:20 - adventOfCode 277678
2017-12-18 12:22:26 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 12:22:26 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 12:22:26 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 12:22:26 - // let rec squareBuilder2 (goal, acc, min, max, accSeq) =
2017-12-18 12:22:26 - //     match (goal <= acc) with 
2017-12-18 12:22:26 - //     | true -> (goal, acc, min, max, accSeq)
2017-12-18 12:22:26 - //     | _ -> 
2017-12-18 12:22:26 - //         let newSquare = generateSquare min max
2017-12-18 12:22:26 - //         squareBuilder2 (goal, (acc + Seq.length newSquare), (min+1), (max+2), Seq.append accSeq newSquare)
2017-12-18 12:22:26 - let rec squareBuilder ((goal, acc, min, max):int*int*int*int) : int seq =
2017-12-18 12:22:26 -     match (goal <= acc) with 
2017-12-18 12:22:26 -     | true -> Seq.empty
2017-12-18 12:22:26 -     | _ -> 
2017-12-18 12:22:26 -         let newSquare = generateSquare min max
2017-12-18 12:22:26 -         squareBuilder (goal, (acc + Seq.length newSquare), (min+1), (max+2))
2017-12-18 12:22:26 -         |> Seq.append newSquare
2017-12-18 12:22:26 -         
2017-12-18 12:22:26 - // let adventOfCode2 (goal:int) : int = 
2017-12-18 12:22:26 - //     let extractor (_, _, _, _, manDistances) : int seq = 
2017-12-18 12:22:26 - //         manDistances
2017-12-18 12:22:26 -         
2017-12-18 12:22:26 - //     squareBuilder2 (goal, 0, 1, 2, [])
2017-12-18 12:22:26 - //     |> extractor
2017-12-18 12:22:26 - //     |> Seq.toList
2017-12-18 12:22:26 - //     |> (fun distanceList -> distanceList.[goal-2])
2017-12-18 12:22:26 - let adventOfCode (goal:int) : int = 
2017-12-18 12:22:26 -    
2017-12-18 12:22:26 -     squareBuilder (goal, 0, 1, 2)
2017-12-18 12:22:26 -     |> Seq.toList
2017-12-18 12:22:26 -     |> (fun distanceList -> distanceList.[goal-2])
2017-12-18 12:22:29 - adventOfCode 277678
2017-12-18 13:10:44 -    
2017-12-18 13:10:44 - let folder ((answer, oldFilter):int*int list) (maxInt:int) : int*int list> =
2017-12-18 13:10:44 -     let newFilter = filterList maxInt oldFilter
2017-12-18 13:10:44 -     
2017-12-18 13:10:44 -     newFilter
2017-12-18 13:10:44 -     |> (helper1 maxInt)
2017-12-18 13:10:44 -     |> (fun additional -> ((answer + additional), newFilter))
2017-12-18 13:10:44 -     
2017-12-18 13:10:45 - Unexpected symbol '>' in binding. Expected '=' or other token.
2017-12-18 13:10:45 - Incomplete structured construct at or before this point in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.
2017-12-18 13:10:45 - parse error
2017-12-18 13:10:57 -    
2017-12-18 13:10:57 - let folder ((answer, oldFilter):int*int list) (maxInt:int) : int*int list =
2017-12-18 13:10:57 -     let newFilter = filterList maxInt oldFilter
2017-12-18 13:10:57 -     
2017-12-18 13:10:57 -     newFilter
2017-12-18 13:10:57 -     |> (helper1 maxInt)
2017-12-18 13:10:57 -     |> (fun additional -> ((answer + additional), newFilter))
2017-12-18 13:10:57 -     
2017-12-18 13:10:57 - The value or constructor 'filterList' is not defined. Maybe you want one of the following:
2017-12-18 13:10:57 -    File
2017-12-18 13:10:57 - The value or constructor 'helper1' is not defined. Maybe you want one of the following:
2017-12-18 13:10:57 -    Help
2017-12-18 13:11:11 -    
2017-12-18 13:11:11 - let folder ((answer, oldFilter):int*int list) (maxInt:int) : int*int list =
2017-12-18 13:11:11 -     let newFilter = filterList maxInt oldFilter
2017-12-18 13:11:11 -     
2017-12-18 13:11:11 -     newFilter
2017-12-18 13:11:11 -     |> (helper1 maxInt)
2017-12-18 13:11:11 -     |> (fun additional -> ((answer + additional), newFilter))
2017-12-18 13:11:11 -     
2017-12-18 13:11:11 - The value or constructor 'filterList' is not defined. Maybe you want one of the following:
2017-12-18 13:11:11 -    File
2017-12-18 13:11:11 - The value or constructor 'helper1' is not defined. Maybe you want one of the following:
2017-12-18 13:11:11 -    Help
2017-12-18 13:11:22 - open System
2017-12-18 13:11:22 - let fullInput = "121	59	141	21	120	67	58	49	22	46	56	112	53	111	104	130
2017-12-18 13:11:22 - 1926	1910	760	2055	28	2242	146	1485	163	976	1842	1982	137	1387	162	789
2017-12-18 13:11:22 - 4088	258	2060	1014	4420	177	4159	194	2794	4673	4092	681	174	2924	170	3548
2017-12-18 13:11:22 - 191	407	253	192	207	425	580	231	197	382	404	472	164	571	500	216
2017-12-18 13:11:22 - 4700	1161	168	5398	5227	5119	252	2552	4887	5060	1152	3297	847	4525	220	262
2017-12-18 13:11:22 - 2417	992	1445	184	554	2940	209	2574	2262	1911	2923	204	2273	2760	506	157
2017-12-18 13:11:22 - 644	155	638	78	385	408	152	360	588	618	313	126	172	220	217	161
2017-12-18 13:11:22 - 227	1047	117	500	1445	222	29	913	190	791	230	1281	1385	226	856	1380
2017-12-18 13:11:22 - 436	46	141	545	122	86	283	124	249	511	347	502	168	468	117	94
2017-12-18 13:11:22 - 2949	3286	2492	2145	1615	159	663	1158	154	939	166	2867	141	324	2862	641
2017-12-18 13:11:22 - 1394	151	90	548	767	1572	150	913	141	1646	154	1351	1506	1510	707	400
2017-12-18 13:11:22 - 646	178	1228	1229	270	167	161	1134	193	1312	1428	131	1457	719	1288	989
2017-12-18 13:11:22 - 1108	1042	93	140	822	124	1037	1075	125	941	1125	298	136	94	135	711
2017-12-18 13:11:22 - 112	2429	1987	2129	2557	1827	477	100	78	634	352	1637	588	77	1624	2500
2017-12-18 13:11:22 - 514	218	209	185	197	137	393	555	588	569	710	537	48	309	519	138
2017-12-18 13:11:22 - 1567	3246	4194	151	3112	903	1575	134	150	4184	3718	4077	180	4307	4097	1705"
2017-12-18 13:11:22 - let stringSplit (input:string) : string[] = 
2017-12-18 13:11:22 -     input.Split()
2017-12-18 13:11:22 - let rec separateBy (rowLength:int) (data: list<int>) : list<list<int>> = 
2017-12-18 13:11:22 -     match data with
2017-12-18 13:11:22 -     | [] -> []
2017-12-18 13:11:22 -     | _ ->
2017-12-18 13:11:22 -         let endPoint = rowLength - 1
2017-12-18 13:11:22 -         let arrayHead = data.[0..endPoint] 
2017-12-18 13:11:22 -         let arrayRest = data.[rowLength..]
2017-12-18 13:11:22 -         
2017-12-18 13:11:22 -         arrayHead :: (separateBy rowLength arrayRest)
2017-12-18 13:11:23 - let dataCleaner (rows:int) (input:string) : list<list<int>> = 
2017-12-18 13:11:23 -     input
2017-12-18 13:11:23 -         |> stringSplit 
2017-12-18 13:11:23 -         |> Array.toList
2017-12-18 13:11:23 -         |> List.map (fun x -> System.Int32.Parse x) 
2017-12-18 13:11:23 -         |> separateBy rows
2017-12-18 13:11:23 -         
2017-12-18 13:11:23 - dataCleaner 16 fullInput
2017-12-18 13:11:23 - let rowDiffer (row : list<int>) : int = 
2017-12-18 13:11:23 -     (Seq.max row) - (Seq.min row) 
2017-12-18 13:11:23 - let adventOfCode2 (rows:int) (data:string) = 
2017-12-18 13:11:23 -     data
2017-12-18 13:11:23 -         |> dataCleaner rows
2017-12-18 13:11:23 -         |> Seq.sumBy rowDiffer
2017-12-18 13:11:23 - adventOfCode2 16 fullInput
2017-12-18 13:11:23 - let divideFactors (dividend:int) (divisor:int) : int = 
2017-12-18 13:11:23 -     if dividend % divisor = 0 then
2017-12-18 13:11:23 -         (dividend / divisor)
2017-12-18 13:11:23 -     else
2017-12-18 13:11:23 -         0
2017-12-18 13:11:23 - let potentialFactor (maxInt:int) (num:int) : bool = 
2017-12-18 13:11:23 -     if num <= maxInt/2 then 
2017-12-18 13:11:23 -         true 
2017-12-18 13:11:23 -     else 
2017-12-18 13:11:23 -         false
2017-12-18 13:11:23 - let filterList (maxInt:int) (data:list<int>) : list<int> =
2017-12-18 13:11:23 -     List.filter (potentialFactor maxInt) data 
2017-12-18 13:11:23 - let helper1 (maxInt:int) (data:list<int>) : int =
2017-12-18 13:11:23 -     data
2017-12-18 13:11:23 -     |> List.map (divideFactors maxInt)
2017-12-18 13:11:23 -     |> List.sum 
2017-12-18 13:11:23 -    
2017-12-18 13:11:23 - let folder ((answer, oldFilter):int*int list) (maxInt:int) : int*int list =
2017-12-18 13:11:23 -     let newFilter = filterList maxInt oldFilter
2017-12-18 13:11:23 -     
2017-12-18 13:11:23 -     newFilter
2017-12-18 13:11:23 -     |> (helper1 maxInt)
2017-12-18 13:11:23 -     |> (fun additional -> ((answer + additional), newFilter))
2017-12-18 13:11:23 -     
2017-12-18 13:11:23 - let solveRow (input:list<int>) : int = 
2017-12-18 13:11:23 -     let startInt = input.Head
2017-12-18 13:11:23 -     
2017-12-18 13:11:23 -     input
2017-12-18 13:11:23 -     |> List.fold folder (0, input) 
2017-12-18 13:11:23 -     |> (fun (answer, _) -> answer)
2017-12-18 13:11:23 - let adventOfCode2Part2 (rows:int) (data:string) = 
2017-12-18 13:11:23 -     data
2017-12-18 13:11:23 -         |> dataCleaner rows
2017-12-18 13:11:23 -         |> List.map (List.sortDescending)
2017-12-18 13:11:23 -         |> List.map solveRow 
2017-12-18 13:11:23 -         |> List.sum 
2017-12-18 13:11:23 - adventOfCode2Part2 16 fullInput
2017-12-18 13:12:41 - squareBuilder 100 0 1 2
2017-12-18 13:12:41 - This value is not a function and cannot be applied
2017-12-18 13:12:46 - squareBuilder (100 0 1 2)
2017-12-18 13:12:46 - This value is not a function and cannot be applied
2017-12-18 13:12:57 - squareBuilder (100, 0, 1, 2)
2017-12-18 13:13:10 - squareBuilder (100, 0, 1, 2) |> Seq.toList
2017-12-18 15:15:34 - type Movement = Up | Left | Down | Right
2017-12-18 15:15:34 - let advanceMovement (movement:Movement) : Movement =
2017-12-18 15:15:34 -     match movement with
2017-12-18 15:15:34 -     | Up -> Left
2017-12-18 15:15:34 -     | Left -> Down
2017-12-18 15:15:34 -     | Down -> Right
2017-12-18 15:15:34 -     | Right -> Up
2017-12-18 15:15:34 -     
2017-12-18 15:15:34 - let instructionSequence (init:Movement) : (Movement*int) seq = 
2017-12-18 15:15:34 -     seq { for i in [1,2] do yield! Seq.map (fun x -> (advanceMovement init, ) ) }
2017-12-18 15:15:34 - Expected an expression after this point
2017-12-18 15:17:00 - type Movement = Up | Left | Down | Right
2017-12-18 15:17:00 - let advanceMovement (movement:Movement) : Movement =
2017-12-18 15:17:00 -     match movement with
2017-12-18 15:17:00 -     | Up -> Left
2017-12-18 15:17:00 -     | Left -> Down
2017-12-18 15:17:00 -     | Down -> Right
2017-12-18 15:17:00 -     | Right -> Up
2017-12-18 15:17:00 -     
2017-12-18 15:17:00 - let instructionSequence (init:Movement) : (Movement*int) seq = 
2017-12-18 15:17:00 -     seq { for i in [1,2] do yield! Seq.map (fun x -> (advanceMovement init, x) ) seq {1..} }
2017-12-18 15:17:00 - Unexpected symbol '}' in expression
2017-12-18 15:17:55 - type Movement = Up | Left | Down | Right
2017-12-18 15:17:55 - let advanceMovement (movement:Movement) : Movement =
2017-12-18 15:17:55 -     match movement with
2017-12-18 15:17:55 -     | Up -> Left
2017-12-18 15:17:55 -     | Left -> Down
2017-12-18 15:17:55 -     | Down -> Right
2017-12-18 15:17:55 -     | Right -> Up
2017-12-18 15:17:55 -     
2017-12-18 15:17:55 - let instructionSequence (init:Movement) : (Movement*int) seq = 
2017-12-18 15:17:55 -     Seq.map (fun x -> (advanceMovement init, x) ) 
2017-12-18 15:17:55 - This expression was expected to have type
2017-12-18 15:17:55 -     'seq<Movement * int>'    
2017-12-18 15:17:55 - but here has type
2017-12-18 15:17:55 -     'seq<obj> -> seq<Movement * obj>'    
2017-12-18 15:17:55 - This expression was expected to have type
2017-12-18 15:17:55 -     'seq<Movement * int>'    
2017-12-18 15:17:55 - but here has type
2017-12-18 15:17:55 -     'seq<obj> -> seq<Movement * obj>'    
2017-12-18 15:57:53 - let seqInfinite = Seq.initInfinite (fun index ->
2017-12-18 15:57:53 -     let n = float( index + 1 )
2017-12-18 15:57:53 -     1.0 / (n * n * (if ((index + 1) % 2 = 0) then 1.0 else -1.0)))
2017-12-18 15:57:53 - printfn "%A" seqInfinite
2017-12-18 16:20:10 - type Movement = Up | Left | Down | Right
2017-12-18 16:20:10 - let advanceMovement (movement:Movement) : Movement =
2017-12-18 16:20:10 -     match movement with
2017-12-18 16:20:10 -     | Up -> Left
2017-12-18 16:20:10 -     | Left -> Down
2017-12-18 16:20:10 -     | Down -> Right
2017-12-18 16:20:10 -     | Right -> Up
2017-12-18 16:20:10 - let infiniCount = Seq.initInfinite (fun index -> index + 1)
2017-12-18 16:20:10 - // let rec instructionSequence (input: int seq) (goal:int) : int = 
2017-12-18 16:20:10 - //     match ( Seq.head input > goal) with
2017-12-18 16:20:10 - //     | true -> Seq.head input
2017-12-18 16:20:10 - //     | _ -> 
2017-12-18 16:20:10 -     
2017-12-18 16:20:30 - Seq.toList infinicount
2017-12-18 16:20:30 - The value or constructor 'infinicount' is not defined. Maybe you want one of the following:
2017-12-18 16:20:30 -    infiniCount
2017-12-18 16:20:30 -    infinity
2017-12-18 16:20:30 -    infinityf
2017-12-18 16:20:36 - type Movement = Up | Left | Down | Right
2017-12-18 16:20:36 - let advanceMovement (movement:Movement) : Movement =
2017-12-18 16:20:36 -     match movement with
2017-12-18 16:20:36 -     | Up -> Left
2017-12-18 16:20:36 -     | Left -> Down
2017-12-18 16:20:36 -     | Down -> Right
2017-12-18 16:20:36 -     | Right -> Up
2017-12-18 16:20:36 - let infiniCount = Seq.initInfinite (fun index -> index + 1)
2017-12-18 16:20:36 - // let rec instructionSequence (input: int seq) (goal:int) : int = 
2017-12-18 16:20:36 - //     match ( Seq.head input > goal) with
2017-12-18 16:20:36 - //     | true -> Seq.head input
2017-12-18 16:20:36 - //     | _ -> 
2017-12-18 16:20:36 -     
2017-12-18 16:20:42 - Seq.toList infinicount
2017-12-18 16:20:42 - The value or constructor 'infinicount' is not defined. Maybe you want one of the following:
2017-12-18 16:20:42 -    infiniCount
2017-12-18 16:20:42 -    infinity
2017-12-18 16:20:42 -    infinityf
2017-12-18 16:20:49 - Seq.toList infiniCount
2017-12-18 16:21:56 - shutdown request
2017-12-18 16:22:00 - // include directory, this will be replaced by the kernel
2017-12-18 16:22:00 - #I "C:\\Users\\misadmin\\Desktop\\F sharp notebook"
2017-12-18 16:22:00 - // load base dlls
2017-12-18 16:22:00 - #r "IfSharp.Kernel.dll"
2017-12-18 16:22:00 - #r "NetMQ.dll"
2017-12-18 16:22:00 - // open the global functions and methods
2017-12-18 16:22:00 - open IfSharp.Kernel
2017-12-18 16:22:00 - open IfSharp.Kernel.Globals
2017-12-18 16:22:07 - F# Interactive for F# 4.1
2017-12-18 16:22:07 - Freely distributed under the Apache 2.0 Open Source License
2017-12-18 16:22:07 - For help type #help;;
2017-12-18 16:22:07 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2017-12-18 16:22:07 -   seq []
2017-12-18 16:22:07 - --> Added 'C:\Users\misadmin\Desktop\F sharp notebook' to library include path
2017-12-18 16:22:07 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2017-12-18 16:22:07 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\NetMQ.dll' (file may be locked by F# Interactive process)
2017-12-18 16:22:08 - let generateSquare (min:int) (max:int): int seq = 
2017-12-18 16:22:08 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-18 16:22:08 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-18 16:22:08 - let rec squareBuilder ((goal, acc, min, max):int*int*int*int) : int seq =
2017-12-18 16:22:08 -     match (goal <= acc) with 
2017-12-18 16:22:08 -     | true -> Seq.empty
2017-12-18 16:22:08 -     | _ -> 
2017-12-18 16:22:08 -         let newSquare = generateSquare min max
2017-12-18 16:22:08 -         squareBuilder (goal, (acc + Seq.length newSquare), (min+1), (max+2))
2017-12-18 16:22:08 -         |> Seq.append newSquare
2017-12-18 16:22:08 -     
2017-12-18 16:22:08 - let adventOfCode (goal:int) : int = 
2017-12-18 16:22:08 -    
2017-12-18 16:22:08 -     squareBuilder (goal, 0, 1, 2)
2017-12-18 16:22:08 -     |> Seq.toList
2017-12-18 16:22:08 -     |> (fun distanceList -> distanceList.[goal-2])
2017-12-18 16:22:08 -     
2017-12-18 16:22:08 - adventOfCode 277678
2017-12-18 16:22:09 - squareBuilder (100, 0, 1, 2) |> Seq.toList
2017-12-18 16:22:09 - type Movement = Up | Left | Down | Right
2017-12-18 16:22:09 - let advanceMovement (movement:Movement) : Movement =
2017-12-18 16:22:09 -     match movement with
2017-12-18 16:22:09 -     | Up -> Left
2017-12-18 16:22:09 -     | Left -> Down
2017-12-18 16:22:09 -     | Down -> Right
2017-12-18 16:22:09 -     | Right -> Up
2017-12-18 16:22:09 - let infiniCount = Seq.initInfinite (fun index -> index + 1)
2017-12-18 16:22:09 - // let rec instructionSequence (input: int seq) (goal:int) : int = 
2017-12-18 16:22:09 - //     match ( Seq.head input > goal) with
2017-12-18 16:22:09 - //     | true -> Seq.head input
2017-12-18 16:22:09 - //     | _ -> 
2017-12-18 16:22:09 -     
2017-12-18 16:22:09 - Seq.take Seq.toList infiniCount
2017-12-18 16:22:09 - This expression was expected to have type
2017-12-18 16:22:09 -     'int'    
2017-12-18 16:22:09 - but here has type
2017-12-18 16:22:09 -     'seq<obj> -> obj list'    
2017-12-18 16:22:50 - type Movement = Up | Left | Down | Right
2017-12-18 16:22:50 - let advanceMovement (movement:Movement) : Movement =
2017-12-18 16:22:50 -     match movement with
2017-12-18 16:22:50 -     | Up -> Left
2017-12-18 16:22:50 -     | Left -> Down
2017-12-18 16:22:50 -     | Down -> Right
2017-12-18 16:22:50 -     | Right -> Up
2017-12-18 16:22:50 - let infiniCount : int seq = 
2017-12-18 16:22:50 -     Seq.initInfinite (fun index -> index + 1)
2017-12-18 16:22:50 - // let rec instructionSequence (input: int seq) (goal:int) : int = 
2017-12-18 16:22:50 - //     match ( Seq.head input > goal) with
2017-12-18 16:22:50 - //     | true -> Seq.head input
2017-12-18 16:22:50 - //     | _ -> 
2017-12-18 16:22:50 -     
2017-12-18 16:22:54 - Seq.take Seq.toList infiniCount
2017-12-18 16:22:54 - This expression was expected to have type
2017-12-18 16:22:54 -     'int'    
2017-12-18 16:22:54 - but here has type
2017-12-18 16:22:54 -     'seq<obj> -> obj list'    
2017-12-18 16:24:06 - Seq.find (fun x -> x > 10) infiniCount
2017-12-18 16:43:44 - type Point = int*int
2017-12-18 16:43:44 - Point 2 4
2017-12-18 16:43:44 - The value or constructor 'Point' is not defined.
2017-12-18 16:44:11 - type Point = int * int
2017-12-18 16:44:11 - Point 2 4
2017-12-18 16:44:11 - The value or constructor 'Point' is not defined.
2017-12-18 16:44:19 - type Point = int * int
2017-12-18 16:44:19 - Point (2, 4)
2017-12-18 16:44:19 - The value or constructor 'Point' is not defined.
2017-12-18 16:44:28 - type Point2 = int * int
2017-12-18 16:44:28 - Point2 (2, 4)
2017-12-18 16:44:28 - The value or constructor 'Point2' is not defined.
2017-12-18 16:44:42 - type Point2 = int * int
2017-12-18 16:44:42 - let val = Point2 4 5
2017-12-18 16:44:42 - val
2017-12-18 16:44:42 - Unexpected keyword 'val' in binding
2017-12-18 16:44:42 - parse error
2017-12-18 16:44:46 - type Point2 = int * int
2017-12-18 16:44:46 - let valt = Point2 4 5
2017-12-18 16:44:46 - valt
2017-12-18 16:44:46 - The value or constructor 'Point2' is not defined.
2017-12-18 16:49:06 - type Movement = Up | Left | Down | Right
2017-12-18 16:49:06 - type Point = (int, int)
2017-12-18 16:49:06 - let advanceMovement (movement:Movement) : Movement =
2017-12-18 16:49:06 -     match movement with
2017-12-18 16:49:06 -     | Up -> Left
2017-12-18 16:49:06 -     | Left -> Down
2017-12-18 16:49:06 -     | Down -> Right
2017-12-18 16:49:06 -     | Right -> Up
2017-12-18 16:49:06 - let updatePoint (movement:Movement) (point:Point) : Point =
2017-12-18 16:49:06 -     match point with
2017-12-18 16:49:06 -     | Up -> point |> (fun (x, y) -> )
2017-12-18 16:49:06 -     
2017-12-18 16:49:06 - let infiniCount : int seq = 
2017-12-18 16:49:06 -     Seq.initInfinite (fun index -> index + 1)
2017-12-18 16:49:06 -     
2017-12-18 16:49:06 - let folder ((movement, point, dataStream):Movement*int seq) (num:int) : Movement*Point*int seq =
2017-12-18 16:49:06 -     let newMove = advanceMovement movement
2017-12-18 16:49:06 -     let firstSeq = seq { }
2017-12-18 16:49:06 - // let rec instructionSequence (input: int seq) (goal:int) : int = 
2017-12-18 16:49:06 - //     match ( Seq.head input > goal) with
2017-12-18 16:49:06 - //     | true -> Seq.head input
2017-12-18 16:49:06 - //     | _ -> 
2017-12-18 16:49:06 -     
2017-12-18 16:49:06 - Incomplete structured construct at or before this point in type definition
2017-12-18 16:49:06 - Unexpected symbol ':' in member definition
2017-12-18 16:49:06 - Missing function body
2017-12-18 16:49:06 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2017-12-18 16:49:06 - Unexpected end of input in type definition
2017-12-18 16:49:06 - Anonymous type variables are not permitted in this declaration
2017-12-18 16:49:06 - Anonymous type variables are not permitted in this declaration
2017-12-18 16:49:06 - This construct is deprecated: This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as 'type C<'a> = C of ...'.
2017-12-18 16:49:06 - Type abbreviations cannot have augmentations
2017-12-18 16:49:06 - This declaration element is not permitted in an augmentation
2017-12-18 16:49:14 - type Movement = Up | Left | Down | Right
2017-12-18 16:49:14 - type Point = (int, int)
2017-12-18 16:49:14 - let advanceMovement (movement:Movement) : Movement =
2017-12-18 16:49:14 -     match movement with
2017-12-18 16:49:14 -     | Up -> Left
2017-12-18 16:49:14 -     | Left -> Down
2017-12-18 16:49:14 -     | Down -> Right
2017-12-18 16:49:14 -     | Right -> Up
2017-12-18 16:49:14 - // let updatePoint (movement:Movement) (point:Point) : Point =
2017-12-18 16:49:14 - //     match point with
2017-12-18 16:49:14 - //     | Up -> point |> (fun (x, y) -> )
2017-12-18 16:49:14 -     
2017-12-18 16:49:14 - let infiniCount : int seq = 
2017-12-18 16:49:14 -     Seq.initInfinite (fun index -> index + 1)
2017-12-18 16:49:14 -     
2017-12-18 16:49:14 - let folder ((movement, point, dataStream):Movement*int seq) (num:int) : Movement*Point*int seq =
2017-12-18 16:49:14 -     let newMove = advanceMovement movement
2017-12-18 16:49:14 -     let firstSeq = seq { }
2017-12-18 16:49:14 - // let rec instructionSequence (input: int seq) (goal:int) : int = 
2017-12-18 16:49:14 - //     match ( Seq.head input > goal) with
2017-12-18 16:49:14 - //     | true -> Seq.head input
2017-12-18 16:49:14 - //     | _ -> 
2017-12-18 16:49:14 -     
2017-12-18 16:49:14 - Incomplete structured construct at or before this point in type definition
2017-12-18 16:49:14 - Unexpected symbol ':' in member definition
2017-12-18 16:49:14 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2017-12-18 16:49:14 - Unexpected end of input in type definition
2017-12-18 16:49:14 - Anonymous type variables are not permitted in this declaration
2017-12-18 16:49:14 - Anonymous type variables are not permitted in this declaration
2017-12-18 16:49:14 - This construct is deprecated: This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as 'type C<'a> = C of ...'.
2017-12-18 16:49:14 - Type abbreviations cannot have augmentations
2017-12-18 16:49:14 - This declaration element is not permitted in an augmentation
2017-12-18 16:49:35 - type Point2 = (int, int)
2017-12-18 16:49:35 - let valt (point: Point) = Point2 4 5
2017-12-18 16:49:35 - valt
2017-12-18 16:49:35 - Incomplete structured construct at or before this point in type definition
2017-12-18 16:49:35 - Unexpected symbol '=' in member definition
2017-12-18 16:49:35 - parse error
2017-12-18 16:49:47 - type Point2 = int*int
2017-12-18 16:49:47 - let valt (point: Point) = Point2 4 5
2017-12-18 16:49:47 - valt
2017-12-18 16:49:47 - The type 'Point' is not defined. Maybe you want one of the following:
2017-12-18 16:49:47 -    Point2
2017-12-18 16:49:47 -    int
2017-12-18 16:49:47 -    Pyin
2017-12-18 16:49:47 - The value or constructor 'Point2' is not defined.
2017-12-18 16:49:53 - type Point2 = int*int
2017-12-18 16:49:53 - let valt (point: Point2) = Point2 4 5
2017-12-18 16:49:53 - valt
2017-12-18 16:49:53 - The value or constructor 'Point2' is not defined.
2017-12-18 16:50:36 - type Point2 = int*int
2017-12-18 16:50:36 - let valt (point: Point2) : int = point |> (fun (x, y) -> x)
2017-12-18 16:50:36 - valt
2017-12-18 16:50:45 - type Point2 = int*int
2017-12-18 16:50:45 - let valt (point: Point2) : int = point |> (fun (x, y) -> x)
2017-12-18 16:50:45 - valt 5.6
2017-12-18 16:50:45 - This expression was expected to have type
2017-12-18 16:50:45 -     'Point2'    
2017-12-18 16:50:45 - but here has type
2017-12-18 16:50:45 -     'float'    
2017-12-18 16:50:52 - type Point2 = int*int
2017-12-18 16:50:52 - let valt (point: Point2) : int = point |> (fun (x, y) -> x)
2017-12-18 16:50:52 - valt 5,6
2017-12-18 16:50:52 - This expression was expected to have type
2017-12-18 16:50:52 -     'Point2'    
2017-12-18 16:50:52 - but here has type
2017-12-18 16:50:52 -     'int'    
2017-12-18 16:50:53 - type Point2 = int*int
2017-12-18 16:50:53 - let valt (point: Point2) : int = point |> (fun (x, y) -> x)
2017-12-18 16:50:53 - valt 5,6
2017-12-18 16:50:53 - This expression was expected to have type
2017-12-18 16:50:53 -     'Point2'    
2017-12-18 16:50:53 - but here has type
2017-12-18 16:50:53 -     'int'    
2017-12-18 16:50:58 - type Point2 = int*int
2017-12-18 16:50:58 - let valt (point: Point2) : int = point |> (fun (x, y) -> x)
2017-12-18 16:50:58 - valt (5,6)
2017-12-18 17:27:34 - type Movement = Up | Left | Down | Right
2017-12-18 17:27:34 - type Point = (int, int)
2017-12-18 17:27:34 - let advanceMovement (movement:Movement) : Movement =
2017-12-18 17:27:34 -     match movement with
2017-12-18 17:27:34 -     | Up -> Left
2017-12-18 17:27:34 -     | Left -> Down
2017-12-18 17:27:34 -     | Down -> Right
2017-12-18 17:27:34 -     | Right -> Up
2017-12-18 17:27:34 - let updatePoint (movement:Movement) (point:Point) : Point =
2017-12-18 17:27:34 -     match point with
2017-12-18 17:27:34 -     | Up -> point |> (fun (x, y) -> x, y+1)
2017-12-18 17:27:34 -     | Left -> point |> (fun (x, y) -> x-1, y)
2017-12-18 17:27:34 -     | Down -> point |> (fun (x, y) -> x, y-1)
2017-12-18 17:27:34 -     | Right -> point |> (fun (x, y) -> x+1, y)
2017-12-18 17:27:34 - let infiniCount : int seq = 
2017-12-18 17:27:34 -     Seq.initInfinite (fun index -> index + 1)
2017-12-18 17:27:34 - let folder ((moveState, pointState):Movement*Point seq) (num:int) : Movement*Point seq =
2017-12-18 17:27:34 -     let newMoveState = 
2017-12-18 17:27:34 -         advanceMovement moveState
2017-12-18 17:27:34 -     
2017-12-18 17:27:34 -     let newPoint = 
2017-12-18 17:27:34 -         Seq.last pointState 
2017-12-18 17:27:34 -         |> updatePoint moveState
2017-12-18 17:27:34 -     
2017-12-18 17:27:34 -     (newMoveState, Seq.append pointState {newPoint} )
2017-12-18 17:27:34 - // let folder2 ((movement, point, dataStream):Movement*int seq) (num:int) : Movement*Point*int seq =
2017-12-18 17:27:34 - //     let fstMove = advanceMovement movement
2017-12-18 17:27:34 - //     let fstSeq = seq { for i in 1 to 4 do yield (updatePoint firstMove point) }
2017-12-18 17:27:34 - //     let sndMove = advanceMovement fstMove
2017-12-18 17:27:34 - //     let sndSeq = seq { for i in 1 to 4 do yield (updatePoint )}
2017-12-18 17:27:34 - // let rec instructionSequence (input: int seq) (goal:int) : int = 
2017-12-18 17:27:34 - //     match ( Seq.head input > goal) with
2017-12-18 17:27:34 - //     | true -> Seq.head input
2017-12-18 17:27:34 - //     | _ -> 
2017-12-18 17:27:34 -     
2017-12-18 17:27:34 - Incomplete structured construct at or before this point in type definition
2017-12-18 17:27:34 - Unexpected symbol ':' in member definition
2017-12-18 17:27:34 - Unexpected end of input in type definition
2017-12-18 17:27:34 - Anonymous type variables are not permitted in this declaration
2017-12-18 17:27:34 - Anonymous type variables are not permitted in this declaration
2017-12-18 17:27:34 - This construct is deprecated: This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as 'type C<'a> = C of ...'.
2017-12-18 17:27:34 - Type abbreviations cannot have augmentations
2017-12-18 17:27:34 - This declaration element is not permitted in an augmentation
2017-12-18 17:28:34 - type Movement = Up | Left | Down | Right
2017-12-18 17:28:39 - type Point = (int, int)
2017-12-18 17:28:39 - Incomplete structured construct at or before this point in type definition
2017-12-18 17:28:39 - parse error
2017-12-18 17:28:50 - type Point = int*int
2017-12-18 17:28:58 - let advanceMovement (movement:Movement) : Movement =
2017-12-18 17:28:58 -     match movement with
2017-12-18 17:28:58 -     | Up -> Left
2017-12-18 17:28:58 -     | Left -> Down
2017-12-18 17:28:58 -     | Down -> Right
2017-12-18 17:28:58 -     | Right -> Up
2017-12-18 17:28:58 -     
2017-12-18 17:29:10 - let updatePoint (movement:Movement) (point:Point) : Point =
2017-12-18 17:29:10 -     match point with
2017-12-18 17:29:10 -     | Up -> point |> (fun (x, y) -> x, y+1)
2017-12-18 17:29:10 -     | Left -> point |> (fun (x, y) -> x-1, y)
2017-12-18 17:29:10 -     | Down -> point |> (fun (x, y) -> x, y-1)
2017-12-18 17:29:10 -     | Right -> point |> (fun (x, y) -> x+1, y)
2017-12-18 17:29:10 - This expression was expected to have type
2017-12-18 17:29:10 -     'Point'    
2017-12-18 17:29:10 - but here has type
2017-12-18 17:29:10 -     'Movement'    
2017-12-18 17:29:35 - let updatePoint (movement:Movement) (point:Point) : Point =
2017-12-18 17:29:35 -     match movement with
2017-12-18 17:29:35 -     | Up -> point |> (fun (x, y) -> x, y+1)
2017-12-18 17:29:35 -     | Left -> point |> (fun (x, y) -> x-1, y)
2017-12-18 17:29:35 -     | Down -> point |> (fun (x, y) -> x, y-1)
2017-12-18 17:29:35 -     | Right -> point |> (fun (x, y) -> x+1, y)
2017-12-18 17:29:51 - let infiniCount : int seq = 
2017-12-18 17:29:51 -     Seq.initInfinite (fun index -> index + 1)
2017-12-18 17:30:02 - let folder ((moveState, pointState):Movement*Point seq) (num:int) : Movement*Point seq =
2017-12-18 17:30:02 -     let newMoveState = 
2017-12-18 17:30:02 -         advanceMovement moveState
2017-12-18 17:30:02 -     
2017-12-18 17:30:02 -     let newPoint = 
2017-12-18 17:30:02 -         Seq.last pointState 
2017-12-18 17:30:02 -         |> updatePoint moveState
2017-12-18 17:30:02 -     
2017-12-18 17:30:02 -     (newMoveState, Seq.append pointState {newPoint,} )
2017-12-18 17:30:02 - // let folder2 ((movement, point, dataStream):Movement*int seq) (num:int) : Movement*Point*int seq =
2017-12-18 17:30:02 - //     let fstMove = advanceMovement movement
2017-12-18 17:30:02 - //     let fstSeq = seq { for i in 1 to 4 do yield (updatePoint firstMove point) }
2017-12-18 17:30:02 - //     let sndMove = advanceMovement fstMove
2017-12-18 17:30:02 - //     let sndSeq = seq { for i in 1 to 4 do yield (updatePoint )}
2017-12-18 17:30:02 - // let rec instructionSequence (input: int seq) (goal:int) : int = 
2017-12-18 17:30:02 - //     match ( Seq.head input > goal) with
2017-12-18 17:30:02 - //     | true -> Seq.head input
2017-12-18 17:30:02 - //     | _ -> 
2017-12-18 17:30:02 -     
2017-12-18 17:30:02 - Expected an expression after this point
2017-12-18 17:30:14 - let folder ((moveState, pointState):Movement*Point seq) (num:int) : Movement*Point seq =
2017-12-18 17:30:14 -     let newMoveState = 
2017-12-18 17:30:14 -         advanceMovement moveState
2017-12-18 17:30:14 -     
2017-12-18 17:30:14 -     let newPoint = 
2017-12-18 17:30:14 -         Seq.last pointState 
2017-12-18 17:30:14 -         |> updatePoint moveState
2017-12-18 17:30:14 -     
2017-12-18 17:30:14 -     (newMoveState, Seq.append pointState {newPoint,} )
2017-12-18 17:30:14 - Expected an expression after this point
2017-12-18 17:32:46 - let folder ((moveState, pointState):Movement*Point seq) (num:int) : Movement*Point seq =
2017-12-18 17:32:46 -     let newMoveState = 
2017-12-18 17:32:46 -         advanceMovement moveState
2017-12-18 17:32:46 -     
2017-12-18 17:32:46 -     let newPoint = 
2017-12-18 17:32:46 -         Seq.last pointState 
2017-12-18 17:32:46 -         |> updatePoint moveState
2017-12-18 17:32:46 -     
2017-12-18 17:32:46 -     newPoint
2017-12-18 17:32:46 -     |> Seq.singleton
2017-12-18 17:32:46 -     |> Seq.append pointState
2017-12-18 17:32:46 -     |> (fun x -> (newMoveState, x))
2017-12-18 17:59:17 - let subFolder ((moveState, pointState):Movement*Point seq) (num:int) : Movement*Point seq =
2017-12-18 17:59:17 -     
2017-12-18 17:59:17 -     let newPoint = 
2017-12-18 17:59:17 -         Seq.last pointState 
2017-12-18 17:59:17 -         |> updatePoint moveState
2017-12-18 17:59:17 -     
2017-12-18 17:59:17 -     newPoint
2017-12-18 17:59:17 -     |> Seq.singleton
2017-12-18 17:59:17 -     |> Seq.append pointState
2017-12-18 17:59:17 -     |> (fun x -> (moveState, x))
2017-12-18 18:00:44 - let subFolder ((moveState, pointState):Movement*Point seq) (num:int) : Movement*Point seq =
2017-12-18 18:00:44 -     
2017-12-18 18:00:44 -     let (fstMove, fstPoints) = Seq.fold subfolder (advanceMovement moveState, Seq.last pointState) {1..4}
2017-12-18 18:00:44 -     
2017-12-18 18:00:44 -     let (newMove, sndPoints) = Seq.fold subfolder (advanceMovement fstMove, Seq.last fstPoints) {1..4}
2017-12-18 18:00:44 -     
2017-12-18 18:00:44 -     Seq.append fstPoints sndPoints
2017-12-18 18:00:44 -     
2017-12-18 18:00:44 -     
2017-12-18 18:00:44 -     
2017-12-18 18:00:44 -     
2017-12-18 18:00:44 - The value or constructor 'subfolder' is not defined. Maybe you want one of the following:
2017-12-18 18:00:44 -    subFolder
2017-12-18 18:00:44 -    Folder
2017-12-18 18:00:44 -    folder
2017-12-18 18:00:44 - The value or constructor 'subfolder' is not defined. Maybe you want one of the following:
2017-12-18 18:00:44 -    subFolder
2017-12-18 18:00:44 -    Folder
2017-12-18 18:00:44 -    folder
2017-12-18 18:00:44 - The type 'Point' is not compatible with the type 'seq<seq<obj>>'
2017-12-18 18:00:44 - This expression was expected to have type
2017-12-18 18:00:44 -     'Movement * seq<Point>'    
2017-12-18 18:00:44 - but here has type
2017-12-18 18:00:44 -     'seq<obj>'    
2017-12-18 18:00:44 - The type 'Point' is not compatible with the type 'seq<obj>'
2017-12-18 18:00:44 - This expression was expected to have type
2017-12-18 18:00:44 -     'Movement * seq<Point>'    
2017-12-18 18:00:44 - but here has type
2017-12-18 18:00:44 -     'seq<obj>'    
2017-12-18 18:02:02 - let folder ((moveState, pointState):Movement*Point seq) (num:int) : Movement*Point seq =
2017-12-18 18:02:02 -     
2017-12-18 18:02:02 -     let (fstMove, fstPoints) = Seq.fold subFolder (advanceMovement moveState, Seq.last pointState) {1..4}
2017-12-18 18:02:02 -     
2017-12-18 18:02:02 -     let (newMove, sndPoints) = Seq.fold subFolder (advanceMovement fstMove, Seq.last fstPoints) {1..4}
2017-12-18 18:02:02 -     
2017-12-18 18:02:02 -     (newMove, Seq.append fstPoints sndPoints)
2017-12-18 18:02:02 -     
2017-12-18 18:02:02 -     
2017-12-18 18:02:02 -     
2017-12-18 18:02:02 -     
2017-12-18 18:02:02 - The type 'seq<Point>' does not match the type 'Point'
2017-12-18 18:02:02 - The type 'seq<Point>' does not match the type 'Point'
2017-12-18 18:20:50 - let folder ((moveState, pointState):Movement*Point seq) (num:int) : Movement*Point seq =
2017-12-18 18:20:50 -     
2017-12-18 18:20:50 -     let (fstMove, fstPoints) = Seq.fold subFolder (advanceMovement moveState, pointState) {1..4}
2017-12-18 18:20:50 -     
2017-12-18 18:20:50 -     let (newMove, sndPoints) = Seq.fold subFolder (advanceMovement fstMove, fstPoints) {1..4}
2017-12-18 18:20:50 -     
2017-12-18 18:20:50 -     (newMove, Seq.append fstPoints sndPoints)
2017-12-18 18:20:50 -     
2017-12-18 18:20:50 -     
2017-12-18 18:20:50 -     
2017-12-18 18:20:50 -     
2017-12-18 18:20:55 - let folder ((moveState, pointState):Movement*Point seq) (num:int) : Movement*Point seq =
2017-12-18 18:20:55 -     
2017-12-18 18:20:55 -     let (fstMove, fstPoints) = Seq.fold subFolder (advanceMovement moveState, pointState) {1..4}
2017-12-18 18:20:55 -     
2017-12-18 18:20:55 -     let (newMove, sndPoints) = Seq.fold subFolder (advanceMovement fstMove, fstPoints) {1..4}
2017-12-18 18:20:55 -     
2017-12-18 18:20:55 -     (newMove, Seq.append fstPoints sndPoints)
2017-12-18 18:20:55 -     
2017-12-18 18:20:55 -     
2017-12-18 18:20:55 -     
2017-12-18 18:20:55 -     
2017-12-20 09:58:32 - type Point = int*int
2017-12-20 10:24:43 - let subFolder ((moveState, pointState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 10:24:43 -     
2017-12-20 10:24:43 -     let newPoint = 
2017-12-20 10:24:43 -         Seq.last pointState 
2017-12-20 10:24:43 -         |> (fun (point, num) -> updatePoint moveState
2017-12-20 10:24:43 -     
2017-12-20 10:24:43 -     newPoint
2017-12-20 10:24:43 -     |> Seq.singleton
2017-12-20 10:24:43 -     |> Seq.append pointState
2017-12-20 10:24:43 -     |> (fun x -> (moveState, x))
2017-12-20 10:24:43 - Unexpected identifier in expression
2017-12-20 10:24:43 - Possible incorrect indentation: this token is offside of context started at position (4:9). Try indenting this token further or using standard formatting conventions.
2017-12-20 10:24:43 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2017-12-20 10:24:43 - The type 'Item' is not defined.
2017-12-20 10:24:48 - let subFolder ((moveState, pointState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 10:24:48 -     
2017-12-20 10:24:48 -     let newPoint = 
2017-12-20 10:24:48 -         Seq.last pointState 
2017-12-20 10:24:48 -         |> (fun (point, num) -> updatePoint moveState)
2017-12-20 10:24:48 -     
2017-12-20 10:24:48 -     newPoint
2017-12-20 10:24:48 -     |> Seq.singleton
2017-12-20 10:24:48 -     |> Seq.append pointState
2017-12-20 10:24:48 -     |> (fun x -> (moveState, x))
2017-12-20 10:24:48 - The type 'Item' is not defined.
2017-12-20 10:24:48 - The type 'Item' is not defined.
2017-12-20 10:24:48 - The type 'Point -> Point' does not match the type ''a * 'b'
2017-12-20 10:24:56 - let generateSquare (min:int) (max:int): int seq = 
2017-12-20 10:24:56 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-20 10:24:56 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-20 10:24:56 - let rec squareBuilder ((goal, acc, min, max):int*int*int*int) : int seq =
2017-12-20 10:24:56 -     match (goal <= acc) with 
2017-12-20 10:24:56 -     | true -> Seq.empty
2017-12-20 10:24:56 -     | _ -> 
2017-12-20 10:24:56 -         let newSquare = generateSquare min max
2017-12-20 10:24:56 -         squareBuilder (goal, (acc + Seq.length newSquare), (min+1), (max+2))
2017-12-20 10:24:56 -         |> Seq.append newSquare
2017-12-20 10:24:56 -     
2017-12-20 10:24:56 - let adventOfCode (goal:int) : int = 
2017-12-20 10:24:56 -    
2017-12-20 10:24:56 -     squareBuilder (goal, 0, 1, 2)
2017-12-20 10:24:56 -     |> Seq.toList
2017-12-20 10:24:56 -     |> (fun distanceList -> distanceList.[goal-2])
2017-12-20 10:24:56 -     
2017-12-20 10:24:56 - adventOfCode 277678
2017-12-20 10:24:56 - squareBuilder (100, 0, 1, 2) |> Seq.toList
2017-12-20 10:24:57 - type Movement = Up | Left | Down | Right
2017-12-20 10:24:57 - let advanceMovement (movement:Movement) : Movement =
2017-12-20 10:24:57 -     match movement with
2017-12-20 10:24:57 -     | Up -> Left
2017-12-20 10:24:57 -     | Left -> Down
2017-12-20 10:24:57 -     | Down -> Right
2017-12-20 10:24:57 -     | Right -> Up
2017-12-20 10:24:57 -     
2017-12-20 10:24:57 - type Point = int*int
2017-12-20 10:24:57 - type Item = Point*int
2017-12-20 10:24:57 - // let getVal (((x,y), num):Item) (data:Item seq) : int = 
2017-12-20 10:24:57 - //     Seq.find (fun )
2017-12-20 10:24:57 -     
2017-12-20 10:24:57 -     
2017-12-20 10:24:57 - let updatePoint (movement:Movement) (point:Point) : Point =
2017-12-20 10:24:57 -     match movement with
2017-12-20 10:24:57 -     | Up -> point |> (fun (x, y) -> x, y+1)
2017-12-20 10:24:57 -     | Left -> point |> (fun (x, y) -> x-1, y)
2017-12-20 10:24:57 -     | Down -> point |> (fun (x, y) -> x, y-1)
2017-12-20 10:24:57 -     | Right -> point |> (fun (x, y) -> x+1, y)
2017-12-20 10:24:57 - let infiniCount : int seq = 
2017-12-20 10:24:57 -     Seq.initInfinite (fun index -> index + 1)
2017-12-20 10:24:57 - let subFolder ((moveState, pointState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 10:24:57 -     
2017-12-20 10:24:57 -     let newPoint = 
2017-12-20 10:24:57 -         Seq.last pointState 
2017-12-20 10:24:57 -         |> (fun (point, num) -> updatePoint moveState)
2017-12-20 10:24:57 -     
2017-12-20 10:24:57 -     newPoint
2017-12-20 10:24:57 -     |> Seq.singleton
2017-12-20 10:24:57 -     |> Seq.append pointState
2017-12-20 10:24:57 -     |> (fun x -> (moveState, x))
2017-12-20 10:24:57 - The type 'Point -> Point' does not match the type 'Item'
2017-12-20 10:24:57 - Type mismatch. Expecting a
2017-12-20 10:24:57 -     'seq<Item>'    
2017-12-20 10:24:57 - but given a
2017-12-20 10:24:57 -     'seq<(Point -> Point)>'    
2017-12-20 10:24:57 - The type 'Item' does not match the type 'Point -> Point'
2017-12-20 10:24:57 - let folder ((moveState, pointState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 10:24:57 -     
2017-12-20 10:24:57 -     let (fstMove, fstPoints) = Seq.fold subFolder (advanceMovement moveState, pointState) {1..num}
2017-12-20 10:24:57 -     
2017-12-20 10:24:57 -     let (newMove, sndPoints) = Seq.fold subFolder (advanceMovement fstMove, fstPoints) {1..num}
2017-12-20 10:24:57 -     
2017-12-20 10:24:57 -     (newMove, Seq.append fstPoints sndPoints)
2017-12-20 10:24:57 -     
2017-12-20 10:24:57 -     
2017-12-20 10:24:57 - This expression was expected to have type
2017-12-20 10:24:57 -     'FSI_0032.Movement'    
2017-12-20 10:24:57 - but here has type
2017-12-20 10:24:57 -     'FSI_0054.Movement'    
2017-12-20 10:24:57 - This expression was expected to have type
2017-12-20 10:24:57 -     'FSI_0032.Movement'    
2017-12-20 10:24:57 - but here has type
2017-12-20 10:24:57 -     'FSI_0054.Movement'    
2017-12-20 10:24:57 - Type mismatch. Expecting a
2017-12-20 10:24:57 -     'seq<Point>'    
2017-12-20 10:24:57 - but given a
2017-12-20 10:24:57 -     'seq<Item>'    
2017-12-20 10:24:57 - The type 'int' does not match the type 'Point'
2017-12-20 10:24:57 - This expression was expected to have type
2017-12-20 10:24:57 -     'FSI_0032.Movement'    
2017-12-20 10:24:57 - but here has type
2017-12-20 10:24:57 -     'FSI_0054.Movement'    
2017-12-20 10:24:57 - This expression was expected to have type
2017-12-20 10:24:57 -     'FSI_0054.Movement'    
2017-12-20 10:24:57 - but here has type
2017-12-20 10:24:57 -     'FSI_0032.Movement'    
2017-12-20 10:24:57 - This expression was expected to have type
2017-12-20 10:24:57 -     'FSI_0032.Movement'    
2017-12-20 10:24:57 - but here has type
2017-12-20 10:24:57 -     'FSI_0054.Movement'    
2017-12-20 10:24:57 - This expression was expected to have type
2017-12-20 10:24:57 -     'FSI_0054.Movement'    
2017-12-20 10:24:57 - but here has type
2017-12-20 10:24:57 -     'FSI_0032.Movement'    
2017-12-20 10:24:57 - The type 'Point' does not match the type 'int'
2017-12-20 10:24:57 - The type 'Point' does not match the type 'int'
2017-12-20 10:24:57 - // let folder2 ((movement, point, dataStream):Movement*int seq) (num:int) : Movement*Point*int seq =
2017-12-20 10:24:57 - //     let fstMove = advanceMovement movement
2017-12-20 10:24:57 - //     let fstSeq = seq { for i in 1 to 4 do yield (updatePoint firstMove point) }
2017-12-20 10:24:57 - //     let sndMove = advanceMovement fstMove
2017-12-20 10:24:57 - //     let sndSeq = seq { for i in 1 to 4 do yield (updatePoint )}
2017-12-20 10:24:57 - // let rec instructionSequence (input: int seq) (goal:int) : int = 
2017-12-20 10:24:57 - //     match ( Seq.head input > goal) with
2017-12-20 10:24:57 - //     | true -> Seq.head input
2017-12-20 10:24:57 - //     | _ -> 
2017-12-20 10:24:57 -     
2017-12-20 10:24:57 - type Point2 = int*int
2017-12-20 10:24:57 - let valt (point: Point2) : int = point |> (fun (x, y) -> x)
2017-12-20 10:24:57 - valt (5,6)
2017-12-20 10:26:34 - let subFolder ((moveState, pointState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 10:26:34 -     
2017-12-20 10:26:34 -     let newPoint = 
2017-12-20 10:26:34 -         Seq.last pointState 
2017-12-20 10:26:34 -         |> (fun (point, _) -> point)
2017-12-20 10:26:34 -         |> updatePoint moveState
2017-12-20 10:26:34 -     
2017-12-20 10:26:34 -     newPoint
2017-12-20 10:26:34 -     |> Seq.singleton
2017-12-20 10:26:34 -     |> Seq.append pointState
2017-12-20 10:26:34 -     |> (fun x -> (moveState, x))
2017-12-20 10:26:34 - The type 'int' does not match the type 'Point'
2017-12-20 10:26:34 - Type mismatch. Expecting a
2017-12-20 10:26:34 -     'seq<Item>'    
2017-12-20 10:26:34 - but given a
2017-12-20 10:26:34 -     'seq<Point>'    
2017-12-20 10:26:34 - The type 'Point' does not match the type 'int'
2017-12-20 10:32:25 - let subFolder ((moveState, itemState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 10:32:25 -     
2017-12-20 10:32:25 -     let newPoint = 
2017-12-20 10:32:25 -         Seq.last itemState 
2017-12-20 10:32:25 -         |> (fun (point, _) -> point)
2017-12-20 10:32:25 -         |> updatePoint moveState
2017-12-20 10:32:25 -     
2017-12-20 10:32:25 -     let newItem = 
2017-12-20 10:32:25 -         itemState 
2017-12-20 10:32:25 -         |> (fun (point, itemState) -> (point, getVal point, itemState)
2017-12-20 10:32:25 -     
2017-12-20 10:32:25 -     newPoint
2017-12-20 10:32:25 -     |> Seq.singleton
2017-12-20 10:32:25 -     |> Seq.append pointState
2017-12-20 10:32:25 -     |> (fun x -> (moveState, x))
2017-12-20 10:32:25 - Unexpected identifier in expression
2017-12-20 10:32:25 - Possible incorrect indentation: this token is offside of context started at position (9:9). Try indenting this token further or using standard formatting conventions.
2017-12-20 10:32:25 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2017-12-20 10:34:11 - let subFolder ((moveState, itemState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 10:34:11 -     
2017-12-20 10:34:11 -     let newPoint = 
2017-12-20 10:34:11 -         Seq.last itemState 
2017-12-20 10:34:11 -         |> (fun (point, _) -> point)
2017-12-20 10:34:11 -         |> updatePoint moveState
2017-12-20 10:34:11 -     
2017-12-20 10:34:11 - //     let newItem = 
2017-12-20 10:34:11 - //         itemState 
2017-12-20 10:34:11 - //         |> (fun (point, itemState) -> (point, getVal point, itemState)
2017-12-20 10:34:11 -     
2017-12-20 10:34:11 -     newPoint
2017-12-20 10:34:11 -     |> Seq.singleton
2017-12-20 10:34:11 -     |> Seq.append pointState
2017-12-20 10:34:11 -     |> (fun x -> (moveState, x))
2017-12-20 10:34:11 - The value or constructor 'pointState' is not defined. Maybe you want one of the following:
2017-12-20 10:34:11 -    Point
2017-12-20 10:34:11 -    Point2
2017-12-20 10:34:11 - Type mismatch. Expecting a
2017-12-20 10:34:11 -     'seq<Item>'    
2017-12-20 10:34:11 - but given a
2017-12-20 10:34:11 -     'seq<Point>'    
2017-12-20 10:34:11 - The type 'Point' does not match the type 'int'
2017-12-20 10:34:20 - let subFolder ((moveState, itemState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 10:34:20 -     
2017-12-20 10:34:20 -     let newPoint = 
2017-12-20 10:34:20 -         Seq.last itemState 
2017-12-20 10:34:20 -         |> (fun (point, _) -> point)
2017-12-20 10:34:20 -         |> updatePoint moveState
2017-12-20 10:34:20 -     
2017-12-20 10:34:20 - //     let newItem = 
2017-12-20 10:34:20 - //         itemState 
2017-12-20 10:34:20 - //         |> (fun (point, itemState) -> (point, getVal point, itemState)
2017-12-20 10:34:20 -     
2017-12-20 10:34:20 -     newPoint
2017-12-20 10:34:20 -     |> Seq.singleton
2017-12-20 10:34:20 -     |> Seq.append itemState
2017-12-20 10:34:20 -     |> (fun x -> (moveState, x))
2017-12-20 10:34:20 - The type 'int' does not match the type 'Point'
2017-12-20 10:34:20 - Type mismatch. Expecting a
2017-12-20 10:34:20 -     'seq<Item>'    
2017-12-20 10:34:20 - but given a
2017-12-20 10:34:20 -     'seq<Point>'    
2017-12-20 10:34:20 - The type 'Point' does not match the type 'int'
2017-12-20 10:34:42 - let subFolder ((moveState, itemState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 10:34:42 -     
2017-12-20 10:34:42 -     let newPoint = 
2017-12-20 10:34:42 -         Seq.last itemState 
2017-12-20 10:34:42 -         |> (fun (point, _) -> point)
2017-12-20 10:34:42 -         |> updatePoint moveState
2017-12-20 10:34:42 -     
2017-12-20 10:34:42 -     let newItem = 
2017-12-20 10:34:42 -         itemState 
2017-12-20 10:34:42 -         |> (fun (point, itemState) -> (point, getVal point, itemState)
2017-12-20 10:34:42 -     
2017-12-20 10:34:42 - //     newPoint
2017-12-20 10:34:42 - //     |> Seq.singleton
2017-12-20 10:34:42 - //     |> Seq.append itemState
2017-12-20 10:34:42 - //     |> (fun x -> (moveState, x))
2017-12-20 10:34:42 - Unmatched '('
2017-12-20 10:34:42 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2017-12-20 10:34:51 - let subFolder ((moveState, itemState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 10:34:51 -     
2017-12-20 10:34:51 -     let newPoint = 
2017-12-20 10:34:51 -         Seq.last itemState 
2017-12-20 10:34:51 -         |> (fun (point, _) -> point)
2017-12-20 10:34:51 -         |> updatePoint moveState
2017-12-20 10:34:51 -     
2017-12-20 10:34:51 -     let newItem = 
2017-12-20 10:34:51 -         itemState 
2017-12-20 10:34:51 -         |> (fun (point, itemState) -> (point, getVal point itemState)
2017-12-20 10:34:51 -     
2017-12-20 10:34:51 - //     newPoint
2017-12-20 10:34:51 - //     |> Seq.singleton
2017-12-20 10:34:51 - //     |> Seq.append itemState
2017-12-20 10:34:51 - //     |> (fun x -> (moveState, x))
2017-12-20 10:34:51 - Unmatched '('
2017-12-20 10:34:51 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2017-12-20 10:34:59 - let subFolder ((moveState, itemState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 10:34:59 -     
2017-12-20 10:34:59 -     let newPoint = 
2017-12-20 10:34:59 -         Seq.last itemState 
2017-12-20 10:34:59 -         |> (fun (point, _) -> point)
2017-12-20 10:34:59 -         |> updatePoint moveState
2017-12-20 10:34:59 -     
2017-12-20 10:34:59 -     let newItem = 
2017-12-20 10:34:59 -         itemState 
2017-12-20 10:34:59 -         |> (fun (point, itemState) -> (point, getVal point itemState))
2017-12-20 10:34:59 -     
2017-12-20 10:34:59 - //     newPoint
2017-12-20 10:34:59 - //     |> Seq.singleton
2017-12-20 10:34:59 - //     |> Seq.append itemState
2017-12-20 10:34:59 - //     |> (fun x -> (moveState, x))
2017-12-20 10:34:59 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2017-12-20 10:35:11 - let subFolder ((moveState, itemState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 10:35:11 -     
2017-12-20 10:35:11 -     let newPoint = 
2017-12-20 10:35:11 -         Seq.last itemState 
2017-12-20 10:35:11 -         |> (fun (point, _) -> point)
2017-12-20 10:35:11 -         |> updatePoint moveState
2017-12-20 10:35:11 -     
2017-12-20 10:35:11 -     let newItem = 
2017-12-20 10:35:11 -         itemState 
2017-12-20 10:35:11 -         |> (fun (point, itemState) -> (point, getVal point itemState))
2017-12-20 10:35:11 -     
2017-12-20 10:35:11 -     newPoint
2017-12-20 10:35:11 -     |> Seq.singleton
2017-12-20 10:35:11 -     |> Seq.append itemState
2017-12-20 10:35:11 -     |> (fun x -> (moveState, x))
2017-12-20 10:35:11 - This expression was expected to have type
2017-12-20 10:35:11 -     'seq<Item>'    
2017-12-20 10:35:11 - but here has type
2017-12-20 10:35:11 -     ''a * 'b'    
2017-12-20 10:35:11 - The type 'int' does not match the type 'Point'
2017-12-20 10:35:11 - Type mismatch. Expecting a
2017-12-20 10:35:11 -     'seq<Item>'    
2017-12-20 10:35:11 - but given a
2017-12-20 10:35:11 -     'seq<Point>'    
2017-12-20 10:35:11 - The type 'Point' does not match the type 'int'
2017-12-20 10:36:13 - let subFolder ((moveState, itemState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 10:36:13 -     
2017-12-20 10:36:13 -     let newPoint = 
2017-12-20 10:36:13 -         Seq.last itemState 
2017-12-20 10:36:13 -         |> (fun (point, _) -> point)
2017-12-20 10:36:13 -         |> updatePoint moveState
2017-12-20 10:36:13 -     
2017-12-20 10:36:13 -     let newItem = 
2017-12-20 10:36:13 -         getVal newpoint itemState
2017-12-20 10:36:13 -     
2017-12-20 10:36:13 -     newPoint
2017-12-20 10:36:13 -     |> Seq.singleton
2017-12-20 10:36:13 -     |> Seq.append itemState
2017-12-20 10:36:13 -     |> (fun x -> (moveState, x))
2017-12-20 10:36:13 - The value or constructor 'getVal' is not defined.
2017-12-20 10:36:13 - The type 'int' does not match the type 'Point'
2017-12-20 10:36:13 - Type mismatch. Expecting a
2017-12-20 10:36:13 -     'seq<Item>'    
2017-12-20 10:36:13 - but given a
2017-12-20 10:36:13 -     'seq<Point>'    
2017-12-20 10:36:13 - The type 'Point' does not match the type 'int'
2017-12-20 12:58:50 - let getVal ((x, y):Point) (items:Item seq) : Item = 
2017-12-20 12:58:50 -     Seq.map (fun x -> x) { (x+1, y), (x-1, y), (x, y+1), (x, y-1) }
2017-12-20 12:58:50 -     |> Seq.sum
2017-12-20 12:58:50 -     
2017-12-20 12:58:50 - Invalid object, sequence or record expression
2017-12-20 12:58:50 - Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq { ... }'
2017-12-20 12:58:50 - Expecting a type supporting the operator 'get_Zero' but given a tuple type
2017-12-20 12:58:55 - let getVal ((x, y):Point) (items:Item seq) : Item = 
2017-12-20 12:58:55 -     Seq.map (fun x -> x) { (x+1, y), (x-1, y), (x, y+1), (x, y-1) }
2017-12-20 12:58:55 -     |> Seq.sum
2017-12-20 12:58:55 -     
2017-12-20 12:58:55 - Invalid object, sequence or record expression
2017-12-20 12:58:55 - Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq { ... }'
2017-12-20 12:58:55 - Expecting a type supporting the operator 'get_Zero' but given a tuple type
2017-12-20 13:01:05 - {1}
2017-12-20 13:01:05 - Invalid object, sequence or record expression
2017-12-20 13:01:05 - Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq { ... }'
2017-12-20 13:01:08 - {1;}
2017-12-20 13:01:08 - Invalid object, sequence or record expression
2017-12-20 13:01:08 - Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq { ... }'
2017-12-20 13:01:13 - {1..2}
2017-12-20 13:24:23 - let fintVal (items:Item seq) (point:Point) : int =
2017-12-20 13:24:23 -     items
2017-12-20 13:24:23 -     |> Seq.find (fun (item, _) -> if item = point then true else false) 
2017-12-20 13:24:23 -     |> (fun (_, num) -> num)
2017-12-20 13:24:31 - let getVal ((x, y):Point) (items:Item seq) : Item = 
2017-12-20 13:24:31 -     seq [(x+1, y); (x+1, y+1); (x, y+1); (x-1, y+1); (x-1, y); (x-1, y-1); (x, y-1); (x+1, y-1);]
2017-12-20 13:24:31 -     |> Seq.map findVal
2017-12-20 13:24:31 -     |> Seq.sum
2017-12-20 13:24:31 -     |> (fun num -> (x,y), num)
2017-12-20 13:24:31 -     
2017-12-20 13:24:31 - The value or constructor 'findVal' is not defined. Maybe you want one of the following:
2017-12-20 13:24:31 -    fintVal
2017-12-20 13:24:36 - let findVal (items:Item seq) (point:Point) : int =
2017-12-20 13:24:36 -     items
2017-12-20 13:24:36 -     |> Seq.find (fun (item, _) -> if item = point then true else false) 
2017-12-20 13:24:36 -     |> (fun (_, num) -> num)
2017-12-20 13:24:41 - let getVal ((x, y):Point) (items:Item seq) : Item = 
2017-12-20 13:24:41 -     seq [(x+1, y); (x+1, y+1); (x, y+1); (x-1, y+1); (x-1, y); (x-1, y-1); (x, y-1); (x+1, y-1);]
2017-12-20 13:24:41 -     |> Seq.map findVal
2017-12-20 13:24:41 -     |> Seq.sum
2017-12-20 13:24:41 -     |> (fun num -> (x,y), num)
2017-12-20 13:24:41 -     
2017-12-20 13:24:41 - The type 'int * int' is not compatible with the type 'seq<Item>'
2017-12-20 13:25:12 - let getVal ((x, y):Point) (items:Item seq) : Item = 
2017-12-20 13:25:12 -     seq [(x+1, y); (x+1, y+1); (x, y+1); (x-1, y+1); (x-1, y); (x-1, y-1); (x, y-1); (x+1, y-1);]
2017-12-20 13:25:12 -     |> Seq.map (findVal items)
2017-12-20 13:25:12 -     |> Seq.sum
2017-12-20 13:25:12 -     |> (fun num -> (x,y), num)
2017-12-20 13:25:12 -     
2017-12-20 13:26:03 - let subFolder ((moveState, itemState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 13:26:03 -     
2017-12-20 13:26:03 -     let newPoint = 
2017-12-20 13:26:03 -         Seq.last itemState 
2017-12-20 13:26:03 -         |> (fun (point, _) -> point)
2017-12-20 13:26:03 -         |> updatePoint moveState
2017-12-20 13:26:03 -     
2017-12-20 13:26:03 -     let newItem = 
2017-12-20 13:26:03 -         getVal newPoint itemState
2017-12-20 13:26:03 -     
2017-12-20 13:26:03 -     newItem
2017-12-20 13:26:03 -     |> Seq.singleton
2017-12-20 13:26:03 -     |> Seq.append itemState
2017-12-20 13:26:03 -     |> (fun x -> (moveState, x))
2017-12-20 13:26:06 - let folder ((moveState, pointState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 13:26:06 -     
2017-12-20 13:26:06 -     let (fstMove, fstPoints) = Seq.fold subFolder (advanceMovement moveState, pointState) {1..num}
2017-12-20 13:26:06 -     
2017-12-20 13:26:06 -     let (newMove, sndPoints) = Seq.fold subFolder (advanceMovement fstMove, fstPoints) {1..num}
2017-12-20 13:26:06 -     
2017-12-20 13:26:06 -     (newMove, Seq.append fstPoints sndPoints)
2017-12-20 13:26:06 -     
2017-12-20 13:26:06 -     
2017-12-20 13:51:57 - let adventofCode3 limit = 
2017-12-20 13:51:57 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 13:51:57 -     
2017-12-20 13:51:57 -     let helper ((move, (point, num)):Movement*Item) : bool = 
2017-12-20 13:51:57 -         if num > limit then 
2017-12-20 13:51:57 -             true 
2017-12-20 13:51:57 -         else 
2017-12-20 13:51:57 -             false
2017-12-20 13:51:57 -     
2017-12-20 13:51:57 -     infiniSeq
2017-12-20 13:51:57 -     |> Seq.fold folder (Down, Seq.singleton ((0,0), 0)) 
2017-12-20 13:51:57 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 13:51:57 - The type 'Movement' does not match the type 'Point'
2017-12-20 13:53:17 - let adventofCode3 limit = 
2017-12-20 13:53:17 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 13:53:17 -     
2017-12-20 13:53:17 -     let helper ((_, num):Item) : bool = 
2017-12-20 13:53:17 -         if num > limit then 
2017-12-20 13:53:17 -             true 
2017-12-20 13:53:17 -         else 
2017-12-20 13:53:17 -             false
2017-12-20 13:53:17 -     
2017-12-20 13:53:17 -     infiniSeq
2017-12-20 13:53:17 -     |> Seq.fold folder (Down, Seq.singleton ((0,0), 0)) 
2017-12-20 13:53:17 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 13:54:15 - let generateSquare (min:int) (max:int): int seq = 
2017-12-20 13:54:15 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-20 13:54:15 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-20 13:54:15 - let rec squareBuilder ((goal, acc, min, max):int*int*int*int) : int seq =
2017-12-20 13:54:15 -     match (goal <= acc) with 
2017-12-20 13:54:15 -     | true -> Seq.empty
2017-12-20 13:54:15 -     | _ -> 
2017-12-20 13:54:15 -         let newSquare = generateSquare min max
2017-12-20 13:54:15 -         squareBuilder (goal, (acc + Seq.length newSquare), (min+1), (max+2))
2017-12-20 13:54:15 -         |> Seq.append newSquare
2017-12-20 13:54:15 -     
2017-12-20 13:54:15 - let adventOfCode (goal:int) : int = 
2017-12-20 13:54:15 -    
2017-12-20 13:54:15 -     squareBuilder (goal, 0, 1, 2)
2017-12-20 13:54:15 -     |> Seq.toList
2017-12-20 13:54:15 -     |> (fun distanceList -> distanceList.[goal-2])
2017-12-20 13:54:15 -     
2017-12-20 13:54:15 - adventOfCode 277678
2017-12-20 13:54:15 - squareBuilder (100, 0, 1, 2) |> Seq.toList
2017-12-20 13:54:15 - type Movement = Up | Left | Down | Right
2017-12-20 13:54:15 - let advanceMovement (movement:Movement) : Movement =
2017-12-20 13:54:15 -     match movement with
2017-12-20 13:54:15 -     | Up -> Left
2017-12-20 13:54:15 -     | Left -> Down
2017-12-20 13:54:15 -     | Down -> Right
2017-12-20 13:54:15 -     | Right -> Up
2017-12-20 13:54:15 -     
2017-12-20 13:54:15 - type Point = int*int
2017-12-20 13:54:15 - type Item = Point*int
2017-12-20 13:54:15 - let findVal (items:Item seq) (point:Point) : int =
2017-12-20 13:54:15 -     items
2017-12-20 13:54:15 -     |> Seq.find (fun (item, _) -> if item = point then true else false) 
2017-12-20 13:54:15 -     |> (fun (_, num) -> num)
2017-12-20 13:54:15 - let getVal ((x, y):Point) (items:Item seq) : Item = 
2017-12-20 13:54:15 -     seq [(x+1, y); (x+1, y+1); (x, y+1); (x-1, y+1); (x-1, y); (x-1, y-1); (x, y-1); (x+1, y-1);]
2017-12-20 13:54:15 -     |> Seq.map (findVal items)
2017-12-20 13:54:15 -     |> Seq.sum
2017-12-20 13:54:15 -     |> (fun num -> (x,y), num)
2017-12-20 13:54:15 -     
2017-12-20 13:54:15 - let updatePoint (movement:Movement) (point:Point) : Point =
2017-12-20 13:54:15 -     match movement with
2017-12-20 13:54:15 -     | Up -> point |> (fun (x, y) -> x, y+1)
2017-12-20 13:54:15 -     | Left -> point |> (fun (x, y) -> x-1, y)
2017-12-20 13:54:15 -     | Down -> point |> (fun (x, y) -> x, y-1)
2017-12-20 13:54:15 -     | Right -> point |> (fun (x, y) -> x+1, y)
2017-12-20 13:54:15 - let subFolder ((moveState, itemState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 13:54:15 -     
2017-12-20 13:54:15 -     let newPoint = 
2017-12-20 13:54:15 -         Seq.last itemState 
2017-12-20 13:54:15 -         |> (fun (point, _) -> point)
2017-12-20 13:54:15 -         |> updatePoint moveState
2017-12-20 13:54:15 -     
2017-12-20 13:54:15 -     let newItem = 
2017-12-20 13:54:15 -         getVal newPoint itemState
2017-12-20 13:54:15 -     
2017-12-20 13:54:15 -     newItem
2017-12-20 13:54:15 -     |> Seq.singleton
2017-12-20 13:54:15 -     |> Seq.append itemState
2017-12-20 13:54:15 -     |> (fun x -> (moveState, x))
2017-12-20 13:54:15 - let folder ((moveState, pointState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 13:54:15 -     
2017-12-20 13:54:15 -     let (fstMove, fstPoints) = Seq.fold subFolder (advanceMovement moveState, pointState) {1..num}
2017-12-20 13:54:15 -     
2017-12-20 13:54:15 -     let (newMove, sndPoints) = Seq.fold subFolder (advanceMovement fstMove, fstPoints) {1..num}
2017-12-20 13:54:15 -     
2017-12-20 13:54:15 -     (newMove, Seq.append fstPoints sndPoints)
2017-12-20 13:54:15 -     
2017-12-20 13:54:15 -     
2017-12-20 13:54:15 - let adventofCode3 limit = 
2017-12-20 13:54:15 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 13:54:15 -     
2017-12-20 13:54:15 -     let helper ((_, num):Item) : bool = 
2017-12-20 13:54:15 -         if num > limit then 
2017-12-20 13:54:15 -             true 
2017-12-20 13:54:15 -         else 
2017-12-20 13:54:15 -             false
2017-12-20 13:54:15 -     
2017-12-20 13:54:15 -     infiniSeq
2017-12-20 13:54:15 -     |> Seq.fold folder (Down, Seq.singleton ((0,0), 0)) 
2017-12-20 13:54:15 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 13:54:15 -     |> (fun ())
2017-12-20 13:54:15 - Incomplete structured construct at or before this point in lambda expression. Expected '->' or other token.
2017-12-20 13:54:15 -  {1..2}
2017-12-20 13:54:53 - let adventofCode3 (limit:int) : int = 
2017-12-20 13:54:53 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 13:54:53 -     
2017-12-20 13:54:53 -     let helper ((_, num):Item) : bool = 
2017-12-20 13:54:53 -         if num > limit then 
2017-12-20 13:54:53 -             true 
2017-12-20 13:54:53 -         else 
2017-12-20 13:54:53 -             false
2017-12-20 13:54:53 -     
2017-12-20 13:54:53 -     infiniSeq
2017-12-20 13:54:53 -     |> Seq.fold folder (Down, Seq.singleton ((0,0), 0)) 
2017-12-20 13:54:53 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 13:54:53 -     |> (fun (_, num) -> num)
2017-12-20 13:55:20 - adventOfCode3 277678
2017-12-20 13:55:20 - The value or constructor 'adventOfCode3' is not defined. Maybe you want one of the following:
2017-12-20 13:55:20 -    adventofCode3
2017-12-20 13:55:20 -    adventOfCode
2017-12-20 13:55:23 - let adventOfCode3 (limit:int) : int = 
2017-12-20 13:55:23 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 13:55:23 -     
2017-12-20 13:55:23 -     let helper ((_, num):Item) : bool = 
2017-12-20 13:55:23 -         if num > limit then 
2017-12-20 13:55:23 -             true 
2017-12-20 13:55:23 -         else 
2017-12-20 13:55:23 -             false
2017-12-20 13:55:23 -     
2017-12-20 13:55:23 -     infiniSeq
2017-12-20 13:55:23 -     |> Seq.fold folder (Down, Seq.singleton ((0,0), 0)) 
2017-12-20 13:55:23 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 13:55:23 -     |> (fun (_, num) -> num)
2017-12-20 13:55:25 - adventOfCode3 277678
2017-12-20 13:55:25 - Expression evaluation failed: Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:55:25 - KeyNotFoundExceptionException of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:55:25 -    at Microsoft.FSharp.Collections.SeqModule.Find[T](FSharpFunc`2 predicate, IEnumerable`1 source)
2017-12-20 13:55:25 -    at FSI_0097.findVal(IEnumerable`1 items, Int32 point_0, Int32 point_1) in C:\Users\misadmin\FSharpPractice\input.fsx:line 4
2017-12-20 13:55:25 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& )
2017-12-20 13:55:25 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2017-12-20 13:55:25 -    at FSI_0098.getVal(Int32 _arg1_0, Int32 _arg1_1, IEnumerable`1 items) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2017-12-20 13:55:25 -    at FSI_0100.subFolder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:55:25 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:55:25 -    at FSI_0101.folder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:55:25 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:55:25 -    at FSI_0107.adventOfCode3(Int32 limit) in C:\Users\misadmin\FSharpPractice\input.fsx:line 13
2017-12-20 13:55:25 -    at <StartupCode$FSI_0108>.$FSI_0108.main@()
2017-12-20 13:55:51 - let adventOfCode3 (limit:int) : int = 
2017-12-20 13:55:51 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 13:55:51 -     
2017-12-20 13:55:51 -     let helper ((_, num):Item) : bool = 
2017-12-20 13:55:51 -         if num > limit then 
2017-12-20 13:55:51 -             true 
2017-12-20 13:55:51 -         else 
2017-12-20 13:55:51 -             false
2017-12-20 13:55:51 -     
2017-12-20 13:55:51 -     {1..100}
2017-12-20 13:55:51 -     |> Seq.fold folder (Down, Seq.singleton ((0,0), 0)) 
2017-12-20 13:55:51 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 13:55:51 -     |> (fun (_, num) -> num)
2017-12-20 13:55:57 - adventOfCode3 277678
2017-12-20 13:55:57 - Expression evaluation failed: Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:55:57 - KeyNotFoundExceptionException of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:55:57 -    at Microsoft.FSharp.Collections.SeqModule.Find[T](FSharpFunc`2 predicate, IEnumerable`1 source)
2017-12-20 13:55:57 -    at FSI_0097.findVal(IEnumerable`1 items, Int32 point_0, Int32 point_1) in C:\Users\misadmin\FSharpPractice\input.fsx:line 4
2017-12-20 13:55:57 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& )
2017-12-20 13:55:57 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2017-12-20 13:55:57 -    at FSI_0098.getVal(Int32 _arg1_0, Int32 _arg1_1, IEnumerable`1 items) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2017-12-20 13:55:57 -    at FSI_0100.subFolder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:55:57 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:55:57 -    at FSI_0101.folder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:55:57 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:55:57 -    at FSI_0109.adventOfCode3(Int32 limit) in C:\Users\misadmin\FSharpPractice\input.fsx:line 13
2017-12-20 13:55:57 -    at <StartupCode$FSI_0110>.$FSI_0110.main@()
2017-12-20 13:56:16 - let adventOfCode3 (limit:int) : int = 
2017-12-20 13:56:16 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 13:56:16 -     
2017-12-20 13:56:16 -     let helper ((_, num):Item) : bool = 
2017-12-20 13:56:16 -         if num > limit then 
2017-12-20 13:56:16 -             true 
2017-12-20 13:56:16 -         else 
2017-12-20 13:56:16 -             false
2017-12-20 13:56:16 -     
2017-12-20 13:56:16 -     {1..1000}
2017-12-20 13:56:16 -     |> Seq.fold folder (Down, Seq.singleton ((0,0), 0)) 
2017-12-20 13:56:16 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 13:56:16 -     |> (fun (_, num) -> num)
2017-12-20 13:56:18 - adventOfCode3 277678
2017-12-20 13:56:18 - Expression evaluation failed: Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:56:18 - KeyNotFoundExceptionException of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:56:18 -    at Microsoft.FSharp.Collections.SeqModule.Find[T](FSharpFunc`2 predicate, IEnumerable`1 source)
2017-12-20 13:56:18 -    at FSI_0097.findVal(IEnumerable`1 items, Int32 point_0, Int32 point_1) in C:\Users\misadmin\FSharpPractice\input.fsx:line 4
2017-12-20 13:56:18 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& )
2017-12-20 13:56:18 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2017-12-20 13:56:18 -    at FSI_0098.getVal(Int32 _arg1_0, Int32 _arg1_1, IEnumerable`1 items) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2017-12-20 13:56:18 -    at FSI_0100.subFolder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:56:18 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:56:18 -    at FSI_0101.folder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:56:18 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:56:18 -    at FSI_0111.adventOfCode3(Int32 limit) in C:\Users\misadmin\FSharpPractice\input.fsx:line 13
2017-12-20 13:56:18 -    at <StartupCode$FSI_0112>.$FSI_0112.main@()
2017-12-20 13:56:20 - adventOfCode3 277678
2017-12-20 13:56:20 - Expression evaluation failed: Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:56:20 - KeyNotFoundExceptionException of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:56:20 -    at Microsoft.FSharp.Collections.SeqModule.Find[T](FSharpFunc`2 predicate, IEnumerable`1 source)
2017-12-20 13:56:20 -    at FSI_0097.findVal(IEnumerable`1 items, Int32 point_0, Int32 point_1) in C:\Users\misadmin\FSharpPractice\input.fsx:line 4
2017-12-20 13:56:20 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& )
2017-12-20 13:56:20 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2017-12-20 13:56:20 -    at FSI_0098.getVal(Int32 _arg1_0, Int32 _arg1_1, IEnumerable`1 items) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2017-12-20 13:56:20 -    at FSI_0100.subFolder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:56:20 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:56:20 -    at FSI_0101.folder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:56:20 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:56:20 -    at FSI_0111.adventOfCode3(Int32 limit) in C:\Users\misadmin\FSharpPractice\input.fsx:line 13
2017-12-20 13:56:20 -    at <StartupCode$FSI_0113>.$FSI_0113.main@()
2017-12-20 13:56:24 - let adventOfCode3 (limit:int) : int = 
2017-12-20 13:56:24 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 13:56:24 -     
2017-12-20 13:56:24 -     let helper ((_, num):Item) : bool = 
2017-12-20 13:56:24 -         if num > limit then 
2017-12-20 13:56:24 -             true 
2017-12-20 13:56:24 -         else 
2017-12-20 13:56:24 -             false
2017-12-20 13:56:24 -     
2017-12-20 13:56:24 -     {1..10}
2017-12-20 13:56:24 -     |> Seq.fold folder (Down, Seq.singleton ((0,0), 0)) 
2017-12-20 13:56:24 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 13:56:24 -     |> (fun (_, num) -> num)
2017-12-20 13:56:25 - adventOfCode3 277678
2017-12-20 13:56:25 - Expression evaluation failed: Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:56:25 - KeyNotFoundExceptionException of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:56:25 -    at Microsoft.FSharp.Collections.SeqModule.Find[T](FSharpFunc`2 predicate, IEnumerable`1 source)
2017-12-20 13:56:25 -    at FSI_0097.findVal(IEnumerable`1 items, Int32 point_0, Int32 point_1) in C:\Users\misadmin\FSharpPractice\input.fsx:line 4
2017-12-20 13:56:25 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& )
2017-12-20 13:56:25 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2017-12-20 13:56:25 -    at FSI_0098.getVal(Int32 _arg1_0, Int32 _arg1_1, IEnumerable`1 items) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2017-12-20 13:56:25 -    at FSI_0100.subFolder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:56:25 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:56:25 -    at FSI_0101.folder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:56:25 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:56:25 -    at FSI_0114.adventOfCode3(Int32 limit) in C:\Users\misadmin\FSharpPractice\input.fsx:line 13
2017-12-20 13:56:25 -    at <StartupCode$FSI_0115>.$FSI_0115.main@()
2017-12-20 13:56:56 - let adventOfCode3 (limit:int) : int = 
2017-12-20 13:56:56 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 13:56:56 -     
2017-12-20 13:56:56 -     let helper ((_, num):Item) : bool = 
2017-12-20 13:56:56 -         if num > limit then 
2017-12-20 13:56:56 -             true 
2017-12-20 13:56:56 -         else 
2017-12-20 13:56:56 -             false
2017-12-20 13:56:56 -     
2017-12-20 13:56:56 -     {1..10}
2017-12-20 13:56:56 -     |> Seq.fold folder (Down, Seq.singleton ((0,0), 0)) 
2017-12-20 13:56:56 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 13:56:56 - Type mismatch. Expecting a
2017-12-20 13:56:56 -     'int -> bool'    
2017-12-20 13:56:56 - but given a
2017-12-20 13:56:56 -     'Item -> bool'    
2017-12-20 13:56:56 - The type 'int' does not match the type 'Item'
2017-12-20 13:56:56 - The type 'int' does not match the type 'Item'
2017-12-20 13:56:56 - adventOfCode3 277678
2017-12-20 13:56:56 - Expression evaluation failed: Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:56:56 - KeyNotFoundExceptionException of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:56:56 -    at Microsoft.FSharp.Collections.SeqModule.Find[T](FSharpFunc`2 predicate, IEnumerable`1 source)
2017-12-20 13:56:56 -    at FSI_0097.findVal(IEnumerable`1 items, Int32 point_0, Int32 point_1) in C:\Users\misadmin\FSharpPractice\input.fsx:line 4
2017-12-20 13:56:56 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& )
2017-12-20 13:56:56 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2017-12-20 13:56:56 -    at FSI_0098.getVal(Int32 _arg1_0, Int32 _arg1_1, IEnumerable`1 items) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2017-12-20 13:56:56 -    at FSI_0100.subFolder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:56:56 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:56:56 -    at FSI_0101.folder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:56:56 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:56:56 -    at FSI_0114.adventOfCode3(Int32 limit) in C:\Users\misadmin\FSharpPractice\input.fsx:line 13
2017-12-20 13:56:56 -    at <StartupCode$FSI_0117>.$FSI_0117.main@()
2017-12-20 13:57:25 - let adventOfCode3 (limit:int) : Item = 
2017-12-20 13:57:25 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 13:57:25 -     
2017-12-20 13:57:25 -     let helper ((_, num):Item) : bool = 
2017-12-20 13:57:25 -         if num > limit then 
2017-12-20 13:57:25 -             true 
2017-12-20 13:57:25 -         else 
2017-12-20 13:57:25 -             false
2017-12-20 13:57:25 -     
2017-12-20 13:57:25 -     {1..10}
2017-12-20 13:57:25 -     |> Seq.fold folder (Down, Seq.singleton ((0,0), 0)) 
2017-12-20 13:57:25 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 13:57:28 - adventOfCode3 277678
2017-12-20 13:57:28 - Expression evaluation failed: Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:57:28 - KeyNotFoundExceptionException of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:57:28 -    at Microsoft.FSharp.Collections.SeqModule.Find[T](FSharpFunc`2 predicate, IEnumerable`1 source)
2017-12-20 13:57:28 -    at FSI_0097.findVal(IEnumerable`1 items, Int32 point_0, Int32 point_1) in C:\Users\misadmin\FSharpPractice\input.fsx:line 4
2017-12-20 13:57:28 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& )
2017-12-20 13:57:28 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2017-12-20 13:57:28 -    at FSI_0098.getVal(Int32 _arg1_0, Int32 _arg1_1, IEnumerable`1 items) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2017-12-20 13:57:28 -    at FSI_0100.subFolder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:57:28 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:57:28 -    at FSI_0101.folder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:57:28 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:57:28 -    at FSI_0118.adventOfCode3(Int32 limit) in C:\Users\misadmin\FSharpPractice\input.fsx:line 10
2017-12-20 13:57:28 -    at <StartupCode$FSI_0119>.$FSI_0119.main@()
2017-12-20 13:57:30 - let adventOfCode3 (limit:int) : Item = 
2017-12-20 13:57:30 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 13:57:30 -     
2017-12-20 13:57:30 -     let helper ((_, num):Item) : bool = 
2017-12-20 13:57:30 -         if num > limit then 
2017-12-20 13:57:30 -             true 
2017-12-20 13:57:30 -         else 
2017-12-20 13:57:30 -             false
2017-12-20 13:57:30 -     
2017-12-20 13:57:30 -     {1..10}
2017-12-20 13:57:30 -     |> Seq.fold folder (Down, Seq.singleton ((0,0), 0)) 
2017-12-20 13:57:30 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 13:57:31 - adventOfCode3 277678
2017-12-20 13:57:31 - Expression evaluation failed: Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:57:31 - KeyNotFoundExceptionException of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:57:31 -    at Microsoft.FSharp.Collections.SeqModule.Find[T](FSharpFunc`2 predicate, IEnumerable`1 source)
2017-12-20 13:57:31 -    at FSI_0097.findVal(IEnumerable`1 items, Int32 point_0, Int32 point_1) in C:\Users\misadmin\FSharpPractice\input.fsx:line 4
2017-12-20 13:57:31 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& )
2017-12-20 13:57:31 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2017-12-20 13:57:31 -    at FSI_0098.getVal(Int32 _arg1_0, Int32 _arg1_1, IEnumerable`1 items) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2017-12-20 13:57:31 -    at FSI_0100.subFolder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:57:31 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:57:31 -    at FSI_0101.folder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:57:31 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:57:31 -    at FSI_0120.adventOfCode3(Int32 limit) in C:\Users\misadmin\FSharpPractice\input.fsx:line 10
2017-12-20 13:57:31 -    at <StartupCode$FSI_0121>.$FSI_0121.main@()
2017-12-20 13:57:34 - adventOfCode3 277678
2017-12-20 13:57:34 - Expression evaluation failed: Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:57:34 - KeyNotFoundExceptionException of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:57:34 -    at Microsoft.FSharp.Collections.SeqModule.Find[T](FSharpFunc`2 predicate, IEnumerable`1 source)
2017-12-20 13:57:34 -    at FSI_0097.findVal(IEnumerable`1 items, Int32 point_0, Int32 point_1) in C:\Users\misadmin\FSharpPractice\input.fsx:line 4
2017-12-20 13:57:34 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& )
2017-12-20 13:57:34 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2017-12-20 13:57:34 -    at FSI_0098.getVal(Int32 _arg1_0, Int32 _arg1_1, IEnumerable`1 items) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2017-12-20 13:57:34 -    at FSI_0100.subFolder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:57:34 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:57:34 -    at FSI_0101.folder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:57:34 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:57:34 -    at FSI_0120.adventOfCode3(Int32 limit) in C:\Users\misadmin\FSharpPractice\input.fsx:line 10
2017-12-20 13:57:34 -    at <StartupCode$FSI_0122>.$FSI_0122.main@()
2017-12-20 13:57:39 - let adventOfCode3 (limit:int) : Item = 
2017-12-20 13:57:39 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 13:57:39 -     
2017-12-20 13:57:39 -     let helper ((_, num):Item) : bool = 
2017-12-20 13:57:39 -         if num > limit then 
2017-12-20 13:57:39 -             true 
2017-12-20 13:57:39 -         else 
2017-12-20 13:57:39 -             false
2017-12-20 13:57:39 -     
2017-12-20 13:57:39 -     {1..10000}
2017-12-20 13:57:39 -     |> Seq.fold folder (Down, Seq.singleton ((0,0), 0)) 
2017-12-20 13:57:39 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 13:57:41 - adventOfCode3 277678
2017-12-20 13:57:41 - Expression evaluation failed: Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:57:41 - KeyNotFoundExceptionException of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:57:41 -    at Microsoft.FSharp.Collections.SeqModule.Find[T](FSharpFunc`2 predicate, IEnumerable`1 source)
2017-12-20 13:57:41 -    at FSI_0097.findVal(IEnumerable`1 items, Int32 point_0, Int32 point_1) in C:\Users\misadmin\FSharpPractice\input.fsx:line 4
2017-12-20 13:57:41 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& )
2017-12-20 13:57:41 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2017-12-20 13:57:41 -    at FSI_0098.getVal(Int32 _arg1_0, Int32 _arg1_1, IEnumerable`1 items) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2017-12-20 13:57:41 -    at FSI_0100.subFolder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:57:41 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:57:41 -    at FSI_0101.folder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:57:41 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:57:41 -    at FSI_0123.adventOfCode3(Int32 limit) in C:\Users\misadmin\FSharpPractice\input.fsx:line 10
2017-12-20 13:57:41 -    at <StartupCode$FSI_0124>.$FSI_0124.main@()
2017-12-20 13:57:43 - adventOfCode3 277678
2017-12-20 13:57:43 - Expression evaluation failed: Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:57:43 - KeyNotFoundExceptionException of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:57:43 -    at Microsoft.FSharp.Collections.SeqModule.Find[T](FSharpFunc`2 predicate, IEnumerable`1 source)
2017-12-20 13:57:43 -    at FSI_0097.findVal(IEnumerable`1 items, Int32 point_0, Int32 point_1) in C:\Users\misadmin\FSharpPractice\input.fsx:line 4
2017-12-20 13:57:43 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& )
2017-12-20 13:57:43 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2017-12-20 13:57:43 -    at FSI_0098.getVal(Int32 _arg1_0, Int32 _arg1_1, IEnumerable`1 items) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2017-12-20 13:57:43 -    at FSI_0100.subFolder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:57:43 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:57:43 -    at FSI_0101.folder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:57:43 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:57:43 -    at FSI_0123.adventOfCode3(Int32 limit) in C:\Users\misadmin\FSharpPractice\input.fsx:line 10
2017-12-20 13:57:43 -    at <StartupCode$FSI_0125>.$FSI_0125.main@()
2017-12-20 13:57:45 - let generateSquare (min:int) (max:int): int seq = 
2017-12-20 13:57:45 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-20 13:57:45 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-20 13:57:45 - let rec squareBuilder ((goal, acc, min, max):int*int*int*int) : int seq =
2017-12-20 13:57:45 -     match (goal <= acc) with 
2017-12-20 13:57:45 -     | true -> Seq.empty
2017-12-20 13:57:45 -     | _ -> 
2017-12-20 13:57:45 -         let newSquare = generateSquare min max
2017-12-20 13:57:45 -         squareBuilder (goal, (acc + Seq.length newSquare), (min+1), (max+2))
2017-12-20 13:57:45 -         |> Seq.append newSquare
2017-12-20 13:57:45 -     
2017-12-20 13:57:45 - let adventOfCode (goal:int) : int = 
2017-12-20 13:57:45 -    
2017-12-20 13:57:45 -     squareBuilder (goal, 0, 1, 2)
2017-12-20 13:57:45 -     |> Seq.toList
2017-12-20 13:57:45 -     |> (fun distanceList -> distanceList.[goal-2])
2017-12-20 13:57:45 -     
2017-12-20 13:57:45 - adventOfCode 277678
2017-12-20 13:57:46 - squareBuilder (100, 0, 1, 2) |> Seq.toList
2017-12-20 13:57:46 - type Movement = Up | Left | Down | Right
2017-12-20 13:57:46 - let advanceMovement (movement:Movement) : Movement =
2017-12-20 13:57:46 -     match movement with
2017-12-20 13:57:46 -     | Up -> Left
2017-12-20 13:57:46 -     | Left -> Down
2017-12-20 13:57:46 -     | Down -> Right
2017-12-20 13:57:46 -     | Right -> Up
2017-12-20 13:57:46 -     
2017-12-20 13:57:46 - type Point = int*int
2017-12-20 13:57:46 - type Item = Point*int
2017-12-20 13:57:46 - let findVal (items:Item seq) (point:Point) : int =
2017-12-20 13:57:46 -     items
2017-12-20 13:57:46 -     |> Seq.find (fun (item, _) -> if item = point then true else false) 
2017-12-20 13:57:46 -     |> (fun (_, num) -> num)
2017-12-20 13:57:46 - let getVal ((x, y):Point) (items:Item seq) : Item = 
2017-12-20 13:57:46 -     seq [(x+1, y); (x+1, y+1); (x, y+1); (x-1, y+1); (x-1, y); (x-1, y-1); (x, y-1); (x+1, y-1);]
2017-12-20 13:57:46 -     |> Seq.map (findVal items)
2017-12-20 13:57:46 -     |> Seq.sum
2017-12-20 13:57:46 -     |> (fun num -> (x,y), num)
2017-12-20 13:57:46 -     
2017-12-20 13:57:46 - let updatePoint (movement:Movement) (point:Point) : Point =
2017-12-20 13:57:46 -     match movement with
2017-12-20 13:57:46 -     | Up -> point |> (fun (x, y) -> x, y+1)
2017-12-20 13:57:46 -     | Left -> point |> (fun (x, y) -> x-1, y)
2017-12-20 13:57:46 -     | Down -> point |> (fun (x, y) -> x, y-1)
2017-12-20 13:57:46 -     | Right -> point |> (fun (x, y) -> x+1, y)
2017-12-20 13:57:46 - let subFolder ((moveState, itemState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 13:57:46 -     
2017-12-20 13:57:46 -     let newPoint = 
2017-12-20 13:57:46 -         Seq.last itemState 
2017-12-20 13:57:46 -         |> (fun (point, _) -> point)
2017-12-20 13:57:46 -         |> updatePoint moveState
2017-12-20 13:57:46 -     
2017-12-20 13:57:46 -     let newItem = 
2017-12-20 13:57:46 -         getVal newPoint itemState
2017-12-20 13:57:46 -     
2017-12-20 13:57:46 -     newItem
2017-12-20 13:57:46 -     |> Seq.singleton
2017-12-20 13:57:46 -     |> Seq.append itemState
2017-12-20 13:57:46 -     |> (fun x -> (moveState, x))
2017-12-20 13:57:46 - let folder ((moveState, pointState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 13:57:46 -     
2017-12-20 13:57:46 -     let (fstMove, fstPoints) = Seq.fold subFolder (advanceMovement moveState, pointState) {1..num}
2017-12-20 13:57:46 -     
2017-12-20 13:57:46 -     let (newMove, sndPoints) = Seq.fold subFolder (advanceMovement fstMove, fstPoints) {1..num}
2017-12-20 13:57:46 -     
2017-12-20 13:57:46 -     (newMove, Seq.append fstPoints sndPoints)
2017-12-20 13:57:46 -     
2017-12-20 13:57:46 -     
2017-12-20 13:57:46 - let adventOfCode3 (limit:int) : Item = 
2017-12-20 13:57:46 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 13:57:46 -     
2017-12-20 13:57:46 -     let helper ((_, num):Item) : bool = 
2017-12-20 13:57:46 -         if num > limit then 
2017-12-20 13:57:46 -             true 
2017-12-20 13:57:46 -         else 
2017-12-20 13:57:46 -             false
2017-12-20 13:57:46 -     
2017-12-20 13:57:46 -     {1..10000}
2017-12-20 13:57:46 -     |> Seq.fold folder (Down, Seq.singleton ((0,0), 0)) 
2017-12-20 13:57:46 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 13:57:46 - adventOfCode3 277678
2017-12-20 13:57:46 - Expression evaluation failed: Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:57:46 - KeyNotFoundExceptionException of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 13:57:46 -    at Microsoft.FSharp.Collections.SeqModule.Find[T](FSharpFunc`2 predicate, IEnumerable`1 source)
2017-12-20 13:57:46 -    at FSI_0135.findVal(IEnumerable`1 items, Int32 point_0, Int32 point_1) in C:\Users\misadmin\FSharpPractice\input.fsx:line 4
2017-12-20 13:57:46 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& )
2017-12-20 13:57:46 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2017-12-20 13:57:46 -    at FSI_0136.getVal(Int32 _arg1_0, Int32 _arg1_1, IEnumerable`1 items) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2017-12-20 13:57:46 -    at FSI_0138.subFolder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:57:46 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:57:46 -    at FSI_0139.folder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 13:57:46 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 13:57:46 -    at FSI_0140.adventOfCode3(Int32 limit) in C:\Users\misadmin\FSharpPractice\input.fsx:line 10
2017-12-20 13:57:46 -    at <StartupCode$FSI_0141>.$FSI_0141.main@()
2017-12-20 13:58:42 - {1..1}
2017-12-20 14:34:19 - let folder ((moveState, pointState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 14:34:19 -     
2017-12-20 14:34:19 -     let (fstMove, fstPoints) = Seq.fold subFolder (advanceMovement moveState, pointState) {1..num}
2017-12-20 14:34:19 -     
2017-12-20 14:34:19 -     let (newMove, sndPoints) = Seq.fold subFolder (advanceMovement fstMove, fstPoints) {1..num}
2017-12-20 14:34:19 -     
2017-12-20 14:34:19 -     (newMove, sndPoints)
2017-12-20 14:34:19 -     
2017-12-20 14:34:19 -     
2017-12-20 14:34:25 - let adventOfCode3 (limit:int) : Item = 
2017-12-20 14:34:25 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 14:34:25 -     
2017-12-20 14:34:25 -     let helper ((_, num):Item) : bool = 
2017-12-20 14:34:25 -         if num > limit then 
2017-12-20 14:34:25 -             true 
2017-12-20 14:34:25 -         else 
2017-12-20 14:34:25 -             false
2017-12-20 14:34:25 -     
2017-12-20 14:34:25 -     {1..10000}
2017-12-20 14:34:25 -     |> Seq.fold folder (Down, Seq.singleton ((0,0), 0)) 
2017-12-20 14:34:25 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 14:34:39 - adventOfCode3 277678
2017-12-20 14:34:39 - Expression evaluation failed: Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 14:34:39 - KeyNotFoundExceptionException of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 14:34:39 -    at Microsoft.FSharp.Collections.SeqModule.Find[T](FSharpFunc`2 predicate, IEnumerable`1 source)
2017-12-20 14:34:39 -    at FSI_0135.findVal(IEnumerable`1 items, Int32 point_0, Int32 point_1) in C:\Users\misadmin\FSharpPractice\input.fsx:line 4
2017-12-20 14:34:39 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& )
2017-12-20 14:34:39 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2017-12-20 14:34:39 -    at FSI_0136.getVal(Int32 _arg1_0, Int32 _arg1_1, IEnumerable`1 items) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2017-12-20 14:34:39 -    at FSI_0138.subFolder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 14:34:39 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 14:34:39 -    at FSI_0144.folder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 14:34:39 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 14:34:39 -    at FSI_0145.adventOfCode3(Int32 limit) in C:\Users\misadmin\FSharpPractice\input.fsx:line 10
2017-12-20 14:34:39 -    at <StartupCode$FSI_0146>.$FSI_0146.main@()
2017-12-20 15:46:23 - let folder (num:int) ((moveState, pointState):Movement*Item seq)  : Movement*Item seq =
2017-12-20 15:46:23 -     
2017-12-20 15:46:23 -     let (fstMove, fstPoints) = Seq.fold subFolder (advanceMovement moveState, pointState) {1..num}
2017-12-20 15:46:23 -     
2017-12-20 15:46:23 -     let (newMove, sndPoints) = Seq.fold subFolder (advanceMovement fstMove, fstPoints) {1..num}
2017-12-20 15:46:23 -     
2017-12-20 15:46:23 -     (newMove, sndPoints)
2017-12-20 15:46:23 -     
2017-12-20 15:46:23 -     
2017-12-20 15:47:58 - let adventOfCode3 (limit:int) : Item = 
2017-12-20 15:47:58 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 15:47:58 -     
2017-12-20 15:47:58 -     let helper ((_, num):Item) : bool = 
2017-12-20 15:47:58 -         if num > limit then 
2017-12-20 15:47:58 -             true 
2017-12-20 15:47:58 -         else 
2017-12-20 15:47:58 -             false
2017-12-20 15:47:58 -     
2017-12-20 15:47:58 -     (Down, Seq.singleton ((0,0), 0))
2017-12-20 15:47:58 -     |> Seq.foldBack folder infiniSeq 
2017-12-20 15:47:58 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 15:48:00 - adventOfCode3 277678
2017-12-20 15:48:27 - shutdown request
2017-12-20 15:48:29 - // include directory, this will be replaced by the kernel
2017-12-20 15:48:29 - #I "C:\\Users\\misadmin\\Desktop\\F sharp notebook"
2017-12-20 15:48:29 - // load base dlls
2017-12-20 15:48:29 - #r "IfSharp.Kernel.dll"
2017-12-20 15:48:29 - #r "NetMQ.dll"
2017-12-20 15:48:29 - // open the global functions and methods
2017-12-20 15:48:29 - open IfSharp.Kernel
2017-12-20 15:48:29 - open IfSharp.Kernel.Globals
2017-12-20 15:48:35 - F# Interactive for F# 4.1
2017-12-20 15:48:35 - Freely distributed under the Apache 2.0 Open Source License
2017-12-20 15:48:35 - For help type #help;;
2017-12-20 15:48:35 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2017-12-20 15:48:35 -   seq []
2017-12-20 15:48:35 - --> Added 'C:\Users\misadmin\Desktop\F sharp notebook' to library include path
2017-12-20 15:48:35 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2017-12-20 15:48:35 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\NetMQ.dll' (file may be locked by F# Interactive process)
2017-12-20 15:48:35 - let generateSquare (min:int) (max:int): int seq = 
2017-12-20 15:48:35 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-20 15:48:35 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-20 15:48:35 - let rec squareBuilder ((goal, acc, min, max):int*int*int*int) : int seq =
2017-12-20 15:48:35 -     match (goal <= acc) with 
2017-12-20 15:48:35 -     | true -> Seq.empty
2017-12-20 15:48:35 -     | _ -> 
2017-12-20 15:48:35 -         let newSquare = generateSquare min max
2017-12-20 15:48:35 -         squareBuilder (goal, (acc + Seq.length newSquare), (min+1), (max+2))
2017-12-20 15:48:35 -         |> Seq.append newSquare
2017-12-20 15:48:35 -     
2017-12-20 15:48:35 - let adventOfCode (goal:int) : int = 
2017-12-20 15:48:35 -    
2017-12-20 15:48:35 -     squareBuilder (goal, 0, 1, 2)
2017-12-20 15:48:35 -     |> Seq.toList
2017-12-20 15:48:35 -     |> (fun distanceList -> distanceList.[goal-2])
2017-12-20 15:48:35 -     
2017-12-20 15:48:35 - adventOfCode 277678
2017-12-20 15:48:36 - squareBuilder (100, 0, 1, 2) |> Seq.toList
2017-12-20 15:48:36 - type Movement = Up | Left | Down | Right
2017-12-20 15:48:36 - let advanceMovement (movement:Movement) : Movement =
2017-12-20 15:48:36 -     match movement with
2017-12-20 15:48:36 -     | Up -> Left
2017-12-20 15:48:36 -     | Left -> Down
2017-12-20 15:48:36 -     | Down -> Right
2017-12-20 15:48:36 -     | Right -> Up
2017-12-20 15:48:36 -     
2017-12-20 15:48:36 - type Point = int*int
2017-12-20 15:48:36 - type Item = Point*int
2017-12-20 15:48:36 - let findVal (items:Item seq) (point:Point) : int =
2017-12-20 15:48:36 -     items
2017-12-20 15:48:36 -     |> Seq.find (fun (item, _) -> if item = point then true else false) 
2017-12-20 15:48:36 -     |> (fun (_, num) -> num)
2017-12-20 15:48:36 - let getVal ((x, y):Point) (items:Item seq) : Item = 
2017-12-20 15:48:36 -     seq [(x+1, y); (x+1, y+1); (x, y+1); (x-1, y+1); (x-1, y); (x-1, y-1); (x, y-1); (x+1, y-1);]
2017-12-20 15:48:36 -     |> Seq.map (findVal items)
2017-12-20 15:48:36 -     |> Seq.sum
2017-12-20 15:48:36 -     |> (fun num -> (x,y), num)
2017-12-20 15:48:36 -     
2017-12-20 15:48:37 - let updatePoint (movement:Movement) (point:Point) : Point =
2017-12-20 15:48:37 -     match movement with
2017-12-20 15:48:37 -     | Up -> point |> (fun (x, y) -> x, y+1)
2017-12-20 15:48:37 -     | Left -> point |> (fun (x, y) -> x-1, y)
2017-12-20 15:48:37 -     | Down -> point |> (fun (x, y) -> x, y-1)
2017-12-20 15:48:37 -     | Right -> point |> (fun (x, y) -> x+1, y)
2017-12-20 15:48:37 - let subFolder ((moveState, itemState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 15:48:37 -     
2017-12-20 15:48:37 -     let newPoint = 
2017-12-20 15:48:37 -         Seq.last itemState 
2017-12-20 15:48:37 -         |> (fun (point, _) -> point)
2017-12-20 15:48:37 -         |> updatePoint moveState
2017-12-20 15:48:37 -     
2017-12-20 15:48:37 -     let newItem = 
2017-12-20 15:48:37 -         getVal newPoint itemState
2017-12-20 15:48:37 -     
2017-12-20 15:48:37 -     newItem
2017-12-20 15:48:37 -     |> Seq.singleton
2017-12-20 15:48:37 -     |> Seq.append itemState
2017-12-20 15:48:37 -     |> (fun x -> (moveState, x))
2017-12-20 15:48:37 - let folder (num:int) ((moveState, pointState):Movement*Item seq)  : Movement*Item seq =
2017-12-20 15:48:37 -     
2017-12-20 15:48:37 -     let (fstMove, fstPoints) = Seq.fold subFolder (advanceMovement moveState, pointState) {1..num}
2017-12-20 15:48:37 -     
2017-12-20 15:48:37 -     let (newMove, sndPoints) = Seq.fold subFolder (advanceMovement fstMove, fstPoints) {1..num}
2017-12-20 15:48:37 -     
2017-12-20 15:48:37 -     (newMove, sndPoints)
2017-12-20 15:48:37 -     
2017-12-20 15:48:37 -     
2017-12-20 15:48:37 - let adventOfCode3 (limit:int) : Item = 
2017-12-20 15:48:37 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 15:48:37 -     
2017-12-20 15:48:37 -     let helper ((_, num):Item) : bool = 
2017-12-20 15:48:37 -         if num > limit then 
2017-12-20 15:48:37 -             true 
2017-12-20 15:48:37 -         else 
2017-12-20 15:48:37 -             false
2017-12-20 15:48:37 -     
2017-12-20 15:48:37 -     (Down, Seq.singleton ((0,0), 0))
2017-12-20 15:48:37 -     |> Seq.foldBack folder infiniSeq 
2017-12-20 15:48:37 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 15:48:37 - adventOfCode3 277678
2017-12-20 15:49:14 - shutdown request
2017-12-20 15:49:15 - // include directory, this will be replaced by the kernel
2017-12-20 15:49:15 - #I "C:\\Users\\misadmin\\Desktop\\F sharp notebook"
2017-12-20 15:49:15 - // load base dlls
2017-12-20 15:49:15 - #r "IfSharp.Kernel.dll"
2017-12-20 15:49:15 - #r "NetMQ.dll"
2017-12-20 15:49:15 - // open the global functions and methods
2017-12-20 15:49:15 - open IfSharp.Kernel
2017-12-20 15:49:15 - open IfSharp.Kernel.Globals
2017-12-20 15:49:21 - F# Interactive for F# 4.1
2017-12-20 15:49:21 - Freely distributed under the Apache 2.0 Open Source License
2017-12-20 15:49:21 - For help type #help;;
2017-12-20 15:49:21 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2017-12-20 15:49:21 -   seq []
2017-12-20 15:49:21 - --> Added 'C:\Users\misadmin\Desktop\F sharp notebook' to library include path
2017-12-20 15:49:21 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2017-12-20 15:49:21 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\NetMQ.dll' (file may be locked by F# Interactive process)
2017-12-20 15:49:42 - shutdown request
2017-12-20 15:49:43 - // include directory, this will be replaced by the kernel
2017-12-20 15:49:43 - #I "C:\\Users\\misadmin\\Desktop\\F sharp notebook"
2017-12-20 15:49:43 - // load base dlls
2017-12-20 15:49:43 - #r "IfSharp.Kernel.dll"
2017-12-20 15:49:43 - #r "NetMQ.dll"
2017-12-20 15:49:43 - // open the global functions and methods
2017-12-20 15:49:43 - open IfSharp.Kernel
2017-12-20 15:49:43 - open IfSharp.Kernel.Globals
2017-12-20 15:49:48 - F# Interactive for F# 4.1
2017-12-20 15:49:48 - Freely distributed under the Apache 2.0 Open Source License
2017-12-20 15:49:48 - For help type #help;;
2017-12-20 15:49:48 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2017-12-20 15:49:48 -   seq []
2017-12-20 15:49:48 - --> Added 'C:\Users\misadmin\Desktop\F sharp notebook' to library include path
2017-12-20 15:49:48 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2017-12-20 15:49:48 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\NetMQ.dll' (file may be locked by F# Interactive process)
2017-12-20 15:49:48 - let generateSquare (min:int) (max:int): int seq = 
2017-12-20 15:49:48 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-20 15:49:48 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-20 15:49:48 - let rec squareBuilder ((goal, acc, min, max):int*int*int*int) : int seq =
2017-12-20 15:49:48 -     match (goal <= acc) with 
2017-12-20 15:49:48 -     | true -> Seq.empty
2017-12-20 15:49:48 -     | _ -> 
2017-12-20 15:49:48 -         let newSquare = generateSquare min max
2017-12-20 15:49:48 -         squareBuilder (goal, (acc + Seq.length newSquare), (min+1), (max+2))
2017-12-20 15:49:48 -         |> Seq.append newSquare
2017-12-20 15:49:48 -     
2017-12-20 15:49:48 - let adventOfCode (goal:int) : int = 
2017-12-20 15:49:48 -    
2017-12-20 15:49:48 -     squareBuilder (goal, 0, 1, 2)
2017-12-20 15:49:48 -     |> Seq.toList
2017-12-20 15:49:48 -     |> (fun distanceList -> distanceList.[goal-2])
2017-12-20 15:49:48 -     
2017-12-20 15:49:49 - adventOfCode 277678
2017-12-20 15:49:49 - squareBuilder (100, 0, 1, 2) |> Seq.toList
2017-12-20 15:49:50 - type Movement = Up | Left | Down | Right
2017-12-20 15:49:50 - let advanceMovement (movement:Movement) : Movement =
2017-12-20 15:49:50 -     match movement with
2017-12-20 15:49:50 -     | Up -> Left
2017-12-20 15:49:50 -     | Left -> Down
2017-12-20 15:49:50 -     | Down -> Right
2017-12-20 15:49:50 -     | Right -> Up
2017-12-20 15:49:50 -     
2017-12-20 15:49:50 - type Point = int*int
2017-12-20 15:49:50 - type Item = Point*int
2017-12-20 15:49:50 - let findVal (items:Item seq) (point:Point) : int =
2017-12-20 15:49:50 -     items
2017-12-20 15:49:50 -     |> Seq.find (fun (item, _) -> if item = point then true else false) 
2017-12-20 15:49:50 -     |> (fun (_, num) -> num)
2017-12-20 15:49:50 - let getVal ((x, y):Point) (items:Item seq) : Item = 
2017-12-20 15:49:50 -     seq [(x+1, y); (x+1, y+1); (x, y+1); (x-1, y+1); (x-1, y); (x-1, y-1); (x, y-1); (x+1, y-1);]
2017-12-20 15:49:50 -     |> Seq.map (findVal items)
2017-12-20 15:49:50 -     |> Seq.sum
2017-12-20 15:49:50 -     |> (fun num -> (x,y), num)
2017-12-20 15:49:50 -     
2017-12-20 15:49:50 - let updatePoint (movement:Movement) (point:Point) : Point =
2017-12-20 15:49:50 -     match movement with
2017-12-20 15:49:50 -     | Up -> point |> (fun (x, y) -> x, y+1)
2017-12-20 15:49:50 -     | Left -> point |> (fun (x, y) -> x-1, y)
2017-12-20 15:49:50 -     | Down -> point |> (fun (x, y) -> x, y-1)
2017-12-20 15:49:50 -     | Right -> point |> (fun (x, y) -> x+1, y)
2017-12-20 15:49:50 - let subFolder ((moveState, itemState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 15:49:50 -     
2017-12-20 15:49:50 -     let newPoint = 
2017-12-20 15:49:50 -         Seq.last itemState 
2017-12-20 15:49:50 -         |> (fun (point, _) -> point)
2017-12-20 15:49:50 -         |> updatePoint moveState
2017-12-20 15:49:50 -     
2017-12-20 15:49:50 -     let newItem = 
2017-12-20 15:49:50 -         getVal newPoint itemState
2017-12-20 15:49:50 -     
2017-12-20 15:49:50 -     newItem
2017-12-20 15:49:50 -     |> Seq.singleton
2017-12-20 15:49:50 -     |> Seq.append itemState
2017-12-20 15:49:50 -     |> (fun x -> (moveState, x))
2017-12-20 15:49:50 - let folder (num:int) ((moveState, pointState):Movement*Item seq)  : Movement*Item seq =
2017-12-20 15:49:50 -     
2017-12-20 15:49:50 -     let (fstMove, fstPoints) = Seq.fold subFolder (advanceMovement moveState, pointState) {1..num}
2017-12-20 15:49:50 -     
2017-12-20 15:49:50 -     let (newMove, sndPoints) = Seq.fold subFolder (advanceMovement fstMove, fstPoints) {1..num}
2017-12-20 15:49:50 -     
2017-12-20 15:49:50 -     (newMove, sndPoints)
2017-12-20 15:49:50 -     
2017-12-20 15:49:50 -     
2017-12-20 15:49:50 - let adventOfCode3 (limit:int) : Item = 
2017-12-20 15:49:50 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 15:49:50 -     
2017-12-20 15:49:50 -     let helper ((_, num):Item) : bool = 
2017-12-20 15:49:50 -         if num > limit then 
2017-12-20 15:49:50 -             true 
2017-12-20 15:49:50 -         else 
2017-12-20 15:49:50 -             false
2017-12-20 15:49:50 -     
2017-12-20 15:49:50 -     (Down, Seq.singleton ((0,0), 0))
2017-12-20 15:49:50 -     |> Seq.foldBack folder infiniSeq 
2017-12-20 15:49:50 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 15:49:50 - adventOfCode3 5
2017-12-20 15:54:07 - shutdown request
2017-12-20 15:54:13 - // include directory, this will be replaced by the kernel
2017-12-20 15:54:13 - #I "C:\\Users\\misadmin\\Desktop\\F sharp notebook"
2017-12-20 15:54:13 - // load base dlls
2017-12-20 15:54:13 - #r "IfSharp.Kernel.dll"
2017-12-20 15:54:13 - #r "NetMQ.dll"
2017-12-20 15:54:13 - // open the global functions and methods
2017-12-20 15:54:13 - open IfSharp.Kernel
2017-12-20 15:54:13 - open IfSharp.Kernel.Globals
2017-12-20 15:54:20 - F# Interactive for F# 4.1
2017-12-20 15:54:20 - Freely distributed under the Apache 2.0 Open Source License
2017-12-20 15:54:20 - For help type #help;;
2017-12-20 15:54:20 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2017-12-20 15:54:20 -   seq []
2017-12-20 15:54:20 - --> Added 'C:\Users\misadmin\Desktop\F sharp notebook' to library include path
2017-12-20 15:54:20 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2017-12-20 15:54:20 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\NetMQ.dll' (file may be locked by F# Interactive process)
2017-12-20 15:54:20 - let generateSquare (min:int) (max:int): int seq = 
2017-12-20 15:54:20 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2017-12-20 15:54:20 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2017-12-20 15:54:20 - let rec squareBuilder ((goal, acc, min, max):int*int*int*int) : int seq =
2017-12-20 15:54:20 -     match (goal <= acc) with 
2017-12-20 15:54:20 -     | true -> Seq.empty
2017-12-20 15:54:20 -     | _ -> 
2017-12-20 15:54:20 -         let newSquare = generateSquare min max
2017-12-20 15:54:20 -         squareBuilder (goal, (acc + Seq.length newSquare), (min+1), (max+2))
2017-12-20 15:54:20 -         |> Seq.append newSquare
2017-12-20 15:54:20 -     
2017-12-20 15:54:20 - let adventOfCode (goal:int) : int = 
2017-12-20 15:54:20 -    
2017-12-20 15:54:20 -     squareBuilder (goal, 0, 1, 2)
2017-12-20 15:54:20 -     |> Seq.toList
2017-12-20 15:54:20 -     |> (fun distanceList -> distanceList.[goal-2])
2017-12-20 15:54:20 -     
2017-12-20 15:54:21 - adventOfCode 277678
2017-12-20 15:54:21 - squareBuilder (100, 0, 1, 2) |> Seq.toList
2017-12-20 15:54:21 - type Movement = Up | Left | Down | Right
2017-12-20 15:54:22 - let advanceMovement (movement:Movement) : Movement =
2017-12-20 15:54:22 -     match movement with
2017-12-20 15:54:22 -     | Up -> Left
2017-12-20 15:54:22 -     | Left -> Down
2017-12-20 15:54:22 -     | Down -> Right
2017-12-20 15:54:22 -     | Right -> Up
2017-12-20 15:54:22 -     
2017-12-20 15:54:22 - type Point = int*int
2017-12-20 15:54:22 - type Item = Point*int
2017-12-20 15:54:22 - let findVal (items:Item seq) (point:Point) : int =
2017-12-20 15:54:22 -     items
2017-12-20 15:54:22 -     |> Seq.find (fun (item, _) -> if item = point then true else false) 
2017-12-20 15:54:22 -     |> (fun (_, num) -> num)
2017-12-20 15:54:22 - let getVal ((x, y):Point) (items:Item seq) : Item = 
2017-12-20 15:54:22 -     seq [(x+1, y); (x+1, y+1); (x, y+1); (x-1, y+1); (x-1, y); (x-1, y-1); (x, y-1); (x+1, y-1);]
2017-12-20 15:54:22 -     |> Seq.map (findVal items)
2017-12-20 15:54:22 -     |> Seq.sum
2017-12-20 15:54:22 -     |> (fun num -> (x,y), num)
2017-12-20 15:54:22 -     
2017-12-20 15:54:22 - let updatePoint (movement:Movement) (point:Point) : Point =
2017-12-20 15:54:22 -     match movement with
2017-12-20 15:54:22 -     | Up -> point |> (fun (x, y) -> x, y+1)
2017-12-20 15:54:22 -     | Left -> point |> (fun (x, y) -> x-1, y)
2017-12-20 15:54:22 -     | Down -> point |> (fun (x, y) -> x, y-1)
2017-12-20 15:54:22 -     | Right -> point |> (fun (x, y) -> x+1, y)
2017-12-20 15:54:22 - let subFolder ((moveState, itemState):Movement*Item seq) (num:int) : Movement*Item seq =
2017-12-20 15:54:22 -     
2017-12-20 15:54:22 -     let newPoint = 
2017-12-20 15:54:22 -         Seq.last itemState 
2017-12-20 15:54:22 -         |> (fun (point, _) -> point)
2017-12-20 15:54:22 -         |> updatePoint moveState
2017-12-20 15:54:22 -     
2017-12-20 15:54:22 -     let newItem = 
2017-12-20 15:54:22 -         getVal newPoint itemState
2017-12-20 15:54:22 -     
2017-12-20 15:54:22 -     newItem
2017-12-20 15:54:22 -     |> Seq.singleton
2017-12-20 15:54:22 -     |> Seq.append itemState
2017-12-20 15:54:22 -     |> (fun x -> (moveState, x))
2017-12-20 15:54:22 - let folder (num:int) ((moveState, pointState):Movement*Item seq)  : Movement*Item seq =
2017-12-20 15:54:22 -     
2017-12-20 15:54:22 -     let (fstMove, fstPoints) = Seq.fold subFolder (advanceMovement moveState, pointState) {1..num}
2017-12-20 15:54:22 -     
2017-12-20 15:54:22 -     let (newMove, sndPoints) = Seq.fold subFolder (advanceMovement fstMove, fstPoints) {1..num}
2017-12-20 15:54:22 -     
2017-12-20 15:54:22 -     (newMove, sndPoints)
2017-12-20 15:54:22 -     
2017-12-20 15:54:22 -     
2017-12-20 15:54:22 - let adventOfCode3 (limit:int) : Item = 
2017-12-20 15:54:22 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 15:54:22 -     
2017-12-20 15:54:22 -     let helper ((_, num):Item) : bool = 
2017-12-20 15:54:22 -         if num > limit then 
2017-12-20 15:54:22 -             true 
2017-12-20 15:54:22 -         else 
2017-12-20 15:54:22 -             false
2017-12-20 15:54:22 -     
2017-12-20 15:54:22 -     (Down, Seq.singleton ((0,0), 0))
2017-12-20 15:54:22 -     |> Seq.foldBack folder {1...1000}
2017-12-20 15:54:22 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 15:54:23 - Unexpected symbol '.' in expression
2017-12-20 15:54:23 - adventOfCode3 5
2017-12-20 15:54:23 - The value or constructor 'adventOfCode3' is not defined. Maybe you want one of the following:
2017-12-20 15:54:23 -    adventOfCode
2017-12-20 15:54:29 - let adventOfCode3 (limit:int) : Item = 
2017-12-20 15:54:29 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 15:54:29 -     
2017-12-20 15:54:29 -     let helper ((_, num):Item) : bool = 
2017-12-20 15:54:29 -         if num > limit then 
2017-12-20 15:54:29 -             true 
2017-12-20 15:54:29 -         else 
2017-12-20 15:54:29 -             false
2017-12-20 15:54:29 -     
2017-12-20 15:54:29 -     (Down, Seq.singleton ((0,0), 0))
2017-12-20 15:54:29 -     |> Seq.foldBack folder {1..1000}
2017-12-20 15:54:29 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 15:54:31 - adventOfCode3 5
2017-12-20 15:54:31 - Expression evaluation failed: Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 15:54:31 - KeyNotFoundExceptionException of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2017-12-20 15:54:31 -    at Microsoft.FSharp.Collections.SeqModule.Find[T](FSharpFunc`2 predicate, IEnumerable`1 source)
2017-12-20 15:54:31 -    at FSI_0013.findVal(IEnumerable`1 items, Int32 point_0, Int32 point_1) in C:\Users\misadmin\FSharpPractice\input.fsx:line 4
2017-12-20 15:54:31 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& )
2017-12-20 15:54:31 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2017-12-20 15:54:31 -    at FSI_0014.getVal(Int32 _arg1_0, Int32 _arg1_1, IEnumerable`1 items) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2017-12-20 15:54:31 -    at FSI_0016.subFolder(Movement _arg1_0, IEnumerable`1 _arg1_1, Int32 num) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 15:54:31 -    at Microsoft.FSharp.Collections.SeqModule.Fold[T,TState](FSharpFunc`2 folder, TState state, IEnumerable`1 source)
2017-12-20 15:54:31 -    at FSI_0017.folder(Int32 num, Movement _arg1_0, IEnumerable`1 _arg1_1) in C:\Users\misadmin\FSharpPractice\input.fsx:line 3
2017-12-20 15:54:31 -    at Microsoft.FSharp.Collections.SeqModule.FoldBack[T,TState](FSharpFunc`2 folder, IEnumerable`1 source, TState state)
2017-12-20 15:54:31 -    at FSI_0020.adventOfCode3(Int32 limit) in C:\Users\misadmin\FSharpPractice\input.fsx:line 10
2017-12-20 15:54:31 -    at <StartupCode$FSI_0021>.$FSI_0021.main@()
2017-12-20 16:02:47 - let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 16:02:47 - Seq.find (fun x -> x < 4) infiniSeq
2017-12-20 16:03:16 - let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 16:03:16 - Seq.take (fun x -> x < 4) infiniSeq
2017-12-20 16:03:16 - This function takes too many arguments, or is used in a context where a function is not expected
2017-12-20 16:04:15 - let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 16:04:15 - Seq.take 9 infiniSeq
2017-12-20 16:04:32 - let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 16:04:32 - Seq.take 9 infiniSeq |> Seq.toList
2017-12-20 16:05:07 - let adventOfCode3 (limit:int) : Item = 
2017-12-20 16:05:07 -     let infiniSeq = Seq.initInfinite (fun index -> index + 1)
2017-12-20 16:05:07 -     
2017-12-20 16:05:07 -     let helper ((_, num):Item) : bool = 
2017-12-20 16:05:07 -         if num > limit then 
2017-12-20 16:05:07 -             true 
2017-12-20 16:05:07 -         else 
2017-12-20 16:05:07 -             false
2017-12-20 16:05:07 -     
2017-12-20 16:05:07 -     (Down, Seq.singleton ((0,0), 0))
2017-12-20 16:05:07 -     |> Seq.foldBack folder infiniSeq
2017-12-20 16:05:07 -     |> (fun (_, items) -> Seq.find helper items)
2017-12-20 16:05:19 - adventOfCode3 5
2017-12-20 16:14:33 - Expression evaluation failed: Exception of type 'System.OutOfMemoryException' was thrown.
2017-12-20 16:14:33 - OutOfMemoryExceptionException of type 'System.OutOfMemoryException' was thrown.
2017-12-20 16:14:33 -    at System.Collections.Generic.List`1.set_Capacity(Int32 value)
2017-12-20 16:14:33 -    at System.Collections.Generic.List`1.EnsureCapacity(Int32 min)
2017-12-20 16:14:33 -    at System.Collections.Generic.List`1.Add(T item)
2017-12-20 16:14:33 -    at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)
2017-12-20 16:14:33 -    at Microsoft.FSharp.Collections.SeqModule.ToArray[T](IEnumerable`1 source)
2017-12-20 16:14:33 -    at Microsoft.FSharp.Collections.SeqModule.FoldBack[T,TState](FSharpFunc`2 folder, IEnumerable`1 source, TState state)
2017-12-20 16:14:33 -    at FSI_0029.adventOfCode3(Int32 limit) in C:\Users\misadmin\FSharpPractice\input.fsx:line 10
2017-12-20 16:14:33 -    at <StartupCode$FSI_0030>.$FSI_0030.main@()
2018-01-10 16:44:59 - // include directory, this will be replaced by the kernel
2018-01-10 16:44:59 - #I "C:\\Users\\misadmin\\Desktop\\F sharp notebook"
2018-01-10 16:44:59 - // load base dlls
2018-01-10 16:44:59 - #r "IfSharp.Kernel.dll"
2018-01-10 16:44:59 - #r "NetMQ.dll"
2018-01-10 16:44:59 - // open the global functions and methods
2018-01-10 16:44:59 - open IfSharp.Kernel
2018-01-10 16:44:59 - open IfSharp.Kernel.Globals
2018-01-10 16:45:05 - F# Interactive for F# 4.1
2018-01-10 16:45:05 - Freely distributed under the Apache 2.0 Open Source License
2018-01-10 16:45:05 - For help type #help;;
2018-01-10 16:45:05 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-01-10 16:45:05 -   seq []
2018-01-10 16:45:05 - --> Added 'C:\Users\misadmin\Desktop\F sharp notebook' to library include path
2018-01-10 16:45:05 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-01-10 16:45:05 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\NetMQ.dll' (file may be locked by F# Interactive process)
2018-01-10 16:45:08 - Unknown content type on shell. msg_type is `comm_info_request`
2018-01-11 11:04:34 - // include directory, this will be replaced by the kernel
2018-01-11 11:04:34 - #I "C:\\Users\\misadmin\\Desktop\\F sharp notebook"
2018-01-11 11:04:34 - // load base dlls
2018-01-11 11:04:34 - #r "IfSharp.Kernel.dll"
2018-01-11 11:04:34 - #r "NetMQ.dll"
2018-01-11 11:04:34 - // open the global functions and methods
2018-01-11 11:04:34 - open IfSharp.Kernel
2018-01-11 11:04:34 - open IfSharp.Kernel.Globals
2018-01-11 11:04:40 - F# Interactive for F# 4.1
2018-01-11 11:04:40 - Freely distributed under the Apache 2.0 Open Source License
2018-01-11 11:04:40 - For help type #help;;
2018-01-11 11:04:40 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-01-11 11:04:40 -   seq []
2018-01-11 11:04:40 - --> Added 'C:\Users\misadmin\Desktop\F sharp notebook' to library include path
2018-01-11 11:04:40 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-01-11 11:04:40 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\NetMQ.dll' (file may be locked by F# Interactive process)
2018-01-11 11:04:42 - Unknown content type on shell. msg_type is `comm_info_request`
2018-01-11 11:49:14 - let getScore (data:Item) : int =
2018-01-11 11:49:14 -     data |> (fun (_, num, _) -> num)
2018-01-11 11:49:14 - The type 'Item' is not defined.
2018-01-11 11:49:21 - type Movement = Up | Left | Down | Right
2018-01-11 11:49:22 - let advanceMovement (movement:Movement) : Movement =
2018-01-11 11:49:22 -     match movement with
2018-01-11 11:49:22 -     | Up -> Left
2018-01-11 11:49:22 -     | Left -> Down
2018-01-11 11:49:22 -     | Down -> Right
2018-01-11 11:49:22 -     | Right -> Up
2018-01-11 11:49:22 -     
2018-01-11 11:49:24 - type Point = int*int
2018-01-11 11:49:27 - type Item = Point*int*Movement
2018-01-11 11:49:29 - let getSeqEnd (data:seq<'T>) : 'T = 
2018-01-11 11:49:29 -     Seq.rev data
2018-01-11 11:49:29 -     |> Seq.head   
2018-01-11 11:49:31 - let getScore (data:Item) : int =
2018-01-11 11:49:31 -     data |> (fun (_, num, _) -> num)
2018-01-11 11:51:22 - let rec finder (limit:int) (current:Item seq) : Item seq =
2018-01-11 11:51:22 -     if (current >> getSeqEnd >> getScore)) >= limit then
2018-01-11 11:51:22 -         current
2018-01-11 11:51:22 -     else
2018-01-11 11:51:22 -         let newList = addNewPoint current
2018-01-11 11:51:22 -         finder limit newList Seq.
2018-01-11 11:51:22 -         
2018-01-11 11:51:22 - Unexpected symbol ')' in expression
2018-01-11 11:51:22 - Incomplete conditional. Expected 'if <expr> then <expr>' or 'if <expr> then <expr> else <expr>'.
2018-01-11 11:51:22 - Unexpected keyword 'else' in binding. Expected incomplete structured construct at or before this point or other token.
2018-01-11 11:51:22 - Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.
2018-01-11 11:51:22 - Missing qualification after '.'
2018-01-11 11:51:22 - Incomplete structured construct at or before this point in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.
2018-01-11 11:51:22 - parse error
2018-01-11 11:51:28 - let rec finder (limit:int) (current:Item seq) : Item seq =
2018-01-11 11:51:28 -     if (current >> getSeqEnd >> getScore) >= limit then
2018-01-11 11:51:28 -         current
2018-01-11 11:51:28 -     else
2018-01-11 11:51:28 -         let newList = addNewPoint current
2018-01-11 11:51:28 -         finder limit newList Seq.
2018-01-11 11:51:28 -         
2018-01-11 11:51:28 - Missing qualification after '.'
2018-01-11 11:51:28 - The type '('a -> 'b)' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface
2018-01-11 11:51:28 - This expression was expected to have type
2018-01-11 11:51:28 -     'obj -> seq<Item>'    
2018-01-11 11:51:28 - but here has type
2018-01-11 11:51:28 -     'seq<Item>'    
2018-01-11 11:51:28 - This expression was expected to have type
2018-01-11 11:51:28 -     'obj -> int'    
2018-01-11 11:51:28 - but here has type
2018-01-11 11:51:28 -     'int'    
2018-01-11 11:51:28 - The value or constructor 'addNewPoint' is not defined.
2018-01-11 11:51:28 - This value is not a function and cannot be applied
2018-01-11 11:51:42 - let rec finder (limit:int) (current:Item seq) : Item seq =
2018-01-11 11:51:42 -     if (current |> getSeqEnd >> getScore) >= limit then
2018-01-11 11:51:42 -         current
2018-01-11 11:51:42 -     else
2018-01-11 11:51:42 -         let newList = addNewPoint current
2018-01-11 11:51:42 -         finder limit newList Seq.
2018-01-11 11:51:42 -         
2018-01-11 11:51:42 - Missing qualification after '.'
2018-01-11 11:51:42 - The type '('a -> 'b)' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface
2018-01-11 11:51:42 - Type mismatch. Expecting a
2018-01-11 11:51:42 -     'seq<Item> -> obj -> Item'    
2018-01-11 11:51:42 - but given a
2018-01-11 11:51:42 -     'seq<Item> -> Item'    
2018-01-11 11:51:42 - The type 'obj -> Item' does not match the type 'Item'
2018-01-11 11:51:42 - This expression was expected to have type
2018-01-11 11:51:42 -     'obj -> int'    
2018-01-11 11:51:42 - but here has type
2018-01-11 11:51:42 -     'int'    
2018-01-11 11:51:42 - The value or constructor 'addNewPoint' is not defined.
2018-01-11 11:51:42 - This value is not a function and cannot be applied
2018-01-11 11:52:07 - let rec finder (limit:int) (current:Item seq) : Item seq =
2018-01-11 11:52:07 -     if (current |> (getSeqEnd >> getScore) >= limit then
2018-01-11 11:52:07 -         current
2018-01-11 11:52:07 -     else
2018-01-11 11:52:07 -         let newList = addNewPoint current
2018-01-11 11:52:07 -         finder limit newList Seq.
2018-01-11 11:52:07 -         
2018-01-11 11:52:07 - Unexpected keyword 'else' in expression
2018-01-11 11:52:07 - Incomplete conditional. Expected 'if <expr> then <expr>' or 'if <expr> then <expr> else <expr>'.
2018-01-11 11:52:07 - Unexpected end of input
2018-01-11 11:52:07 - Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.
2018-01-11 11:53:13 - let getScore (data:Item) : int =
2018-01-11 11:53:13 -     data |> (fun (_, num, _) -> num)
2018-01-11 11:53:13 - let getCoords (data:Item) : Point
2018-01-11 11:53:13 - Incomplete structured construct at or before this point in binding. Expected '=' or other token.
2018-01-11 11:54:34 - let getScore (data:Item) : int =
2018-01-11 11:54:34 -     data |> (fun (_, num, _) -> num)
2018-01-11 11:54:34 - let getCoords (data:Item) : Point = 
2018-01-11 11:54:34 -     data |> (fun (point, _, _) -> point)
2018-01-11 11:54:34 -     
2018-01-11 11:54:34 - let getDirection (data:Item) : Movement = 
2018-01-11 11:54:34 -     data |> (fun (_, _, direction) -> direction)
2018-01-11 12:20:29 - let findVal (items:Item seq) (point:Point) : int =
2018-01-11 12:20:29 -     items
2018-01-11 12:20:29 -     |> Seq.find (fun (item, _, _) -> if item = point then true else false) 
2018-01-11 12:20:29 -     |> (fun (_, num, _) -> num)
2018-01-11 12:20:32 - let getScore (data:Item) : int =
2018-01-11 12:20:32 -     data |> (fun (_, num, _) -> num)
2018-01-11 12:20:32 - let getCoords (data:Item) : Point = 
2018-01-11 12:20:32 -     data |> (fun (point, _, _) -> point)
2018-01-11 12:20:32 -     
2018-01-11 12:20:32 - let getDirection (data:Item) : Movement = 
2018-01-11 12:20:32 -     data |> (fun (_, _, direction) -> direction)
2018-01-11 12:20:34 - let getVal ((x, y):Point) (items:Item seq) : int = 
2018-01-11 12:20:34 -     seq [(x+1, y); (x+1, y+1); (x, y+1); (x-1, y+1); (x-1, y); (x-1, y-1); (x, y-1); (x+1, y-1);]
2018-01-11 12:20:34 -     |> Seq.map (findVal items)
2018-01-11 12:20:34 -     |> Seq.sum
2018-01-11 12:20:37 - let addNewItem (current:Item seq) : Item = 
2018-01-11 12:20:37 -     let lastPoint = getEnd current
2018-01-11 12:20:37 -     let lastCoords = getCoords lastPoint
2018-01-11 12:20:37 -     let newMove = lastPoint |> getDirection |> advanceMovement
2018-01-11 12:20:37 -     let newCoords = updatePoint newMove lastCoords
2018-01-11 12:20:37 -     let newVal = getVal newCoords current
2018-01-11 12:20:37 -     
2018-01-11 12:20:37 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2018-01-11 12:22:11 - let addNewItem (current:Item seq) : Item = 
2018-01-11 12:22:11 -     let lastPoint = getEnd current
2018-01-11 12:22:11 -     let lastCoords = getCoords lastPoint
2018-01-11 12:22:11 -     let newMove = lastPoint |> getDirection |> advanceMovement
2018-01-11 12:22:11 -     let newCoords = updatePoint newMove lastCoords
2018-01-11 12:22:11 -     let newVal = getVal newCoords current
2018-01-11 12:22:11 -     (newCoords, newVal, newMove)
2018-01-11 12:22:11 -     
2018-01-11 12:22:11 - The value or constructor 'getEnd' is not defined. Maybe you want one of the following:
2018-01-11 12:22:11 -    getSeqEnd
2018-01-11 12:22:11 - The value or constructor 'updatePoint' is not defined.
2018-01-11 12:22:14 - let updatePoint (movement:Movement) (point:Point) : Point =
2018-01-11 12:22:14 -     match movement with
2018-01-11 12:22:14 -     | Up -> point |> (fun (x, y) -> x, y+1)
2018-01-11 12:22:14 -     | Left -> point |> (fun (x, y) -> x-1, y)
2018-01-11 12:22:14 -     | Down -> point |> (fun (x, y) -> x, y-1)
2018-01-11 12:22:14 -     | Right -> point |> (fun (x, y) -> x+1, y)
2018-01-11 12:22:15 - let addNewItem (current:Item seq) : Item = 
2018-01-11 12:22:15 -     let lastPoint = getEnd current
2018-01-11 12:22:15 -     let lastCoords = getCoords lastPoint
2018-01-11 12:22:15 -     let newMove = lastPoint |> getDirection |> advanceMovement
2018-01-11 12:22:15 -     let newCoords = updatePoint newMove lastCoords
2018-01-11 12:22:15 -     let newVal = getVal newCoords current
2018-01-11 12:22:15 -     (newCoords, newVal, newMove)
2018-01-11 12:22:15 -     
2018-01-11 12:22:15 - The value or constructor 'getEnd' is not defined. Maybe you want one of the following:
2018-01-11 12:22:15 -    getSeqEnd
2018-01-11 12:22:22 - let getEnd (data:seq<'T>) : 'T = 
2018-01-11 12:22:22 -     Seq.rev data
2018-01-11 12:22:22 -     |> Seq.head   
2018-01-11 12:22:29 - let addNewItem (current:Item seq) : Item = 
2018-01-11 12:22:29 -     let lastPoint = getEnd current
2018-01-11 12:22:29 -     let lastCoords = getCoords lastPoint
2018-01-11 12:22:29 -     let newMove = lastPoint |> getDirection |> advanceMovement
2018-01-11 12:22:29 -     let newCoords = updatePoint newMove lastCoords
2018-01-11 12:22:29 -     let newVal = getVal newCoords current
2018-01-11 12:22:29 -     (newCoords, newVal, newMove)
2018-01-11 12:22:29 -     
2018-01-11 12:22:35 - let rec finder (limit:int) (current:Item seq) : Item seq =
2018-01-11 12:22:35 -     if (getEnd >> getScore) current >= limit then
2018-01-11 12:22:35 -         current
2018-01-11 12:22:35 -     else
2018-01-11 12:22:35 -         let newItem = addNewItem current
2018-01-11 12:22:35 -         newItem
2018-01-11 12:22:35 -         |> Seq.singleton
2018-01-11 12:22:35 -         |> Seq.append current
2018-01-11 12:22:35 -         |> finder limit 
2018-01-11 12:22:35 -         
2018-01-11 12:23:46 - let generateSquare (min:int) (max:int): int seq = 
2018-01-11 12:23:46 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2018-01-11 12:23:46 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2018-01-11 12:23:46 - let rec squareBuilder ((goal, acc, min, max):int*int*int*int) : int seq =
2018-01-11 12:23:46 -     match (goal <= acc) with 
2018-01-11 12:23:46 -     | true -> Seq.empty
2018-01-11 12:23:46 -     | _ -> 
2018-01-11 12:23:46 -         let newSquare = generateSquare min max
2018-01-11 12:23:46 -         squareBuilder (goal, (acc + Seq.length newSquare), (min+1), (max+2))
2018-01-11 12:23:46 -         |> Seq.append newSquare
2018-01-11 12:23:46 -     
2018-01-11 12:23:46 - let adventOfCode3Part1 (goal:int) : int = 
2018-01-11 12:23:46 -    
2018-01-11 12:23:46 -     squareBuilder (goal, 0, 1, 2)
2018-01-11 12:23:46 -     |> Seq.toList
2018-01-11 12:23:46 -     |> (fun distanceList -> distanceList.[goal-2])
2018-01-11 12:23:46 -     
2018-01-11 12:23:47 - adventOfCode3Part1 277678
2018-01-11 12:23:47 - squareBuilder (100, 0, 1, 2) |> Seq.toList
2018-01-11 12:23:47 - type Movement = Up | Left | Down | Right
2018-01-11 12:23:47 - let advanceMovement (movement:Movement) : Movement =
2018-01-11 12:23:47 -     match movement with
2018-01-11 12:23:47 -     | Up -> Left
2018-01-11 12:23:47 -     | Left -> Down
2018-01-11 12:23:47 -     | Down -> Right
2018-01-11 12:23:47 -     | Right -> Up
2018-01-11 12:23:47 -     
2018-01-11 12:23:47 - type Point = int*int
2018-01-11 12:23:47 - type Item = Point*int*Movement
2018-01-11 12:23:47 - let getEnd (data:seq<'T>) : 'T = 
2018-01-11 12:23:47 -     Seq.rev data
2018-01-11 12:23:47 -     |> Seq.head   
2018-01-11 12:23:47 - let getScore (data:Item) : int =
2018-01-11 12:23:47 -     data |> (fun (_, num, _) -> num)
2018-01-11 12:23:47 - let getCoords (data:Item) : Point = 
2018-01-11 12:23:47 -     data |> (fun (point, _, _) -> point)
2018-01-11 12:23:47 -     
2018-01-11 12:23:47 - let getDirection (data:Item) : Movement = 
2018-01-11 12:23:47 -     data |> (fun (_, _, direction) -> direction)
2018-01-11 12:23:47 - let findVal (items:Item seq) (point:Point) : int =
2018-01-11 12:23:47 -     items
2018-01-11 12:23:47 -     |> Seq.find (fun (item, _, _) -> if item = point then true else false) 
2018-01-11 12:23:47 -     |> (fun (_, num, _) -> num)
2018-01-11 12:23:47 - let getVal ((x, y):Point) (items:Item seq) : int = 
2018-01-11 12:23:47 -     seq [(x+1, y); (x+1, y+1); (x, y+1); (x-1, y+1); (x-1, y); (x-1, y-1); (x, y-1); (x+1, y-1);]
2018-01-11 12:23:47 -     |> Seq.map (findVal items)
2018-01-11 12:23:47 -     |> Seq.sum
2018-01-11 12:23:47 - let updatePoint (movement:Movement) (point:Point) : Point =
2018-01-11 12:23:47 -     match movement with
2018-01-11 12:23:47 -     | Up -> point |> (fun (x, y) -> x, y+1)
2018-01-11 12:23:47 -     | Left -> point |> (fun (x, y) -> x-1, y)
2018-01-11 12:23:47 -     | Down -> point |> (fun (x, y) -> x, y-1)
2018-01-11 12:23:47 -     | Right -> point |> (fun (x, y) -> x+1, y)
2018-01-11 12:23:47 - let addNewItem (current:Item seq) : Item = 
2018-01-11 12:23:47 -     let lastPoint = getEnd current
2018-01-11 12:23:47 -     let lastCoords = getCoords lastPoint
2018-01-11 12:23:47 -     let newMove = lastPoint |> getDirection |> advanceMovement
2018-01-11 12:23:47 -     let newCoords = updatePoint newMove lastCoords
2018-01-11 12:23:47 -     let newVal = getVal newCoords current
2018-01-11 12:23:47 -     (newCoords, newVal, newMove)
2018-01-11 12:23:47 -     
2018-01-11 12:23:47 - let rec adventOfCode3 (limit:int) (current:Item seq) : Item seq =
2018-01-11 12:23:47 -     if (getEnd >> getScore) current >= limit then
2018-01-11 12:23:47 -         current
2018-01-11 12:23:47 -     else
2018-01-11 12:23:47 -         let newItem = addNewItem current
2018-01-11 12:23:47 -         newItem
2018-01-11 12:23:47 -         |> Seq.singleton
2018-01-11 12:23:47 -         |> Seq.append current
2018-01-11 12:23:47 -         |> finder limit 
2018-01-11 12:23:47 -         
2018-01-11 12:23:47 - The type 'FSI_0005.Movement' does not match the type 'FSI_0031.Movement'
2018-01-11 12:23:47 - The type 'FSI_0031.Movement' does not match the type 'FSI_0005.Movement'
2018-01-11 12:23:47 - adventOfCode3Part2 5
2018-01-11 12:23:47 - The value or constructor 'adventOfCode3Part2' is not defined. Maybe you want one of the following:
2018-01-11 12:23:47 -    adventOfCode3Part1
2018-01-11 12:24:11 - let rec adventOfCode3Part2 (limit:int) (current:Item seq) : Item seq =
2018-01-11 12:24:11 -     if (getEnd >> getScore) current >= limit then
2018-01-11 12:24:11 -         current
2018-01-11 12:24:11 -     else
2018-01-11 12:24:11 -         let newItem = addNewItem current
2018-01-11 12:24:11 -         newItem
2018-01-11 12:24:11 -         |> Seq.singleton
2018-01-11 12:24:11 -         |> Seq.append current
2018-01-11 12:24:11 -         |> adventOfCode3Part2 limit 
2018-01-11 12:24:11 -         
2018-01-11 12:24:16 - adventOfCode3Part2 5
2018-01-11 12:24:16 - Value restriction. The value 'it' has been inferred to have generic type
2018-01-11 12:24:16 -     val it : (seq<Item> -> seq<Item>)    
2018-01-11 12:24:16 - Either make the arguments to 'it' explicit or, if you do not intend for it to be generic, add a type annotation.
2018-01-11 12:25:16 - let rec adventOfCode3Part2 (limit:int) (current:Item seq) : int =
2018-01-11 12:25:16 -     if (getEnd >> getScore) current >= limit then
2018-01-11 12:25:16 -         current
2018-01-11 12:25:16 -         |> getEnd
2018-01-11 12:25:16 -         |> getScore
2018-01-11 12:25:16 -     else
2018-01-11 12:25:16 -         let newItem = addNewItem current
2018-01-11 12:25:16 -         newItem
2018-01-11 12:25:16 -         |> Seq.singleton
2018-01-11 12:25:16 -         |> Seq.append current
2018-01-11 12:25:16 -         |> adventOfCode3Part2 limit 
2018-01-11 12:25:16 -         
2018-01-11 12:25:57 - adventOfCode3Part2 100 (Seq.singleton ((0,0), 1, Down))
2018-01-11 12:25:57 - Expression evaluation failed: Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2018-01-11 12:25:57 - KeyNotFoundExceptionException of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2018-01-11 12:25:57 -    at Microsoft.FSharp.Collections.SeqModule.Find[T](FSharpFunc`2 predicate, IEnumerable`1 source)
2018-01-11 12:25:57 -    at FSI_0037.findVal(IEnumerable`1 items, Int32 point_0, Int32 point_1) in C:\Users\misadmin\FSharpPractice\input.fsx:line 4
2018-01-11 12:25:57 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& )
2018-01-11 12:25:57 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2018-01-11 12:25:57 -    at FSI_0038.getVal(Int32 _arg1_0, Int32 _arg1_1, IEnumerable`1 items) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2018-01-11 12:25:57 -    at FSI_0040.addNewItem(IEnumerable`1 current) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2018-01-11 12:25:57 -    at FSI_0045.adventOfCode3Part2(Int32 limit, IEnumerable`1 current) in C:\Users\misadmin\FSharpPractice\input.fsx:line 7
2018-01-11 12:25:57 -    at <StartupCode$FSI_0046>.$FSI_0046.main@()
2018-01-11 12:30:15 - let getVal ((x, y):Point) (items:Item seq) : int = 
2018-01-11 12:30:15 -     seq [(x+1, y); (x+1, y+1); (x, y+1); (x-1, y+1); (x-1, y); (x-1, y-1); (x, y-1); (x+1, y-1);]
2018-01-11 12:30:15 -     |> Seq.filter (findVal items)
2018-01-11 12:30:15 -     |> Seq.sum
2018-01-11 12:30:15 - Type mismatch. Expecting a
2018-01-11 12:30:15 -     'int * int -> bool'    
2018-01-11 12:30:15 - but given a
2018-01-11 12:30:15 -     'int * int -> int'    
2018-01-11 12:30:15 - The type 'bool' does not match the type 'int'
2018-01-11 12:30:15 - Type mismatch. Expecting a
2018-01-11 12:30:15 -     'int * int -> bool'    
2018-01-11 12:30:15 - but given a
2018-01-11 12:30:15 -     'int * int -> int'    
2018-01-11 12:30:15 - The type 'bool' does not match the type 'int'
2018-01-11 12:30:15 - Expecting a type supporting the operator '+' but given a tuple type
2018-01-11 12:34:25 - let findVal (item:Item) : bool =
2018-01-11 12:34:25 -     let point = getCoords item
2018-01-11 12:34:25 -     seq [(x+1, y); (x+1, y+1); (x, y+1); (x-1, y+1); (x-1, y); (x-1, y-1); (x, y-1); (x+1, y-1);]
2018-01-11 12:34:25 -     Seq.exists point 
2018-01-11 12:34:25 - The value or constructor 'x' is not defined.
2018-01-11 12:34:25 - The value or constructor 'y' is not defined.
2018-01-11 12:34:25 - The value or constructor 'x' is not defined.
2018-01-11 12:34:25 - The value or constructor 'y' is not defined.
2018-01-11 12:34:25 - The value or constructor 'x' is not defined.
2018-01-11 12:34:25 - The value or constructor 'y' is not defined.
2018-01-11 12:34:25 - The value or constructor 'x' is not defined.
2018-01-11 12:34:25 - The value or constructor 'y' is not defined.
2018-01-11 12:34:25 - The value or constructor 'x' is not defined.
2018-01-11 12:34:25 - The value or constructor 'y' is not defined.
2018-01-11 12:34:25 - The value or constructor 'x' is not defined.
2018-01-11 12:34:25 - The value or constructor 'y' is not defined.
2018-01-11 12:34:25 - The value or constructor 'x' is not defined.
2018-01-11 12:34:25 - The value or constructor 'y' is not defined.
2018-01-11 12:34:25 - The value or constructor 'x' is not defined.
2018-01-11 12:34:25 - The value or constructor 'y' is not defined.
2018-01-11 12:34:25 - The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.
2018-01-11 12:34:25 - This expression was expected to have type
2018-01-11 12:34:25 -     'bool'    
2018-01-11 12:34:25 - but here has type
2018-01-11 12:34:25 -     'seq<obj> -> bool'    
2018-01-11 12:34:25 - This expression was expected to have type
2018-01-11 12:34:25 -     'obj -> bool'    
2018-01-11 12:34:25 - but here has type
2018-01-11 12:34:25 -     'Point'    
2018-01-11 12:34:25 - This expression was expected to have type
2018-01-11 12:34:25 -     'bool'    
2018-01-11 12:34:25 - but here has type
2018-01-11 12:34:25 -     'seq<obj> -> bool'    
2018-01-11 12:34:29 - let findVal (item:Item) : bool =
2018-01-11 12:34:29 -     let point = getCoords item
2018-01-11 12:34:29 -     seq [(x+1, y); (x+1, y+1); (x, y+1); (x-1, y+1); (x-1, y); (x-1, y-1); (x, y-1); (x+1, y-1);]
2018-01-11 12:34:29 -     Seq.exists point 
2018-01-11 12:34:29 - The value or constructor 'x' is not defined.
2018-01-11 12:34:29 - The value or constructor 'y' is not defined.
2018-01-11 12:34:29 - The value or constructor 'x' is not defined.
2018-01-11 12:34:29 - The value or constructor 'y' is not defined.
2018-01-11 12:34:29 - The value or constructor 'x' is not defined.
2018-01-11 12:34:29 - The value or constructor 'y' is not defined.
2018-01-11 12:34:29 - The value or constructor 'x' is not defined.
2018-01-11 12:34:29 - The value or constructor 'y' is not defined.
2018-01-11 12:34:29 - The value or constructor 'x' is not defined.
2018-01-11 12:34:29 - The value or constructor 'y' is not defined.
2018-01-11 12:34:29 - The value or constructor 'x' is not defined.
2018-01-11 12:34:29 - The value or constructor 'y' is not defined.
2018-01-11 12:34:29 - The value or constructor 'x' is not defined.
2018-01-11 12:34:29 - The value or constructor 'y' is not defined.
2018-01-11 12:34:29 - The value or constructor 'x' is not defined.
2018-01-11 12:34:29 - The value or constructor 'y' is not defined.
2018-01-11 12:34:29 - The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.
2018-01-11 12:34:29 - This expression was expected to have type
2018-01-11 12:34:29 -     'bool'    
2018-01-11 12:34:29 - but here has type
2018-01-11 12:34:29 -     'seq<obj> -> bool'    
2018-01-11 12:34:29 - This expression was expected to have type
2018-01-11 12:34:29 -     'obj -> bool'    
2018-01-11 12:34:29 - but here has type
2018-01-11 12:34:29 -     'Point'    
2018-01-11 12:34:29 - This expression was expected to have type
2018-01-11 12:34:29 -     'bool'    
2018-01-11 12:34:29 - but here has type
2018-01-11 12:34:29 -     'seq<obj> -> bool'    
2018-01-11 12:34:32 - let findVal (item:Item) : bool =
2018-01-11 12:34:32 -     let point = getCoords item
2018-01-11 12:34:32 -     seq [(x+1, y); (x+1, y+1); (x, y+1); (x-1, y+1); (x-1, y); (x-1, y-1); (x, y-1); (x+1, y-1);]
2018-01-11 12:34:32 -     Seq.exists point 
2018-01-11 12:34:32 - The value or constructor 'x' is not defined.
2018-01-11 12:34:32 - The value or constructor 'y' is not defined.
2018-01-11 12:34:32 - The value or constructor 'x' is not defined.
2018-01-11 12:34:32 - The value or constructor 'y' is not defined.
2018-01-11 12:34:32 - The value or constructor 'x' is not defined.
2018-01-11 12:34:32 - The value or constructor 'y' is not defined.
2018-01-11 12:34:32 - The value or constructor 'x' is not defined.
2018-01-11 12:34:32 - The value or constructor 'y' is not defined.
2018-01-11 12:34:32 - The value or constructor 'x' is not defined.
2018-01-11 12:34:32 - The value or constructor 'y' is not defined.
2018-01-11 12:34:32 - The value or constructor 'x' is not defined.
2018-01-11 12:34:32 - The value or constructor 'y' is not defined.
2018-01-11 12:34:32 - The value or constructor 'x' is not defined.
2018-01-11 12:34:32 - The value or constructor 'y' is not defined.
2018-01-11 12:34:32 - The value or constructor 'x' is not defined.
2018-01-11 12:34:32 - The value or constructor 'y' is not defined.
2018-01-11 12:34:32 - The result of this expression is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.
2018-01-11 12:34:32 - This expression was expected to have type
2018-01-11 12:34:32 -     'bool'    
2018-01-11 12:34:32 - but here has type
2018-01-11 12:34:32 -     'seq<obj> -> bool'    
2018-01-11 12:34:32 - This expression was expected to have type
2018-01-11 12:34:32 -     'obj -> bool'    
2018-01-11 12:34:32 - but here has type
2018-01-11 12:34:32 -     'Point'    
2018-01-11 12:34:32 - This expression was expected to have type
2018-01-11 12:34:32 -     'bool'    
2018-01-11 12:34:32 - but here has type
2018-01-11 12:34:32 -     'seq<obj> -> bool'    
2018-01-11 12:43:36 - let getVal ((x, y):Point) (items:Item seq) : int = 
2018-01-11 12:43:36 -     items
2018-01-11 12:43:36 -     |> Seq.filter (findVal (x, y))
2018-01-11 12:43:36 -     |> Seq.map (fun (_, num, _) -> num)
2018-01-11 12:43:36 -     |> Seq.sum
2018-01-11 12:43:36 - Type mismatch. Expecting a
2018-01-11 12:43:36 -     'Item -> bool'    
2018-01-11 12:43:36 - but given a
2018-01-11 12:43:36 -     'int * int -> int'    
2018-01-11 12:43:36 - The type 'Point' does not match the type 'int'
2018-01-11 12:43:36 - The type 'obj * obj' is not compatible with the type 'seq<Item>'
2018-01-11 12:43:36 - Type mismatch. Expecting a
2018-01-11 12:43:36 -     'Item -> bool'    
2018-01-11 12:43:36 - but given a
2018-01-11 12:43:36 -     'int * int -> int'    
2018-01-11 12:43:36 - The type 'Point' does not match the type 'int'
2018-01-11 12:43:47 - let findVal (point:Point) (item:Item) : bool =
2018-01-11 12:43:47 -     point
2018-01-11 12:43:47 -     |> makeSurroundingPoints
2018-01-11 12:43:47 -     |> Seq.exists (getCoords item)
2018-01-11 12:43:47 - The value or constructor 'makeSurroundingPoints' is not defined.
2018-01-11 12:43:47 - This expression was expected to have type
2018-01-11 12:43:47 -     'obj -> bool'    
2018-01-11 12:43:47 - but here has type
2018-01-11 12:43:47 -     'Point'    
2018-01-11 12:43:47 - This expression was expected to have type
2018-01-11 12:43:47 -     'obj -> bool'    
2018-01-11 12:43:47 - but here has type
2018-01-11 12:43:47 -     'Point'    
2018-01-11 12:43:50 - let makeSurroundingPoints ((x, y):Point) : Point seq = 
2018-01-11 12:43:50 -     seq [(x+1, y); (x+1, y+1); (x, y+1); (x-1, y+1); (x-1, y); (x-1, y-1); (x, y-1); (x+1, y-1);]
2018-01-11 12:43:53 - let findVal (point:Point) (item:Item) : bool =
2018-01-11 12:43:53 -     point
2018-01-11 12:43:53 -     |> makeSurroundingPoints
2018-01-11 12:43:53 -     |> Seq.exists (getCoords item)
2018-01-11 12:43:53 - This expression was expected to have type
2018-01-11 12:43:53 -     'Point -> bool'    
2018-01-11 12:43:53 - but here has type
2018-01-11 12:43:53 -     'Point'    
2018-01-11 12:43:53 - This expression was expected to have type
2018-01-11 12:43:53 -     'Point -> bool'    
2018-01-11 12:43:53 - but here has type
2018-01-11 12:43:53 -     'Point'    
2018-01-11 12:45:51 - let findVal (point:Point) (item:Item) : bool =
2018-01-11 12:45:51 -     point
2018-01-11 12:45:51 -     |> makeSurroundingPoints
2018-01-11 12:45:51 -     |> Seq.exists (fun x -> (getCoords item) = x)
2018-01-11 12:46:00 - let findVal (point:Point) (item:Item) : bool =
2018-01-11 12:46:00 -     point
2018-01-11 12:46:00 -     |> makeSurroundingPoints
2018-01-11 12:46:00 -     |> Seq.exists (fun x -> (getCoords item) = x)
2018-01-11 12:46:02 - let getVal ((x, y):Point) (items:Item seq) : int = 
2018-01-11 12:46:02 -     items
2018-01-11 12:46:02 -     |> Seq.filter (findVal (x, y))
2018-01-11 12:46:02 -     |> Seq.map (fun (_, num, _) -> num)
2018-01-11 12:46:02 -     |> Seq.sum
2018-01-11 12:48:18 - adventOfCode3Part2 100 (Seq.singleton ((0,0), 1, Down))
2018-01-11 12:48:18 - Expression evaluation failed: Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2018-01-11 12:48:18 - KeyNotFoundExceptionException of type 'System.Collections.Generic.KeyNotFoundException' was thrown.
2018-01-11 12:48:18 -    at Microsoft.FSharp.Collections.SeqModule.Find[T](FSharpFunc`2 predicate, IEnumerable`1 source)
2018-01-11 12:48:18 -    at FSI_0037.findVal(IEnumerable`1 items, Int32 point_0, Int32 point_1) in C:\Users\misadmin\FSharpPractice\input.fsx:line 4
2018-01-11 12:48:18 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& )
2018-01-11 12:48:18 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2018-01-11 12:48:18 -    at FSI_0038.getVal(Int32 _arg1_0, Int32 _arg1_1, IEnumerable`1 items) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2018-01-11 12:48:18 -    at FSI_0040.addNewItem(IEnumerable`1 current) in C:\Users\misadmin\FSharpPractice\input.fsx:line 2
2018-01-11 12:48:18 -    at FSI_0045.adventOfCode3Part2(Int32 limit, IEnumerable`1 current) in C:\Users\misadmin\FSharpPractice\input.fsx:line 7
2018-01-11 12:48:18 -    at <StartupCode$FSI_0058>.$FSI_0058.main@()
2018-01-11 12:48:25 - let generateSquare (min:int) (max:int): int seq = 
2018-01-11 12:48:25 -     Seq.append {(max-1)..(-1)..min} {(min+1)..max}
2018-01-11 12:48:25 -     |> (fun x -> seq { for i in 1..4 do yield! x } )
2018-01-11 12:48:25 - let rec squareBuilder ((goal, acc, min, max):int*int*int*int) : int seq =
2018-01-11 12:48:25 -     match (goal <= acc) with 
2018-01-11 12:48:25 -     | true -> Seq.empty
2018-01-11 12:48:25 -     | _ -> 
2018-01-11 12:48:25 -         let newSquare = generateSquare min max
2018-01-11 12:48:25 -         squareBuilder (goal, (acc + Seq.length newSquare), (min+1), (max+2))
2018-01-11 12:48:25 -         |> Seq.append newSquare
2018-01-11 12:48:25 -     
2018-01-11 12:48:25 - let adventOfCode3Part1 (goal:int) : int = 
2018-01-11 12:48:25 -    
2018-01-11 12:48:25 -     squareBuilder (goal, 0, 1, 2)
2018-01-11 12:48:25 -     |> Seq.toList
2018-01-11 12:48:25 -     |> (fun distanceList -> distanceList.[goal-2])
2018-01-11 12:48:25 -     
2018-01-11 12:48:25 - adventOfCode3Part1 277678
2018-01-11 12:48:25 - squareBuilder (100, 0, 1, 2) |> Seq.toList
2018-01-11 12:48:25 - type Movement = Up | Left | Down | Right
2018-01-11 12:48:25 - let advanceMovement (movement:Movement) : Movement =
2018-01-11 12:48:25 -     match movement with
2018-01-11 12:48:25 -     | Up -> Left
2018-01-11 12:48:25 -     | Left -> Down
2018-01-11 12:48:25 -     | Down -> Right
2018-01-11 12:48:25 -     | Right -> Up
2018-01-11 12:48:25 -     
2018-01-11 12:48:25 - type Point = int*int
2018-01-11 12:48:25 - type Item = Point*int*Movement
2018-01-11 12:48:26 - let getEnd (data:seq<'T>) : 'T = 
2018-01-11 12:48:26 -     Seq.rev data
2018-01-11 12:48:26 -     |> Seq.head   
2018-01-11 12:48:26 - let getScore (data:Item) : int =
2018-01-11 12:48:26 -     data |> (fun (_, num, _) -> num)
2018-01-11 12:48:26 - let getCoords (data:Item) : Point = 
2018-01-11 12:48:26 -     data |> (fun (point, _, _) -> point)
2018-01-11 12:48:26 -     
2018-01-11 12:48:26 - let getDirection (data:Item) : Movement = 
2018-01-11 12:48:26 -     data |> (fun (_, _, direction) -> direction)
2018-01-11 12:48:26 - let makeSurroundingPoints ((x, y):Point) : Point seq = 
2018-01-11 12:48:26 -     seq [(x+1, y); (x+1, y+1); (x, y+1); (x-1, y+1); (x-1, y); (x-1, y-1); (x, y-1); (x+1, y-1);]
2018-01-11 12:48:26 - let findVal (point:Point) (item:Item) : bool =
2018-01-11 12:48:26 -     point
2018-01-11 12:48:26 -     |> makeSurroundingPoints
2018-01-11 12:48:26 -     |> Seq.exists (fun x -> (getCoords item) = x)
2018-01-11 12:48:26 - let getVal ((x, y):Point) (items:Item seq) : int = 
2018-01-11 12:48:26 -     items
2018-01-11 12:48:26 -     |> Seq.filter (findVal (x, y))
2018-01-11 12:48:26 -     |> Seq.map (fun (_, num, _) -> num)
2018-01-11 12:48:26 -     |> Seq.sum
2018-01-11 12:48:26 - let updatePoint (movement:Movement) (point:Point) : Point =
2018-01-11 12:48:26 -     match movement with
2018-01-11 12:48:26 -     | Up -> point |> (fun (x, y) -> x, y+1)
2018-01-11 12:48:26 -     | Left -> point |> (fun (x, y) -> x-1, y)
2018-01-11 12:48:26 -     | Down -> point |> (fun (x, y) -> x, y-1)
2018-01-11 12:48:26 -     | Right -> point |> (fun (x, y) -> x+1, y)
2018-01-11 12:48:26 - let addNewItem (current:Item seq) : Item = 
2018-01-11 12:48:26 -     let lastPoint = getEnd current
2018-01-11 12:48:26 -     let lastCoords = getCoords lastPoint
2018-01-11 12:48:26 -     let newMove = lastPoint |> getDirection |> advanceMovement
2018-01-11 12:48:26 -     let newCoords = updatePoint newMove lastCoords
2018-01-11 12:48:26 -     let newVal = getVal newCoords current
2018-01-11 12:48:26 -     (newCoords, newVal, newMove)
2018-01-11 12:48:26 -     
2018-01-11 12:48:26 - let rec adventOfCode3Part2 (limit:int) (current:Item seq) : int =
2018-01-11 12:48:26 -     if (getEnd >> getScore) current >= limit then
2018-01-11 12:48:26 -         current
2018-01-11 12:48:26 -         |> getEnd
2018-01-11 12:48:26 -         |> getScore
2018-01-11 12:48:26 -     else
2018-01-11 12:48:26 -         let newItem = addNewItem current
2018-01-11 12:48:26 -         newItem
2018-01-11 12:48:26 -         |> Seq.singleton
2018-01-11 12:48:26 -         |> Seq.append current
2018-01-11 12:48:26 -         |> adventOfCode3Part2 limit 
2018-01-11 12:48:26 -         
2018-01-11 12:48:26 - adventOfCode3Part2 100 (Seq.singleton ((0,0), 1, Down))
2018-01-11 12:49:57 - adventOfCode3Part2 1000 (Seq.singleton ((0,0), 1, Down))
2018-01-11 12:49:57 - adventOfCode3Part2 1000 (Seq.singleton ((0,0), 1, Down))
2018-01-11 12:50:31 - adventOfCode3Part2 277678 (Seq.singleton ((0,0), 1, Down))
2018-01-11 12:51:45 - let rec adventOfCode3Part2 (limit:int) (current:Item seq) : Item seq =
2018-01-11 12:51:45 -     if (getEnd >> getScore) current >= limit then
2018-01-11 12:51:45 -         current
2018-01-11 12:51:45 - //         |> getEnd
2018-01-11 12:51:45 - //         |> getScore
2018-01-11 12:51:45 -     else
2018-01-11 12:51:45 -         let newItem = addNewItem current
2018-01-11 12:51:45 -         newItem
2018-01-11 12:51:45 -         |> Seq.singleton
2018-01-11 12:51:45 -         |> Seq.append current
2018-01-11 12:51:45 -         |> adventOfCode3Part2 limit 
2018-01-11 12:51:45 -         
2018-01-11 12:51:47 - adventOfCode3Part2 100 (Seq.singleton ((0,0), 1, Down))
2018-01-11 13:22:12 - let addNewItem (current:Item seq) (newMove:Movement) : Item = 
2018-01-11 13:22:12 -     let lastPoint = getEnd current
2018-01-11 13:22:12 -     let lastCoords = getCoords lastPoint
2018-01-11 13:22:12 - //     let newMove = lastPoint |> getDirection |> advanceMovement
2018-01-11 13:22:12 -     let newCoords = updatePoint newMove lastCoords
2018-01-11 13:22:12 -     let newVal = getVal newCoords current
2018-01-11 13:22:12 -     (newCoords, newVal, newMove)
2018-01-11 13:22:12 -     
2018-01-11 13:24:08 - let getScore (data:Item) : int =
2018-01-11 13:24:08 -     data |> (fun (_, num -> num)
2018-01-11 13:24:08 - let getCoords (data:Item) : Point = 
2018-01-11 13:24:08 -     data |> (fun (point, _, _) -> point)
2018-01-11 13:24:08 -     
2018-01-11 13:24:08 - // let getDirection (data:Item) : Movement = 
2018-01-11 13:24:08 - //     data |> (fun (_, _, direction) -> direction)
2018-01-11 13:24:08 - Unexpected symbol '->' in pattern. Expected ')' or other token.
2018-01-11 13:24:08 - Unmatched '('
2018-01-11 13:24:08 - Possible incorrect indentation: this token is offside of context started at position (2:5). Try indenting this token further or using standard formatting conventions.
2018-01-11 13:24:08 - Unexpected symbol '=' in binding. Expected incomplete structured construct at or before this point or other token.
2018-01-11 13:24:17 - let getScore (data:Item) : int =
2018-01-11 13:24:17 -     data |> (fun (_, num -> num)
2018-01-11 13:24:17 - let getCoords (data:Item) : Point = 
2018-01-11 13:24:17 -     data |> (fun (point, _) -> point)
2018-01-11 13:24:17 -     
2018-01-11 13:24:17 - // let getDirection (data:Item) : Movement = 
2018-01-11 13:24:17 - //     data |> (fun (_, _, direction) -> direction)
2018-01-11 13:24:17 - Unexpected symbol '->' in pattern. Expected ')' or other token.
2018-01-11 13:24:17 - Unmatched '('
2018-01-11 13:24:17 - Possible incorrect indentation: this token is offside of context started at position (2:5). Try indenting this token further or using standard formatting conventions.
2018-01-11 13:24:17 - Unexpected symbol '=' in binding. Expected incomplete structured construct at or before this point or other token.
2018-01-11 13:24:26 - let getScore (data:Item) : int =
2018-01-11 13:24:26 -     data |> (fun (_, num) -> num)
2018-01-11 13:24:26 - let getCoords (data:Item) : Point = 
2018-01-11 13:24:26 -     data |> (fun (point, _) -> point)
2018-01-11 13:24:26 -     
2018-01-11 13:24:26 - // let getDirection (data:Item) : Movement = 
2018-01-11 13:24:26 - //     data |> (fun (_, _, direction) -> direction)
2018-01-11 13:24:26 - Type mismatch. Expecting a
2018-01-11 13:24:26 -     'Item'    
2018-01-11 13:24:26 - but given a
2018-01-11 13:24:26 -     'Point * int'    
2018-01-11 13:24:26 - The tuples have differing lengths of 3 and 2
2018-01-11 13:24:26 - Type mismatch. Expecting a
2018-01-11 13:24:26 -     'Item'    
2018-01-11 13:24:26 - but given a
2018-01-11 13:24:26 -     'Point * int'    
2018-01-11 13:24:26 - The tuples have differing lengths of 3 and 2
2018-01-11 13:24:59 - type Item = Point*int
2018-01-11 13:25:05 - let getScore (data:Item) : int =
2018-01-11 13:25:05 -     data |> (fun (_, num) -> num)
2018-01-11 13:25:05 - let getCoords (data:Item) : Point = 
2018-01-11 13:25:05 -     data |> (fun (point, _) -> point)
2018-01-11 13:25:05 -     
2018-01-11 13:25:05 - // let getDirection (data:Item) : Movement = 
2018-01-11 13:25:05 - //     data |> (fun (_, _, direction) -> direction)
2018-01-11 13:25:06 - let getVal ((x, y):Point) (items:Item seq) : int = 
2018-01-11 13:25:06 -     items
2018-01-11 13:25:06 -     |> Seq.filter (findVal (x, y))
2018-01-11 13:25:06 -     |> Seq.map (fun (_, num) -> num)
2018-01-11 13:25:06 -     |> Seq.sum
2018-01-11 13:25:06 - Type mismatch. Expecting a
2018-01-11 13:25:06 -     'FSI_0091.Item -> Microsoft.FSharp.Core.bool'    
2018-01-11 13:25:06 - but given a
2018-01-11 13:25:06 -     'FSI_0067.Item -> Microsoft.FSharp.Core.bool'    
2018-01-11 13:25:06 - The tuples have differing lengths of 2 and 3
2018-01-11 13:25:06 - Type mismatch. Expecting a
2018-01-11 13:25:06 -     'FSI_0091.Item -> Microsoft.FSharp.Core.bool'    
2018-01-11 13:25:06 - but given a
2018-01-11 13:25:06 -     'FSI_0067.Item -> Microsoft.FSharp.Core.bool'    
2018-01-11 13:25:06 - The tuples have differing lengths of 2 and 3
2018-01-11 13:25:25 - let findVal (point:Point) (item:Item) : bool =
2018-01-11 13:25:25 -     point
2018-01-11 13:25:25 -     |> makeSurroundingPoints
2018-01-11 13:25:25 -     |> Seq.exists (fun x -> (getCoords item) = x)
2018-01-11 13:25:28 - let getVal ((x, y):Point) (items:Item seq) : int = 
2018-01-11 13:25:28 -     items
2018-01-11 13:25:28 -     |> Seq.filter (findVal (x, y))
2018-01-11 13:25:28 -     |> Seq.map (fun (_, num) -> num)
2018-01-11 13:25:28 -     |> Seq.sum
2018-01-11 13:25:31 - let updatePoint (movement:Movement) (point:Point) : Point =
2018-01-11 13:25:31 -     match movement with
2018-01-11 13:25:31 -     | Up -> point |> (fun (x, y) -> x, y+1)
2018-01-11 13:25:31 -     | Left -> point |> (fun (x, y) -> x-1, y)
2018-01-11 13:25:31 -     | Down -> point |> (fun (x, y) -> x, y-1)
2018-01-11 13:25:31 -     | Right -> point |> (fun (x, y) -> x+1, y)
2018-01-11 13:25:41 - let addNewItem (current:Item seq) (newMove:Movement) : Item = 
2018-01-11 13:25:41 -     let lastPoint = getEnd current
2018-01-11 13:25:41 -     let lastCoords = getCoords lastPoint
2018-01-11 13:25:41 - //     let newMove = lastPoint |> getDirection |> advanceMovement
2018-01-11 13:25:41 -     let newCoords = updatePoint newMove lastCoords
2018-01-11 13:25:41 -     let newVal = getVal newCoords current
2018-01-11 13:25:41 -     (newCoords, newVal)
2018-01-11 13:25:41 -     
2018-01-11 13:26:19 - let rec adventOfCode3Part2 (limit:int) (current:Item seq) (movement:Movement) (repeat:int) (advancement:int) : Item seq =
2018-01-11 13:26:19 -     if (getEnd >> getScore) current >= limit then
2018-01-11 13:26:19 -         current
2018-01-11 13:26:19 - //         |> getEnd
2018-01-11 13:26:19 - //         |> getScore
2018-01-11 13:26:19 -     else
2018-01-11 13:26:19 -         let newItem = addNewItem current
2018-01-11 13:26:19 -         newItem
2018-01-11 13:26:19 -         |> Seq.singleton
2018-01-11 13:26:19 -         |> Seq.append current
2018-01-11 13:26:19 -         |> adventOfCode3Part2 limit 
2018-01-11 13:26:19 -         
2018-01-11 13:26:19 - The type 'Movement -> Item' does not match the type 'Item'
2018-01-11 13:26:19 - The type 'Item' does not match the type 'Movement -> Item'
2018-01-11 13:26:19 - The type 'seq<Item>' does not match the type 'Movement -> int -> int -> seq<Item>'
2018-01-11 17:20:04 - let getNewParams (direction:Movement) (repeat:int) (advancement:int) : (Movement*int*int) =
2018-01-11 17:20:04 -     if repeat = advencement and (movement = Down or movement = Up) then
2018-01-11 17:20:04 -         ((advanceMovement direction), repeat + 1, 1)
2018-01-11 17:20:04 -     elif repeat = advencement and (movement = Right or movement = Left) then
2018-01-11 17:20:04 -         ((advanceMovement direction), repeat, 1)
2018-01-11 17:20:04 -     else
2018-01-11 17:20:04 -         (direction, repeact, advancement + 1)
2018-01-11 17:20:04 -         
2018-01-11 17:20:04 - Unexpected keyword 'and' in expression
2018-01-11 17:20:04 - Incomplete conditional. Expected 'if <expr> then <expr>' or 'if <expr> then <expr> else <expr>'.
2018-01-11 17:20:04 - Unexpected keyword 'elif' in binding. Expected incomplete structured construct at or before this point or other token.
2018-01-11 17:20:04 - Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.
2018-01-11 17:20:14 - let getNewParams (direction:Movement) (repeat:int) (advancement:int) : (Movement*int*int) =
2018-01-11 17:20:14 -     if repeat = advencement && (movement = Down or movement = Up) then
2018-01-11 17:20:14 -         ((advanceMovement direction), repeat + 1, 1)
2018-01-11 17:20:14 -     elif repeat = advencement and (movement = Right or movement = Left) then
2018-01-11 17:20:14 -         ((advanceMovement direction), repeat, 1)
2018-01-11 17:20:14 -     else
2018-01-11 17:20:14 -         (direction, repeact, advancement + 1)
2018-01-11 17:20:14 -         
2018-01-11 17:20:14 - Unexpected keyword 'and' in if/then/else expression
2018-01-11 17:20:14 - Unexpected keyword 'else' in binding. Expected incomplete structured construct at or before this point or other token.
2018-01-11 17:20:14 - Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.
2018-01-11 17:20:19 - let getNewParams (direction:Movement) (repeat:int) (advancement:int) : (Movement*int*int) =
2018-01-11 17:20:19 -     if repeat = advencement && (movement = Down or movement = Up) then
2018-01-11 17:20:19 -         ((advanceMovement direction), repeat + 1, 1)
2018-01-11 17:20:19 -     elif repeat = advencement && (movement = Right or movement = Left) then
2018-01-11 17:20:19 -         ((advanceMovement direction), repeat, 1)
2018-01-11 17:20:19 -     else
2018-01-11 17:20:19 -         (direction, repeact, advancement + 1)
2018-01-11 17:20:19 -         
2018-01-11 17:20:19 - The value or constructor 'advencement' is not defined. Maybe you want one of the following:
2018-01-11 17:20:19 -    advancement
2018-01-11 17:20:19 -    advanceMovement
2018-01-11 17:20:19 - In F# code, use 'e1 || e2' instead of 'e1 or e2'
2018-01-11 17:20:19 - The value or constructor 'movement' is not defined. Maybe you want one of the following:
2018-01-11 17:20:19 -    Movement
2018-01-11 17:20:19 - The value or constructor 'movement' is not defined. Maybe you want one of the following:
2018-01-11 17:20:19 -    Movement
2018-01-11 17:20:19 - The value or constructor 'advencement' is not defined. Maybe you want one of the following:
2018-01-11 17:20:19 -    advancement
2018-01-11 17:20:19 -    advanceMovement
2018-01-11 17:20:19 - In F# code, use 'e1 || e2' instead of 'e1 or e2'
2018-01-11 17:20:19 - The value or constructor 'movement' is not defined. Maybe you want one of the following:
2018-01-11 17:20:19 -    Movement
2018-01-11 17:20:19 - The value or constructor 'movement' is not defined. Maybe you want one of the following:
2018-01-11 17:20:19 -    Movement
2018-01-11 17:20:19 - The value or constructor 'repeact' is not defined. Maybe you want one of the following:
2018-01-11 17:20:19 -    repeat
2018-01-11 17:21:17 - let getNewParams (direction:Movement) (repeat:int) (advancement:int) : (Movement*int*int) =
2018-01-11 17:21:17 -     if repeat = advancement && (direction = Down || direction = Up) then
2018-01-11 17:21:17 -         ((advanceMovement direction), repeat + 1, 1)
2018-01-11 17:21:17 -     elif repeat = advancement && (direction = Right || direction = Left) then
2018-01-11 17:21:17 -         ((advanceMovement direction), repeat, 1)
2018-01-11 17:21:17 -     else
2018-01-11 17:21:17 -         (direction, repeat, advancement + 1)
2018-01-11 17:21:17 -         
2018-01-11 17:23:27 - let rec adventOfCode3Part2 (limit:int)  (direction:Movement) (repeat:int) (advancement:int) (current:Item seq) : int =
2018-01-11 17:23:27 -     if (getEnd >> getScore) current >= limit then
2018-01-11 17:23:27 -         current
2018-01-11 17:23:27 -         |> getEnd
2018-01-11 17:23:27 -         |> getScore
2018-01-11 17:23:27 -     else
2018-01-11 17:23:27 -         let newItem = addNewItem current direction
2018-01-11 17:23:27 -         let newList = newItem |> Seq.singleton |> Seq.append current
2018-01-11 17:23:27 -         
2018-01-11 17:23:27 -         getNewParams direction repeat advancement 
2018-01-11 17:23:27 -         |> (fun (newDir, newRep, newAdv) -> adventOfCode3Part2 limit newDir newRep newAdv newList)       
2018-01-11 17:23:27 -         
2018-01-11 17:23:39 - adventOfCode3Part2 25 Right 1 1 (Seq.singleton ((0,0), 1))
2018-01-11 17:23:54 - adventOfCode3Part2 100 Right 1 1 (Seq.singleton ((0,0), 1))
2018-01-11 17:24:17 - adventOfCode3Part2 277678 Right 1 1 (Seq.singleton ((0,0), 1))
2018-01-11 17:36:57 - shutdown request
2018-01-17 12:11:48 - // include directory, this will be replaced by the kernel
2018-01-17 12:11:48 - #I "C:\\Users\\misadmin\\Desktop\\F sharp notebook"
2018-01-17 12:11:48 - // load base dlls
2018-01-17 12:11:48 - #r "IfSharp.Kernel.dll"
2018-01-17 12:11:48 - #r "NetMQ.dll"
2018-01-17 12:11:48 - // open the global functions and methods
2018-01-17 12:11:48 - open IfSharp.Kernel
2018-01-17 12:11:48 - open IfSharp.Kernel.Globals
2018-01-17 12:11:55 - F# Interactive for F# 4.1
2018-01-17 12:11:55 - Freely distributed under the Apache 2.0 Open Source License
2018-01-17 12:11:55 - For help type #help;;
2018-01-17 12:11:55 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-01-17 12:11:55 -   seq []
2018-01-17 12:11:55 - --> Added 'C:\Users\misadmin\Desktop\F sharp notebook' to library include path
2018-01-17 12:11:55 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-01-17 12:11:55 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\NetMQ.dll' (file may be locked by F# Interactive process)
2018-01-17 12:11:57 - Unknown content type on shell. msg_type is `comm_info_request`
2018-01-17 12:12:17 - // include directory, this will be replaced by the kernel
2018-01-17 12:12:17 - #I "C:\\Users\\misadmin\\Desktop\\F sharp notebook"
2018-01-17 12:12:17 - // load base dlls
2018-01-17 12:12:17 - #r "IfSharp.Kernel.dll"
2018-01-17 12:12:17 - #r "NetMQ.dll"
2018-01-17 12:12:17 - // open the global functions and methods
2018-01-17 12:12:17 - open IfSharp.Kernel
2018-01-17 12:12:17 - open IfSharp.Kernel.Globals
2018-01-17 12:12:23 - F# Interactive for F# 4.1
2018-01-17 12:12:23 - Freely distributed under the Apache 2.0 Open Source License
2018-01-17 12:12:23 - For help type #help;;
2018-01-17 12:12:23 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-01-17 12:12:23 -   seq []
2018-01-17 12:12:23 - --> Added 'C:\Users\misadmin\Desktop\F sharp notebook' to library include path
2018-01-17 12:12:23 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-01-17 12:12:23 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\NetMQ.dll' (file may be locked by F# Interactive process)
2018-01-17 12:12:27 - Unknown content type on shell. msg_type is `comm_info_request`
2018-01-17 12:23:25 - // Getting the necessary libraries
2018-01-17 12:23:25 - open System.IO
2018-01-17 12:23:25 - open System
2018-01-17 12:23:25 - // Getting the raw data
2018-01-17 12:23:25 - let inputFile = "problem4.txt"
2018-01-17 12:23:25 - let parseFile = File.ReadAllLines(inputFile)
2018-01-17 12:23:25 - parseFile
2018-01-17 12:30:11 - // Getting the necessary libraries
2018-01-17 12:30:11 - open System.IO
2018-01-17 12:30:11 - open System
2018-01-17 12:30:11 - // Getting the raw data
2018-01-17 12:30:11 - let inputFile = "problem4.txt"
2018-01-17 12:30:11 - let parseFile = File.ReadAllLines(inputFile)
2018-01-17 12:30:11 - let dataList = 
2018-01-17 12:30:11 -     parseFile |> Array
2018-01-17 12:30:11 - This type has no accessible object constructors
2018-01-17 12:38:39 - Unknown content type on shell. msg_type is `comm_info_request`
2018-01-17 12:46:26 - // Getting the necessary libraries
2018-01-17 12:46:26 - open System.IO
2018-01-17 12:46:26 - open System
2018-01-17 12:46:26 - // Getting the raw data
2018-01-17 12:46:26 - let inputFile = "problem4.txt"
2018-01-17 12:46:26 - let parseFile input : string array = 
2018-01-17 12:46:26 -     File.ReadAllLines(input)
2018-01-17 12:46:26 - let dataList textArray = 
2018-01-17 12:46:26 -     textArray 
2018-01-17 12:46:26 -         |> Array.toList
2018-01-17 12:46:26 -         |> Seq.collect (fun x -> x.Split())
2018-01-17 12:46:26 - let advOfCodePart4 inputFile = 
2018-01-17 12:46:26 -     inputFile
2018-01-17 12:46:26 -         |> parseFile
2018-01-17 12:46:26 -         |> dataList 
2018-01-17 12:46:26 -         
2018-01-17 12:46:26 - advOfCodePart4 inputFile
2018-01-17 12:46:26 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-01-17 12:47:28 - // include directory, this will be replaced by the kernel
2018-01-17 12:47:28 - #I "C:\\Users\\misadmin\\Desktop\\F sharp notebook"
2018-01-17 12:47:28 - // load base dlls
2018-01-17 12:47:28 - #r "IfSharp.Kernel.dll"
2018-01-17 12:47:28 - #r "NetMQ.dll"
2018-01-17 12:47:28 - // open the global functions and methods
2018-01-17 12:47:28 - open IfSharp.Kernel
2018-01-17 12:47:28 - open IfSharp.Kernel.Globals
2018-01-17 12:47:35 - F# Interactive for F# 4.1
2018-01-17 12:47:35 - Freely distributed under the Apache 2.0 Open Source License
2018-01-17 12:47:35 - For help type #help;;
2018-01-17 12:47:35 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-01-17 12:47:35 -   seq []
2018-01-17 12:47:35 - --> Added 'C:\Users\misadmin\Desktop\F sharp notebook' to library include path
2018-01-17 12:47:35 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-01-17 12:47:35 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\NetMQ.dll' (file may be locked by F# Interactive process)
2018-01-17 12:47:37 - Unknown content type on shell. msg_type is `comm_info_request`
2018-01-17 12:47:51 - // include directory, this will be replaced by the kernel
2018-01-17 12:47:51 - #I "C:\\Users\\misadmin\\Desktop\\F sharp notebook"
2018-01-17 12:47:51 - // load base dlls
2018-01-17 12:47:51 - #r "IfSharp.Kernel.dll"
2018-01-17 12:47:51 - #r "NetMQ.dll"
2018-01-17 12:47:51 - // open the global functions and methods
2018-01-17 12:47:51 - open IfSharp.Kernel
2018-01-17 12:47:51 - open IfSharp.Kernel.Globals
2018-01-17 12:47:58 - F# Interactive for F# 4.1
2018-01-17 12:47:58 - Freely distributed under the Apache 2.0 Open Source License
2018-01-17 12:47:58 - For help type #help;;
2018-01-17 12:47:58 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2018-01-17 12:47:58 -   seq []
2018-01-17 12:47:58 - --> Added 'C:\Users\misadmin\Desktop\F sharp notebook' to library include path
2018-01-17 12:47:58 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-01-17 12:47:58 - --> Referenced 'C:\Users\misadmin\Desktop\F sharp notebook\NetMQ.dll' (file may be locked by F# Interactive process)
2018-01-17 12:48:00 - Unknown content type on shell. msg_type is `comm_info_request`
2018-01-17 12:48:23 - // Getting the necessary libraries
2018-01-17 12:48:23 - open System.IO
2018-01-17 12:48:23 - open System
2018-01-17 12:48:23 - // Getting the raw data
2018-01-17 12:48:23 - let inputFile = "problem4.txt"
2018-01-17 12:48:23 - let parseFile input : string array = 
2018-01-17 12:48:23 -     File.ReadAllLines(input)
2018-01-17 12:48:23 - let dataList textArray = 
2018-01-17 12:48:23 -     textArray 
2018-01-17 12:48:23 -         |> Array.toList
2018-01-17 12:48:23 -         |> Seq.collect (fun x -> x.Split())
2018-01-17 12:48:23 - let advOfCodePart4 (inputFile: string) : string List = 
2018-01-17 12:48:23 -     inputFile
2018-01-17 12:48:23 -         |> parseFile
2018-01-17 12:48:23 -         |> dataList 
2018-01-17 12:48:23 -         
2018-01-17 12:48:23 - advOfCodePart4 inputFile
2018-01-17 12:48:23 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-01-17 12:48:23 - Type mismatch. Expecting a
2018-01-17 12:48:23 -     'string array -> List<string>'    
2018-01-17 12:48:23 - but given a
2018-01-17 12:48:23 -     'string [] -> seq<obj>'    
2018-01-17 12:48:23 - The type 'List<string>' does not match the type 'seq<obj>'
2018-01-17 12:49:04 - // Getting the necessary libraries
2018-01-17 12:49:04 - open System.IO
2018-01-17 12:49:04 - open System
2018-01-17 12:49:04 - // Getting the raw data
2018-01-17 12:49:04 - let inputFile = "problem4.txt"
2018-01-17 12:49:04 - let parseFile input : string array = 
2018-01-17 12:49:04 -     File.ReadAllLines(input)
2018-01-17 12:49:04 - let dataList textArray = 
2018-01-17 12:49:04 -     textArray 
2018-01-17 12:49:04 -         |> Array.toList
2018-01-17 12:49:04 -         |> Seq.collect (fun x -> x.Split())
2018-01-17 12:49:04 - let advOfCodePart4 (inputFile: string) : string [] = 
2018-01-17 12:49:04 -     inputFile
2018-01-17 12:49:04 -         |> parseFile
2018-01-17 12:49:04 -         |> dataList 
2018-01-17 12:49:04 -         
2018-01-17 12:49:04 - advOfCodePart4 inputFile
2018-01-17 12:49:04 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-01-17 12:49:04 - Type mismatch. Expecting a
2018-01-17 12:49:04 -     'string array -> string []'    
2018-01-17 12:49:04 - but given a
2018-01-17 12:49:04 -     'string [] -> seq<obj>'    
2018-01-17 12:49:04 - The type 'string []' does not match the type 'seq<obj>'
2018-01-17 12:52:08 - // Getting the necessary libraries
2018-01-17 12:52:08 - open System.IO
2018-01-17 12:52:08 - open System
2018-01-17 12:52:08 - // Getting the raw data
2018-01-17 12:52:08 - let inputFile = "problem4.txt"
2018-01-17 12:52:08 - let parseFile input = 
2018-01-17 12:52:08 -     File.ReadAllLines(input)
2018-01-17 12:52:08 - let dataList textArray = 
2018-01-17 12:52:08 -     textArray 
2018-01-17 12:52:08 -         |> Array.toList
2018-01-17 12:52:08 -         |> Seq.collect (fun x -> x.Split())
2018-01-17 12:52:08 - let advOfCodePart4 (inputFile: string) : string [] = 
2018-01-17 12:52:08 -     inputFile
2018-01-17 12:52:08 -         |> parseFile
2018-01-17 12:52:08 -         |> dataList 
2018-01-17 12:52:08 -         
2018-01-17 12:52:08 - let thing = parseFile inputFile
2018-01-17 12:52:08 - thing.GetType()
2018-01-17 12:52:08 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-01-17 12:52:08 - Type mismatch. Expecting a
2018-01-17 12:52:08 -     'string [] -> string []'    
2018-01-17 12:52:08 - but given a
2018-01-17 12:52:08 -     'string [] -> seq<obj>'    
2018-01-17 12:52:08 - The type 'string []' does not match the type 'seq<obj>'
2018-01-17 12:52:09 - // Getting the necessary libraries
2018-01-17 12:52:09 - open System.IO
2018-01-17 12:52:09 - open System
2018-01-17 12:52:09 - // Getting the raw data
2018-01-17 12:52:09 - let inputFile = "problem4.txt"
2018-01-17 12:52:09 - let parseFile input = 
2018-01-17 12:52:09 -     File.ReadAllLines(input)
2018-01-17 12:52:09 - let dataList textArray = 
2018-01-17 12:52:09 -     textArray 
2018-01-17 12:52:09 -         |> Array.toList
2018-01-17 12:52:09 -         |> Seq.collect (fun x -> x.Split())
2018-01-17 12:52:09 - let advOfCodePart4 (inputFile: string) : string [] = 
2018-01-17 12:52:09 -     inputFile
2018-01-17 12:52:09 -         |> parseFile
2018-01-17 12:52:09 -         |> dataList 
2018-01-17 12:52:09 -         
2018-01-17 12:52:09 - let thing = parseFile inputFile
2018-01-17 12:52:09 - thing.GetType()
2018-01-17 12:52:09 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-01-17 12:52:09 - Type mismatch. Expecting a
2018-01-17 12:52:09 -     'string [] -> string []'    
2018-01-17 12:52:09 - but given a
2018-01-17 12:52:09 -     'string [] -> seq<obj>'    
2018-01-17 12:52:09 - The type 'string []' does not match the type 'seq<obj>'
2018-01-17 12:52:16 - // Getting the necessary libraries
2018-01-17 12:52:16 - open System.IO
2018-01-17 12:52:16 - open System
2018-01-17 12:52:16 - // Getting the raw data
2018-01-17 12:52:16 - let inputFile = "problem4.txt"
2018-01-17 12:52:16 - let parseFile input = 
2018-01-17 12:52:16 -     File.ReadAllLines(input)
2018-01-17 12:52:16 - // let dataList textArray = 
2018-01-17 12:52:16 - //     textArray 
2018-01-17 12:52:16 - //         |> Array.toList
2018-01-17 12:52:16 - //         |> Seq.collect (fun x -> x.Split())
2018-01-17 12:52:16 - // let advOfCodePart4 (inputFile: string) : string [] = 
2018-01-17 12:52:16 - //     inputFile
2018-01-17 12:52:16 - //         |> parseFile
2018-01-17 12:52:16 - //         |> dataList 
2018-01-17 12:52:16 -         
2018-01-17 12:52:16 - let thing = parseFile inputFile
2018-01-17 12:52:16 - thing.GetType()
2018-01-17 12:52:57 - // Getting the necessary libraries
2018-01-17 12:52:57 - open System.IO
2018-01-17 12:52:57 - open System
2018-01-17 12:52:57 - // Getting the raw data
2018-01-17 12:52:57 - let inputFile = "problem4.txt"
2018-01-17 12:52:57 - let parseFile input = 
2018-01-17 12:52:57 -     File.ReadAllLines(input)
2018-01-17 12:52:57 - let dataList (textArray: String[]) = 
2018-01-17 12:52:57 -     textArray 
2018-01-17 12:52:57 -         |> Array.toList
2018-01-17 12:52:57 -         |> Seq.collect (fun x -> x.Split())
2018-01-17 12:52:57 - // let advOfCodePart4 (inputFile: string) : string [] = 
2018-01-17 12:52:57 - //     inputFile
2018-01-17 12:52:57 - //         |> parseFile
2018-01-17 12:52:57 - //         |> dataList 
2018-01-17 12:52:57 -         
2018-01-17 12:52:57 - let thing = parseFile inputFile
2018-01-17 12:52:57 - thing.GetType()
2018-01-17 12:53:26 - // Getting the necessary libraries
2018-01-17 12:53:26 - open System.IO
2018-01-17 12:53:26 - open System
2018-01-17 12:53:26 - // Getting the raw data
2018-01-17 12:53:26 - let inputFile = "problem4.txt"
2018-01-17 12:53:26 - let parseFile input = 
2018-01-17 12:53:26 -     File.ReadAllLines(input)
2018-01-17 12:53:26 - let dataList (textArray: String[]) = 
2018-01-17 12:53:26 -     textArray 
2018-01-17 12:53:26 -         |> Array.toList
2018-01-17 12:53:26 -         |> Seq.collect (fun x -> x.Split())
2018-01-17 12:53:26 - // let advOfCodePart4 (inputFile: string) : string [] = 
2018-01-17 12:53:26 - //     inputFile
2018-01-17 12:53:26 - //         |> parseFile
2018-01-17 12:53:26 - //         |> dataList 
2018-01-17 12:53:26 -         
2018-01-17 12:53:26 - let thing = inputFile |> parseFile |> dataList
2018-01-17 12:53:26 - thing.GetType()
2018-01-17 12:53:35 - // Getting the necessary libraries
2018-01-17 12:53:35 - open System.IO
2018-01-17 12:53:35 - open System
2018-01-17 12:53:35 - // Getting the raw data
2018-01-17 12:53:35 - let inputFile = "problem4.txt"
2018-01-17 12:53:35 - let parseFile input = 
2018-01-17 12:53:35 -     File.ReadAllLines(input)
2018-01-17 12:53:35 - let dataList (textArray: String[]) = 
2018-01-17 12:53:35 -     textArray 
2018-01-17 12:53:35 -         |> Array.toList
2018-01-17 12:53:35 -         |> Seq.collect (fun x -> x.Split())
2018-01-17 12:53:35 - // let advOfCodePart4 (inputFile: string) : string [] = 
2018-01-17 12:53:35 - //     inputFile
2018-01-17 12:53:35 - //         |> parseFile
2018-01-17 12:53:35 - //         |> dataList 
2018-01-17 12:53:35 -         
2018-01-17 12:53:35 - let thing = inputFile |> parseFile |> dataList
2018-01-17 12:53:35 - thing.GetType()
2018-01-17 12:53:46 - // Getting the necessary libraries
2018-01-17 12:53:46 - open System.IO
2018-01-17 12:53:46 - open System
2018-01-17 12:53:46 - // Getting the raw data
2018-01-17 12:53:46 - let inputFile = "problem4.txt"
2018-01-17 12:53:46 - let parseFile input = 
2018-01-17 12:53:46 -     File.ReadAllLines(input)
2018-01-17 12:53:46 - let dataList (textArray: String[]) = 
2018-01-17 12:53:46 -     textArray 
2018-01-17 12:53:46 -         |> Array.toList
2018-01-17 12:53:46 -         |> Seq.collect (fun x -> x.Split())
2018-01-17 12:53:46 -         |> Seq.toList
2018-01-17 12:53:46 - // let advOfCodePart4 (inputFile: string) : string [] = 
2018-01-17 12:53:46 - //     inputFile
2018-01-17 12:53:46 - //         |> parseFile
2018-01-17 12:53:46 - //         |> dataList 
2018-01-17 12:53:46 -         
2018-01-17 12:53:46 - let thing = inputFile |> parseFile |> dataList
2018-01-17 12:53:46 - thing.GetType()
2018-01-17 12:54:08 - // Getting the necessary libraries
2018-01-17 12:54:08 - open System.IO
2018-01-17 12:54:08 - open System
2018-01-17 12:54:08 - // Getting the raw data
2018-01-17 12:54:08 - let inputFile = "problem4.txt"
2018-01-17 12:54:08 - let parseFile input = 
2018-01-17 12:54:08 -     File.ReadAllLines(input)
2018-01-17 12:54:08 - let dataList (textArray: String[]) = 
2018-01-17 12:54:08 -     textArray 
2018-01-17 12:54:08 -         |> Array.toList
2018-01-17 12:54:08 -         |> Seq.collect (fun x -> x.Split())
2018-01-17 12:54:08 - // let advOfCodePart4 (inputFile: string) : string [] = 
2018-01-17 12:54:08 - //     inputFile
2018-01-17 12:54:08 - //         |> parseFile
2018-01-17 12:54:08 - //         |> dataList 
2018-01-17 12:54:08 -         
2018-01-17 12:54:08 - let thing = inputFile |> parseFile |> dataList
2018-01-17 12:54:08 - thing.GetType()
2018-01-17 14:58:38 - Unknown content type on shell. msg_type is `comm_info_request`
2018-01-17 15:02:03 - // Getting the necessary libraries
2018-01-17 15:02:03 - open System.IO
2018-01-17 15:02:03 - open System
2018-01-17 15:02:03 - // Getting the raw data
2018-01-17 15:02:03 - let inputFile = "problem4.txt"
2018-01-17 15:02:03 - let parseFile input = 
2018-01-17 15:02:03 -     File.ReadAllText(input)
2018-01-17 15:02:03 -     |> .Split(' ')
2018-01-17 15:02:03 -     
2018-01-17 15:02:03 - // let advOfCodePart4 (inputFile: string) : string [] = 
2018-01-17 15:02:03 - //     inputFile
2018-01-17 15:02:03 - //         |> parseFile
2018-01-17 15:02:03 - //         |> dataList 
2018-01-17 15:02:03 -         
2018-01-17 15:02:03 - let thing = inputFile |> parseFile 
2018-01-17 15:02:03 - thing.GetType()
2018-01-17 15:02:03 - Unexpected symbol '.' in expression
2018-01-17 15:02:21 - // Getting the necessary libraries
2018-01-17 15:02:21 - open System.IO
2018-01-17 15:02:21 - open System
2018-01-17 15:02:21 - // Getting the raw data
2018-01-17 15:02:21 - let inputFile = "problem4.txt"
2018-01-17 15:02:21 - let parseFile input = 
2018-01-17 15:02:21 -     File.ReadAllText(input)
2018-01-17 15:02:21 -     |> fun x ->  x.Split(' ')
2018-01-17 15:02:21 -     
2018-01-17 15:02:21 - // let advOfCodePart4 (inputFile: string) : string [] = 
2018-01-17 15:02:21 - //     inputFile
2018-01-17 15:02:21 - //         |> parseFile
2018-01-17 15:02:21 - //         |> dataList 
2018-01-17 15:02:21 -         
2018-01-17 15:02:21 - let thing = inputFile |> parseFile 
2018-01-17 15:02:21 - thing.GetType()
2018-01-17 15:02:30 - // Getting the necessary libraries
2018-01-17 15:02:30 - open System.IO
2018-01-17 15:02:30 - open System
2018-01-17 15:02:30 - // Getting the raw data
2018-01-17 15:02:30 - let inputFile = "problem4.txt"
2018-01-17 15:02:30 - let parseFile input = 
2018-01-17 15:02:30 -     File.ReadAllText(input)
2018-01-17 15:02:30 -     |> fun x ->  x.Split(' ')
2018-01-17 15:02:30 -     
2018-01-17 15:02:30 - // let advOfCodePart4 (inputFile: string) : string [] = 
2018-01-17 15:02:30 - //     inputFile
2018-01-17 15:02:30 - //         |> parseFile
2018-01-17 15:02:30 - //         |> dataList 
2018-01-17 15:02:30 -         
2018-01-17 15:02:30 - let thing = inputFile |> parseFile 
2018-01-17 15:02:30 - thing
2018-01-17 15:02:46 - // Getting the necessary libraries
2018-01-17 15:02:46 - open System.IO
2018-01-17 15:02:46 - open System
2018-01-17 15:02:46 - // Getting the raw data
2018-01-17 15:02:46 - let inputFile = "problem4.txt"
2018-01-17 15:02:46 - let parseFile input = 
2018-01-17 15:02:46 -     File.ReadAllText(input)
2018-01-17 15:02:46 -     |> fun x ->  x.Split(' ')
2018-01-17 15:02:46 -     
2018-01-17 15:02:46 - // let advOfCodePart4 (inputFile: string) : string [] = 
2018-01-17 15:02:46 - //     inputFile
2018-01-17 15:02:46 - //         |> parseFile
2018-01-17 15:02:46 - //         |> dataList 
2018-01-17 15:02:46 -         
2018-01-17 15:02:46 - let thing = inputFile |> parseFile 
2018-01-17 15:02:46 - thing.GetType()
2018-01-17 15:07:22 - // Getting the necessary libraries
2018-01-17 15:07:22 - open System.IO
2018-01-17 15:07:22 - open System
2018-01-17 15:07:22 - // Getting the raw data
2018-01-17 15:07:22 - let inputFile = "problem4.txt"
2018-01-17 15:07:22 - let parseFile input = 
2018-01-17 15:07:22 -     File.ReadAllText(input)
2018-01-17 15:07:22 -     |> fun x ->  x.Split(' ')
2018-01-17 15:07:22 -     
2018-01-17 15:07:22 - let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:07:22 -     let initialData = 
2018-01-17 15:07:22 -     inputFile
2018-01-17 15:07:22 -         |> parseFile
2018-01-17 15:07:22 -     
2018-01-17 15:07:22 -     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:07:22 -     
2018-01-17 15:07:22 -     len(initialData) = len(noDuplicates)
2018-01-17 15:07:22 -         
2018-01-17 15:07:22 - let thing = inputFile |> parseFile 
2018-01-17 15:07:22 - thing.GetType()
2018-01-17 15:07:22 - Possible incorrect indentation: this token is offside of context started at position (18:5). Try indenting this token further or using standard formatting conventions.
2018-01-17 15:07:22 - Possible incorrect indentation: this token is offside of context started at position (18:5). Try indenting this token further or using standard formatting conventions.
2018-01-17 15:07:22 - Possible incorrect indentation: this token is offside of context started at position (18:5). Try indenting this token further or using standard formatting conventions.
2018-01-17 15:07:22 - Possible incorrect indentation: this token is offside of context started at position (18:5). Try indenting this token further or using standard formatting conventions.
2018-01-17 15:07:22 - Possible incorrect indentation: this token is offside of context started at position (18:5). Try indenting this token further or using standard formatting conventions.
2018-01-17 15:07:22 - Possible incorrect indentation: this token is offside of context started at position (18:5). Try indenting this token further or using standard formatting conventions.
2018-01-17 15:07:22 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2018-01-17 15:07:36 - // Getting the necessary libraries
2018-01-17 15:07:36 - open System.IO
2018-01-17 15:07:36 - open System
2018-01-17 15:07:36 - // Getting the raw data
2018-01-17 15:07:36 - let inputFile = "problem4.txt"
2018-01-17 15:07:36 - let parseFile input = 
2018-01-17 15:07:36 -     File.ReadAllText(input)
2018-01-17 15:07:36 -     |> fun x ->  x.Split(' ')
2018-01-17 15:07:36 -     
2018-01-17 15:07:36 - let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:07:36 -     let initialData = 
2018-01-17 15:07:36 -         inputFile
2018-01-17 15:07:36 -             |> parseFile
2018-01-17 15:07:36 -     
2018-01-17 15:07:36 -     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:07:36 -     
2018-01-17 15:07:36 -     len(initialData) = len(noDuplicates)
2018-01-17 15:07:36 -         
2018-01-17 15:07:36 - let thing = inputFile |> parseFile 
2018-01-17 15:07:36 - thing.GetType()
2018-01-17 15:07:36 - The value or constructor 'len' is not defined.
2018-01-17 15:07:36 - The value or constructor 'len' is not defined.
2018-01-17 15:08:16 - // Getting the necessary libraries
2018-01-17 15:08:16 - open System.IO
2018-01-17 15:08:16 - open System
2018-01-17 15:08:16 - // Getting the raw data
2018-01-17 15:08:16 - let inputFile = "problem4.txt"
2018-01-17 15:08:16 - let parseFile input = 
2018-01-17 15:08:16 -     File.ReadAllText(input)
2018-01-17 15:08:16 -     |> fun x ->  x.Split(' ')
2018-01-17 15:08:16 -     
2018-01-17 15:08:16 - let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:08:16 -     let initialData = 
2018-01-17 15:08:16 -         inputFile
2018-01-17 15:08:16 -             |> parseFile
2018-01-17 15:08:16 -     
2018-01-17 15:08:16 -     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:08:16 -     
2018-01-17 15:08:16 -     (Seq.length initialData) = (Seq.length noDuplicates)
2018-01-17 15:08:16 -         
2018-01-17 15:08:16 - let thing = inputFile |> parseFile 
2018-01-17 15:08:16 - thing.GetType()
2018-01-17 15:08:33 - // Getting the necessary libraries
2018-01-17 15:08:33 - open System.IO
2018-01-17 15:08:33 - open System
2018-01-17 15:08:33 - // Getting the raw data
2018-01-17 15:08:33 - let inputFile = "problem4.txt"
2018-01-17 15:08:33 - let parseFile input = 
2018-01-17 15:08:33 -     File.ReadAllText(input)
2018-01-17 15:08:33 -     |> fun x ->  x.Split(' ')
2018-01-17 15:08:33 -     
2018-01-17 15:08:33 - let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:08:33 -     let initialData = 
2018-01-17 15:08:33 -         inputFile
2018-01-17 15:08:33 -             |> parseFile
2018-01-17 15:08:33 -     
2018-01-17 15:08:33 -     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:08:33 -     
2018-01-17 15:08:33 -     (Seq.length initialData) = (Seq.length noDuplicates)
2018-01-17 15:08:33 -         
2018-01-17 15:08:33 - adventofCodePart4 inputFile
2018-01-17 15:08:34 - The value or constructor 'adventofCodePart4' is not defined. Maybe you want one of the following:
2018-01-17 15:08:34 -    advOfCodePart4
2018-01-17 15:08:40 - // Getting the necessary libraries
2018-01-17 15:08:40 - open System.IO
2018-01-17 15:08:40 - open System
2018-01-17 15:08:40 - // Getting the raw data
2018-01-17 15:08:40 - let inputFile = "problem4.txt"
2018-01-17 15:08:40 - let parseFile input = 
2018-01-17 15:08:40 -     File.ReadAllText(input)
2018-01-17 15:08:40 -     |> fun x ->  x.Split(' ')
2018-01-17 15:08:40 -     
2018-01-17 15:08:40 - let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:08:40 -     let initialData = 
2018-01-17 15:08:40 -         inputFile
2018-01-17 15:08:40 -             |> parseFile
2018-01-17 15:08:40 -     
2018-01-17 15:08:40 -     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:08:40 -     
2018-01-17 15:08:40 -     (Seq.length initialData) = (Seq.length noDuplicates)
2018-01-17 15:08:40 -         
2018-01-17 15:08:40 - advOfCodePart4 inputFile
2018-01-17 15:13:11 - // Getting the necessary libraries
2018-01-17 15:13:11 - open System.IO
2018-01-17 15:13:11 - open System
2018-01-17 15:13:11 - // Getting the raw data
2018-01-17 15:13:11 - let inputFile = "problem4.txt"
2018-01-17 15:13:11 - // let parseFile input = 
2018-01-17 15:13:11 - //     File.ReadAllText(input)
2018-01-17 15:13:11 - //     |> fun x ->  x.Split(' ')
2018-01-17 15:13:11 - let parseFile (input: string) : string[] = 
2018-01-17 15:13:11 -     File.ReadAllLines(input)
2018-01-17 15:13:11 -     
2018-01-17 15:13:11 - let duplicates (original: string[]) = None
2018-01-17 15:13:11 -     
2018-01-17 15:13:11 - // let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:13:11 - //     let initialData = 
2018-01-17 15:13:11 - //         inputFile
2018-01-17 15:13:11 - //             |> parseFile
2018-01-17 15:13:11 -     
2018-01-17 15:13:11 - //     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:13:11 -     
2018-01-17 15:13:11 - //     (Seq.length initialData) = (Seq.length noDuplicates)
2018-01-17 15:13:11 -         
2018-01-17 15:13:11 - let thing = inputFile |> parseFile
2018-01-17 15:13:18 - // Getting the necessary libraries
2018-01-17 15:13:18 - open System.IO
2018-01-17 15:13:18 - open System
2018-01-17 15:13:18 - // Getting the raw data
2018-01-17 15:13:18 - let inputFile = "problem4.txt"
2018-01-17 15:13:18 - // let parseFile input = 
2018-01-17 15:13:18 - //     File.ReadAllText(input)
2018-01-17 15:13:18 - //     |> fun x ->  x.Split(' ')
2018-01-17 15:13:18 - let parseFile (input: string) : string[] = 
2018-01-17 15:13:18 -     File.ReadAllLines(input)
2018-01-17 15:13:18 -     
2018-01-17 15:13:18 - let duplicates (original: string[]) = None
2018-01-17 15:13:18 -     
2018-01-17 15:13:18 - // let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:13:18 - //     let initialData = 
2018-01-17 15:13:18 - //         inputFile
2018-01-17 15:13:18 - //             |> parseFile
2018-01-17 15:13:18 -     
2018-01-17 15:13:18 - //     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:13:18 -     
2018-01-17 15:13:18 - //     (Seq.length initialData) = (Seq.length noDuplicates)
2018-01-17 15:13:18 -         
2018-01-17 15:13:18 - let thing = inputFile |> parseFile
2018-01-17 15:13:18 - thing
2018-01-17 15:20:42 - // Getting the necessary libraries
2018-01-17 15:20:42 - open System.IO
2018-01-17 15:20:42 - open System
2018-01-17 15:20:42 - // Getting the raw data
2018-01-17 15:20:42 - let inputFile = "problem4.txt"
2018-01-17 15:20:42 - // let parseFile input = 
2018-01-17 15:20:42 - //     File.ReadAllText(input)
2018-01-17 15:20:42 - //     |> fun x ->  x.Split(' ')
2018-01-17 15:20:42 - let parseFile (input: string) : string[] = 
2018-01-17 15:20:42 -     File.ReadAllLines(input)
2018-01-17 15:20:42 -     |> Array.map (fun x -> x.Split(' ')
2018-01-17 15:20:42 -     
2018-01-17 15:20:42 - let duplicates (original: string[]) = None
2018-01-17 15:20:42 -     
2018-01-17 15:20:42 - // let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:20:42 - //     let initialData = 
2018-01-17 15:20:42 - //         inputFile
2018-01-17 15:20:42 - //             |> parseFile
2018-01-17 15:20:42 -     
2018-01-17 15:20:42 - //     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:20:42 -     
2018-01-17 15:20:42 - //     (Seq.length initialData) = (Seq.length noDuplicates)
2018-01-17 15:20:42 -         
2018-01-17 15:20:42 - let thing = inputFile |> parseFile
2018-01-17 15:20:42 - thing
2018-01-17 15:20:42 - Possible incorrect indentation: this token is offside of context started at position (16:5). Try indenting this token further or using standard formatting conventions.
2018-01-17 15:20:42 - Unexpected keyword 'let' or 'use' in expression
2018-01-17 15:20:42 - Possible incorrect indentation: this token is offside of context started at position (20:1). Try indenting this token further or using standard formatting conventions.
2018-01-17 15:20:42 - Unexpected keyword 'let' or 'use' in binding. Expected incomplete structured construct at or before this point or other token.
2018-01-17 15:20:42 - Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword.
2018-01-17 15:20:42 - Unexpected identifier in interaction. Expected incomplete structured construct at or before this point, ';', ';;' or other token.
2018-01-17 15:20:42 - parse error
2018-01-17 15:21:00 - // Getting the necessary libraries
2018-01-17 15:21:00 - open System.IO
2018-01-17 15:21:00 - open System
2018-01-17 15:21:00 - // Getting the raw data
2018-01-17 15:21:00 - let inputFile = "problem4.txt"
2018-01-17 15:21:00 - // let parseFile input = 
2018-01-17 15:21:00 - //     File.ReadAllText(input)
2018-01-17 15:21:00 - //     |> fun x ->  x.Split(' ')
2018-01-17 15:21:00 - let parseFile (input: string) : string[] = 
2018-01-17 15:21:00 -     File.ReadAllLines(input)
2018-01-17 15:21:00 -         |> Array.map (fun x -> x.Split(' '))
2018-01-17 15:21:00 -     
2018-01-17 15:21:00 - let duplicates (original: string[]) = None
2018-01-17 15:21:00 -     
2018-01-17 15:21:00 - // let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:21:00 - //     let initialData = 
2018-01-17 15:21:00 - //         inputFile
2018-01-17 15:21:00 - //             |> parseFile
2018-01-17 15:21:00 -     
2018-01-17 15:21:00 - //     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:21:00 -     
2018-01-17 15:21:00 - //     (Seq.length initialData) = (Seq.length noDuplicates)
2018-01-17 15:21:00 -         
2018-01-17 15:21:00 - let thing = inputFile |> parseFile
2018-01-17 15:21:00 - thing
2018-01-17 15:21:00 - This expression was expected to have type
2018-01-17 15:21:00 -     'string'    
2018-01-17 15:21:00 - but here has type
2018-01-17 15:21:00 -     'string []'    
2018-01-17 15:21:28 - // Getting the necessary libraries
2018-01-17 15:21:28 - open System.IO
2018-01-17 15:21:28 - open System
2018-01-17 15:21:28 - // Getting the raw data
2018-01-17 15:21:28 - let inputFile = "problem4.txt"
2018-01-17 15:21:28 - // let parseFile input = 
2018-01-17 15:21:28 - //     File.ReadAllText(input)
2018-01-17 15:21:28 - //     |> fun x ->  x.Split(' ')
2018-01-17 15:21:28 - let parseFile (input: string) : string[] = 
2018-01-17 15:21:28 -     File.ReadAllLines(input)
2018-01-17 15:21:28 -         |> Array.map (fun x -> x)
2018-01-17 15:21:28 -     
2018-01-17 15:21:28 - let duplicates (original: string[]) = None
2018-01-17 15:21:28 -     
2018-01-17 15:21:28 - // let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:21:28 - //     let initialData = 
2018-01-17 15:21:28 - //         inputFile
2018-01-17 15:21:28 - //             |> parseFile
2018-01-17 15:21:28 -     
2018-01-17 15:21:28 - //     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:21:28 -     
2018-01-17 15:21:28 - //     (Seq.length initialData) = (Seq.length noDuplicates)
2018-01-17 15:21:28 -         
2018-01-17 15:21:28 - let thing = inputFile |> parseFile
2018-01-17 15:21:28 - thing
2018-01-17 15:22:05 - // Getting the necessary libraries
2018-01-17 15:22:05 - open System.IO
2018-01-17 15:22:05 - open System
2018-01-17 15:22:05 - // Getting the raw data
2018-01-17 15:22:05 - let inputFile = "problem4.txt"
2018-01-17 15:22:05 - // let parseFile input = 
2018-01-17 15:22:05 - //     File.ReadAllText(input)
2018-01-17 15:22:05 - //     |> fun x ->  x.Split(' ')
2018-01-17 15:22:05 - let parseFile (input: string) : string[] = 
2018-01-17 15:22:05 -     File.ReadAllLines(input)
2018-01-17 15:22:05 -         |> Array.map (fun x -> x)
2018-01-17 15:22:05 -     
2018-01-17 15:22:05 - let duplicates (original: string[]) = None
2018-01-17 15:22:05 -     
2018-01-17 15:22:05 - // let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:22:05 - //     let initialData = 
2018-01-17 15:22:05 - //         inputFile
2018-01-17 15:22:05 - //             |> parseFile
2018-01-17 15:22:05 -     
2018-01-17 15:22:05 - //     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:22:05 -     
2018-01-17 15:22:05 - //     (Seq.length initialData) = (Seq.length noDuplicates)
2018-01-17 15:22:05 -         
2018-01-17 15:22:05 - let thing = inputFile |> parseFile
2018-01-17 15:22:05 - thing.GetType(), thing
2018-01-17 15:22:31 - // Getting the necessary libraries
2018-01-17 15:22:31 - open System.IO
2018-01-17 15:22:31 - open System
2018-01-17 15:22:31 - // Getting the raw data
2018-01-17 15:22:31 - let inputFile = "problem4.txt"
2018-01-17 15:22:31 - // let parseFile input = 
2018-01-17 15:22:31 - //     File.ReadAllText(input)
2018-01-17 15:22:31 - //     |> fun x ->  x.Split(' ')
2018-01-17 15:22:31 - let parseFile (input: string) : string[] = 
2018-01-17 15:22:31 -     File.ReadAllLines(input)
2018-01-17 15:22:31 -         |> Seqap (fun x -> x)
2018-01-17 15:22:31 -     
2018-01-17 15:22:31 - let duplicates (original: string[]) = None
2018-01-17 15:22:31 -     
2018-01-17 15:22:31 - // let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:22:31 - //     let initialData = 
2018-01-17 15:22:31 - //         inputFile
2018-01-17 15:22:31 - //             |> parseFile
2018-01-17 15:22:31 -     
2018-01-17 15:22:31 - //     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:22:31 -     
2018-01-17 15:22:31 - //     (Seq.length initialData) = (Seq.length noDuplicates)
2018-01-17 15:22:31 -         
2018-01-17 15:22:31 - let thing = inputFile |> parseFile
2018-01-17 15:22:31 - thing.GetType(), thing
2018-01-17 15:22:31 - The value or constructor 'Seqap' is not defined. Maybe you want one of the following:
2018-01-17 15:22:31 -    Seq
2018-01-17 15:22:31 -    seq
2018-01-17 15:22:48 - // Getting the necessary libraries
2018-01-17 15:22:48 - open System.IO
2018-01-17 15:22:48 - open System
2018-01-17 15:22:48 - // Getting the raw data
2018-01-17 15:22:48 - let inputFile = "problem4.txt"
2018-01-17 15:22:48 - // let parseFile input = 
2018-01-17 15:22:48 - //     File.ReadAllText(input)
2018-01-17 15:22:48 - //     |> fun x ->  x.Split(' ')
2018-01-17 15:22:48 - let parseFile (input: string) : string[] = 
2018-01-17 15:22:48 -     File.ReadAllLines(input)
2018-01-17 15:22:48 -         |> Seq.map (fun x -> x)
2018-01-17 15:22:48 -     
2018-01-17 15:22:48 - let duplicates (original: string[]) = None
2018-01-17 15:22:48 -     
2018-01-17 15:22:48 - // let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:22:48 - //     let initialData = 
2018-01-17 15:22:48 - //         inputFile
2018-01-17 15:22:48 - //             |> parseFile
2018-01-17 15:22:48 -     
2018-01-17 15:22:48 - //     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:22:48 -     
2018-01-17 15:22:48 - //     (Seq.length initialData) = (Seq.length noDuplicates)
2018-01-17 15:22:48 -         
2018-01-17 15:22:48 - let thing = inputFile |> parseFile
2018-01-17 15:22:48 - thing.GetType(), thing
2018-01-17 15:22:48 - Type mismatch. Expecting a
2018-01-17 15:22:48 -     'string [] -> string []'    
2018-01-17 15:22:48 - but given a
2018-01-17 15:22:48 -     'string [] -> seq<string>'    
2018-01-17 15:22:48 - The type 'string []' does not match the type 'seq<string>'
2018-01-17 15:22:48 - Type mismatch. Expecting a
2018-01-17 15:22:48 -     'string [] -> string []'    
2018-01-17 15:22:48 - but given a
2018-01-17 15:22:48 -     'string [] -> seq<string>'    
2018-01-17 15:22:48 - The type 'string []' does not match the type 'seq<string>'
2018-01-17 15:25:26 - // Getting the necessary libraries
2018-01-17 15:25:26 - open System.IO
2018-01-17 15:25:26 - open System
2018-01-17 15:25:26 - // Getting the raw data
2018-01-17 15:25:26 - let inputFile = "problem4.txt"
2018-01-17 15:25:26 - // let parseFile input = 
2018-01-17 15:25:26 - //     File.ReadAllText(input)
2018-01-17 15:25:26 - //     |> fun x ->  x.Split(' ')
2018-01-17 15:25:26 - let parseFile (input: string) : string[] = 
2018-01-17 15:25:26 -     File.ReadAllLines(input)
2018-01-17 15:25:26 -         |> Array.toSeq
2018-01-17 15:25:26 -     
2018-01-17 15:25:26 -     
2018-01-17 15:25:26 -         
2018-01-17 15:25:26 -     
2018-01-17 15:25:26 - let duplicates (original: string[]) = None
2018-01-17 15:25:26 -     
2018-01-17 15:25:26 - // let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:25:26 - //     let initialData = 
2018-01-17 15:25:26 - //         inputFile
2018-01-17 15:25:26 - //             |> parseFile
2018-01-17 15:25:26 -     
2018-01-17 15:25:26 - //     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:25:26 -     
2018-01-17 15:25:26 - //     (Seq.length initialData) = (Seq.length noDuplicates)
2018-01-17 15:25:26 -         
2018-01-17 15:25:26 - let thing = inputFile |> parseFile
2018-01-17 15:25:26 - thing.GetType(), thing
2018-01-17 15:25:26 - Type mismatch. Expecting a
2018-01-17 15:25:26 -     'string [] -> string []'    
2018-01-17 15:25:26 - but given a
2018-01-17 15:25:26 -     'string [] -> seq<string>'    
2018-01-17 15:25:26 - The type 'string []' does not match the type 'seq<string>'
2018-01-17 15:25:35 - // Getting the necessary libraries
2018-01-17 15:25:35 - open System.IO
2018-01-17 15:25:35 - open System
2018-01-17 15:25:35 - // Getting the raw data
2018-01-17 15:25:35 - let inputFile = "problem4.txt"
2018-01-17 15:25:35 - // let parseFile input = 
2018-01-17 15:25:35 - //     File.ReadAllText(input)
2018-01-17 15:25:35 - //     |> fun x ->  x.Split(' ')
2018-01-17 15:25:35 - let parseFile (input: string) : string[] = 
2018-01-17 15:25:35 -     File.ReadAllLines(input)
2018-01-17 15:25:35 -         |> Array.toSeq
2018-01-17 15:25:35 -     
2018-01-17 15:25:35 -     
2018-01-17 15:25:35 -         
2018-01-17 15:25:35 -     
2018-01-17 15:25:35 - let duplicates (original: string[]) = None
2018-01-17 15:25:35 -     
2018-01-17 15:25:35 - // let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:25:35 - //     let initialData = 
2018-01-17 15:25:35 - //         inputFile
2018-01-17 15:25:35 - //             |> parseFile
2018-01-17 15:25:35 -     
2018-01-17 15:25:35 - //     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:25:35 -     
2018-01-17 15:25:35 - //     (Seq.length initialData) = (Seq.length noDuplicates)
2018-01-17 15:25:35 -         
2018-01-17 15:25:35 - let thing = inputFile |> parseFile
2018-01-17 15:25:35 - thing.GetType(), thing
2018-01-17 15:25:35 - Type mismatch. Expecting a
2018-01-17 15:25:35 -     'string [] -> string []'    
2018-01-17 15:25:35 - but given a
2018-01-17 15:25:35 -     'string [] -> seq<string>'    
2018-01-17 15:25:35 - The type 'string []' does not match the type 'seq<string>'
2018-01-17 15:26:37 - // Getting the necessary libraries
2018-01-17 15:26:37 - open System.IO
2018-01-17 15:26:37 - open System
2018-01-17 15:26:37 - // Getting the raw data
2018-01-17 15:26:37 - let inputFile = "problem4.txt"
2018-01-17 15:26:37 - // let parseFile input = 
2018-01-17 15:26:37 - //     File.ReadAllText(input)
2018-01-17 15:26:37 - //     |> fun x ->  x.Split(' ')
2018-01-17 15:26:37 - let parseFile (input: string)  = 
2018-01-17 15:26:37 -     File.ReadAllLines(input)
2018-01-17 15:26:37 -         |> Array.toSeq
2018-01-17 15:26:37 -     
2018-01-17 15:26:37 -     
2018-01-17 15:26:37 -         
2018-01-17 15:26:37 -     
2018-01-17 15:26:37 - let duplicates (original: string[]) = None
2018-01-17 15:26:37 -     
2018-01-17 15:26:37 - // let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:26:37 - //     let initialData = 
2018-01-17 15:26:37 - //         inputFile
2018-01-17 15:26:37 - //             |> parseFile
2018-01-17 15:26:37 -     
2018-01-17 15:26:37 - //     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:26:37 -     
2018-01-17 15:26:37 - //     (Seq.length initialData) = (Seq.length noDuplicates)
2018-01-17 15:26:37 -         
2018-01-17 15:26:37 - let thing = inputFile |> parseFile
2018-01-17 15:26:37 - thing.GetType(), thing
2018-01-17 15:27:09 - // Getting the necessary libraries
2018-01-17 15:27:09 - open System.IO
2018-01-17 15:27:09 - open System
2018-01-17 15:27:09 - // Getting the raw data
2018-01-17 15:27:09 - let inputFile = "problem4.txt"
2018-01-17 15:27:09 - // let parseFile input = 
2018-01-17 15:27:09 - //     File.ReadAllText(input)
2018-01-17 15:27:09 - //     |> fun x ->  x.Split(' ')
2018-01-17 15:27:09 - let parseFile (input: string)  = 
2018-01-17 15:27:09 -     File.ReadAllLines(input)
2018-01-17 15:27:09 -         |> Array.map (fun x -> x.Split(' '))
2018-01-17 15:27:09 -     
2018-01-17 15:27:09 -     
2018-01-17 15:27:09 -         
2018-01-17 15:27:09 -     
2018-01-17 15:27:09 - let duplicates (original: string[]) = None
2018-01-17 15:27:09 -     
2018-01-17 15:27:09 - // let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:27:09 - //     let initialData = 
2018-01-17 15:27:09 - //         inputFile
2018-01-17 15:27:09 - //             |> parseFile
2018-01-17 15:27:09 -     
2018-01-17 15:27:09 - //     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:27:09 -     
2018-01-17 15:27:09 - //     (Seq.length initialData) = (Seq.length noDuplicates)
2018-01-17 15:27:09 -         
2018-01-17 15:27:09 - let thing = inputFile |> parseFile
2018-01-17 15:27:09 - thing.GetType(), thing
2018-01-17 15:28:00 - // Getting the necessary libraries
2018-01-17 15:28:00 - open System.IO
2018-01-17 15:28:00 - open System
2018-01-17 15:28:00 - // Getting the raw data
2018-01-17 15:28:00 - let inputFile = "problem4.txt"
2018-01-17 15:28:00 - // let parseFile input = 
2018-01-17 15:28:00 - //     File.ReadAllText(input)
2018-01-17 15:28:00 - //     |> fun x ->  x.Split(' ')
2018-01-17 15:28:00 - let parseFile (input: string) : String[][]  = 
2018-01-17 15:28:00 -     File.ReadAllLines(input)
2018-01-17 15:28:00 -         |> Array.map (fun x -> x.Split(' '))
2018-01-17 15:28:00 -     
2018-01-17 15:28:00 -     
2018-01-17 15:28:00 -         
2018-01-17 15:28:00 -     
2018-01-17 15:28:00 - let duplicates (original: string[]) = None
2018-01-17 15:28:00 -     
2018-01-17 15:28:00 - // let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:28:00 - //     let initialData = 
2018-01-17 15:28:00 - //         inputFile
2018-01-17 15:28:00 - //             |> parseFile
2018-01-17 15:28:00 -     
2018-01-17 15:28:00 - //     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:28:00 -     
2018-01-17 15:28:00 - //     (Seq.length initialData) = (Seq.length noDuplicates)
2018-01-17 15:28:00 -         
2018-01-17 15:28:00 - let thing = inputFile |> parseFile
2018-01-17 15:28:00 - thing.GetType(), thing
2018-01-17 15:30:50 - // Getting the necessary libraries
2018-01-17 15:30:50 - open System.IO
2018-01-17 15:30:50 - open System
2018-01-17 15:30:50 - // Getting the raw data
2018-01-17 15:30:50 - let inputFile = "problem4.txt"
2018-01-17 15:30:50 - // let parseFile input = 
2018-01-17 15:30:50 - //     File.ReadAllText(input)
2018-01-17 15:30:50 - //     |> fun x ->  x.Split(' ')
2018-01-17 15:30:50 - let parseFile (input: string) : String[][]  = 
2018-01-17 15:30:50 -     File.ReadAllLines(input)
2018-01-17 15:30:50 -         |> Array.map (fun x -> x.Split(' '))
2018-01-17 15:30:50 -     
2018-01-17 15:30:50 -     
2018-01-17 15:30:50 -         
2018-01-17 15:30:50 -     
2018-01-17 15:30:50 - let duplicates (original: string[]) : bool = 
2018-01-17 15:30:50 -     original
2018-01-17 15:30:50 -         |> Set.ofArray 
2018-01-17 15:30:50 -         |> fun setVersion -> Seq.length setVersion = Seq.length original
2018-01-17 15:30:50 -     
2018-01-17 15:30:50 - // let advOfCodePart4 (inputFile: string) : bool = 
2018-01-17 15:30:50 - //     let initialData = 
2018-01-17 15:30:50 - //         inputFile
2018-01-17 15:30:50 - //             |> parseFile
2018-01-17 15:30:50 -     
2018-01-17 15:30:50 - //     let noDuplicates = Set.ofArray (initialData)
2018-01-17 15:30:50 -     
2018-01-17 15:30:50 - //     (Seq.length initialData) = (Seq.length noDuplicates)
2018-01-17 15:30:50 -         
2018-01-17 15:30:50 - let thing = inputFile |> parseFile
2018-01-17 15:30:50 - thing.GetType(), thing
2018-01-17 15:35:14 - // Getting the necessary libraries
2018-01-17 15:35:14 - open System.IO
2018-01-17 15:35:14 - open System
2018-01-17 15:35:14 - // Getting the raw data
2018-01-17 15:35:14 - let inputFile = "problem4.txt"
2018-01-17 15:35:14 - // Turning the raw data into an array of arrays of strings
2018-01-17 15:35:14 - let parseFile (input: string) : String[][]  = 
2018-01-17 15:35:14 -     File.ReadAllLines(input)
2018-01-17 15:35:14 -         |> Array.map (fun x -> x.Split(' '))
2018-01-17 15:35:14 - // acceots an array and returns true if no duplicates by seeing if original is same length as set 
2018-01-17 15:35:14 - let noDuplicates (original: string[]) : bool = 
2018-01-17 15:35:14 -     original
2018-01-17 15:35:14 -         |> Set.ofArray 
2018-01-17 15:35:14 -         |> fun setVersion -> Seq.length setVersion = Seq.length original
2018-01-17 15:35:14 -     
2018-01-17 15:35:14 - let advOfCodePart4 (inputFile: string) : int = 
2018-01-17 15:35:14 -     let initialData = inputFile |> parseFile
2018-01-17 15:35:14 -     
2018-01-17 15:35:14 -     initialData 
2018-01-17 15:35:14 -         |> Array.filter noDuplicates
2018-01-17 15:35:14 -         |> Array.length
2018-01-17 15:35:32 - // Getting the necessary libraries
2018-01-17 15:35:32 - open System.IO
2018-01-17 15:35:32 - open System
2018-01-17 15:35:32 - // Getting the raw data
2018-01-17 15:35:32 - let inputFile = "problem4.txt"
2018-01-17 15:35:32 - // Turning the raw data into an array of arrays of strings
2018-01-17 15:35:32 - let parseFile (input: string) : String[][]  = 
2018-01-17 15:35:32 -     File.ReadAllLines(input)
2018-01-17 15:35:32 -         |> Array.map (fun x -> x.Split(' '))
2018-01-17 15:35:32 - // acceots an array and returns true if no duplicates by seeing if original is same length as set 
2018-01-17 15:35:32 - let noDuplicates (original: string[]) : bool = 
2018-01-17 15:35:32 -     original
2018-01-17 15:35:32 -         |> Set.ofArray 
2018-01-17 15:35:32 -         |> fun setVersion -> Seq.length setVersion = Seq.length original
2018-01-17 15:35:32 -     
2018-01-17 15:35:32 - let advOfCodePart4 (inputFile: string) : int = 
2018-01-17 15:35:32 -     let initialData = inputFile |> parseFile
2018-01-17 15:35:32 -     
2018-01-17 15:35:32 -     initialData 
2018-01-17 15:35:32 -         |> Array.filter noDuplicates
2018-01-17 15:35:32 -         |> Array.length
2018-01-17 15:35:32 -         
2018-01-17 15:35:32 - advOfCodePart4 inputFile
2018-01-17 15:44:46 - let noAnagrams (input: string[]) : bool = 
2018-01-17 15:44:46 -     input
2018-01-17 15:44:46 -         |> Array.map (fun word -> word |> Seq.sort |> String.concat)
2018-01-17 15:44:46 -     
2018-01-17 15:44:46 - Type mismatch. Expecting a
2018-01-17 15:44:46 -     'string [] -> bool'    
2018-01-17 15:44:46 - but given a
2018-01-17 15:44:46 -     'string [] -> obj []'    
2018-01-17 15:44:46 - The type 'bool' does not match the type 'obj []'
2018-01-17 15:44:46 - Type mismatch. Expecting a
2018-01-17 15:44:46 -     'seq<char> -> obj'    
2018-01-17 15:44:46 - but given a
2018-01-17 15:44:46 -     'string -> seq<string> -> string'    
2018-01-17 15:44:46 - The type 'seq<char>' does not match the type 'string'
2018-01-17 15:44:46 - Type mismatch. Expecting a
2018-01-17 15:44:46 -     'string [] -> bool'    
2018-01-17 15:44:46 - but given a
2018-01-17 15:44:46 -     'string [] -> obj []'    
2018-01-17 15:44:46 - The type 'bool' does not match the type 'obj []'
2018-01-17 15:47:38 - let noAnagrams (input: string[]) : bool = 
2018-01-17 15:47:38 -     input
2018-01-17 15:47:38 -         |> Array.map (fun word -> word |> Seq.sort |> String.concat)
2018-01-17 15:47:38 -         |> fun sortedLetters -> (Seq.length sortedLetters) = ( sortedLetters |> Set.ofArray Seq.length)
2018-01-17 15:47:38 -     
2018-01-17 15:47:38 - Type mismatch. Expecting a
2018-01-17 15:47:38 -     'seq<char> -> obj'    
2018-01-17 15:47:38 - but given a
2018-01-17 15:47:38 -     'string -> seq<string> -> string'    
2018-01-17 15:47:38 - The type 'seq<char>' does not match the type 'string'
2018-01-17 15:47:38 - This expression was expected to have type
2018-01-17 15:47:38 -     'obj [] -> int'    
2018-01-17 15:47:38 - but here has type
2018-01-17 15:47:38 -     'Set<IComparable>'    
2018-01-17 15:47:38 - This expression was expected to have type
2018-01-17 15:47:38 -     'IComparable []'    
2018-01-17 15:47:38 - but here has type
2018-01-17 15:47:38 -     'seq<obj> -> int'    
2018-01-17 15:47:38 - This expression was expected to have type
2018-01-17 15:47:38 -     'obj [] -> int'    
2018-01-17 15:47:38 - but here has type
2018-01-17 15:47:38 -     'Set<IComparable>'    
2018-01-17 15:53:18 - let noAnagrams (input: string[]) : bool = 
2018-01-17 15:53:18 -     input
2018-01-17 15:53:18 -         |> Array.map (fun word -> word |> Seq.sort |> String.concat(''))
2018-01-17 15:53:18 -         |> fun sortedLetters -> (Seq.length sortedLetters) = ( sortedLetters |> Set.ofArray |> Seq.length)
2018-01-17 15:53:18 -     
2018-01-17 15:53:18 - Unexpected quote symbol in expression
2018-01-17 15:53:18 - Unmatched '('
2018-01-17 15:53:28 - let noAnagrams (input: string[]) : bool = 
2018-01-17 15:53:28 -     input
2018-01-17 15:53:28 -         |> Array.map (fun word -> word |> Seq.sort |> String.concat())
2018-01-17 15:53:28 -         |> fun sortedLetters -> (Seq.length sortedLetters) = ( sortedLetters |> Set.ofArray |> Seq.length)
2018-01-17 15:53:28 -     
2018-01-17 15:53:28 - The type 'string' does not match the type 'char'
2018-01-17 15:53:28 - This expression was expected to have type
2018-01-17 15:53:28 -     'string'    
2018-01-17 15:53:28 - but here has type
2018-01-17 15:53:28 -     'unit'    
2018-01-17 15:54:00 - let noAnagrams (input: string[]) : bool = 
2018-01-17 15:54:00 -     input
2018-01-17 15:54:00 -         |> Array.map (fun word -> word |> Seq.sort |> String.concat '')
2018-01-17 15:54:00 -         |> fun sortedLetters -> (Seq.length sortedLetters) = ( sortedLetters |> Set.ofArray |> Seq.length)
2018-01-17 15:54:00 -     
2018-01-17 15:54:00 - Unexpected quote symbol in lambda expression. Expected incomplete structured construct at or before this point or other token.
2018-01-17 15:54:10 - let noAnagrams (input: string[]) : bool = 
2018-01-17 15:54:10 -     input
2018-01-17 15:54:10 -         |> Array.map (fun word -> word |> Seq.sort |> String.concat '')
2018-01-17 15:54:10 -         |> fun sortedLetters -> (Seq.length sortedLetters) = ( sortedLetters |> Set.ofArray |> Seq.length)
2018-01-17 15:54:10 -     
2018-01-17 15:54:10 - Unexpected quote symbol in lambda expression. Expected incomplete structured construct at or before this point or other token.
2018-01-17 15:58:22 - let sortword (word:string) : string = 
2018-01-17 15:58:22 -         word 
2018-01-17 15:58:22 -             |> Seq.sort 
2018-01-17 15:58:22 -             |> String.concat ""
2018-01-17 15:58:22 - let noAnagrams (input: string[]) : bool = 
2018-01-17 15:58:22 -     
2018-01-17 15:58:22 -     
2018-01-17 15:58:22 -     (Seq.length sortedInput) = ( sortedLetters |> Set.ofArray |> Seq.length)
2018-01-17 15:58:22 -     
2018-01-17 15:58:22 - The type 'string' does not match the type 'char'
2018-01-17 15:58:22 - The value or constructor 'sortedInput' is not defined.
2018-01-17 15:58:22 - The value or constructor 'sortedLetters' is not defined.
2018-01-17 16:01:02 - // sort the letters in a string
2018-01-17 16:01:02 - let sortWord (word:string) : string = 
2018-01-17 16:01:02 -         word 
2018-01-17 16:01:02 -             |> Seq.sort
2018-01-17 16:01:02 -             |> Seq.map string
2018-01-17 16:01:02 -             |> String.concat ""
2018-01-17 16:01:02 - let noAnagrams (input: string[]) : bool = 
2018-01-17 16:01:02 -     let sortedInput = input |> Array.map sortWord
2018-01-17 16:01:02 -     
2018-01-17 16:01:02 -     let setSortedInput = sortedInput |> Set.ofArray 
2018-01-17 16:01:02 -     
2018-01-17 16:01:02 -     Seq.length sortedInput = Seq.length setSortedInput
2018-01-17 16:01:02 -     
2018-01-17 16:03:16 - // sort the letters in a string
2018-01-17 16:03:16 - let sortWord (word:string) : string = 
2018-01-17 16:03:16 -         word 
2018-01-17 16:03:16 -             |> Seq.sort
2018-01-17 16:03:16 -             |> Seq.map string
2018-01-17 16:03:16 -             |> String.concat ""
2018-01-17 16:03:16 - // check if the word has anagrams by comparing the length of the set.
2018-01-17 16:03:16 - let noAnagrams (input: string[]) : bool = 
2018-01-17 16:03:16 -     let sortedInput = input |> Array.map sortWord
2018-01-17 16:03:16 -     let setSortedInput = sortedInput |> Set.ofArray 
2018-01-17 16:03:16 -     
2018-01-17 16:03:16 -     Seq.length sortedInput = Seq.length setSortedInput
2018-01-17 16:03:16 -     
2018-01-17 16:03:16 - let advOfCode4Part2 (inputFile:string) : int = 
2018-01-17 16:03:16 -     let initialData = inputFile |> parseFile
2018-01-17 16:03:16 -     
2018-01-17 16:03:16 -     initialData 
2018-01-17 16:03:16 -         |> Array.filter noDuplicates
2018-01-17 16:03:16 -         |> Array.filter noAnagrams
2018-01-17 16:03:16 -         |> Array.length
2018-01-17 16:03:16 -     
2018-01-17 16:03:16 -     
2018-01-17 16:04:00 - // sort the letters in a string
2018-01-17 16:04:00 - let sortWord (word:string) : string = 
2018-01-17 16:04:00 -         word 
2018-01-17 16:04:00 -             |> Seq.sort
2018-01-17 16:04:00 -             |> Seq.map string
2018-01-17 16:04:00 -             |> String.concat ""
2018-01-17 16:04:00 - // check if the word has anagrams by comparing the length of the set.
2018-01-17 16:04:00 - let noAnagrams (input: string[]) : bool = 
2018-01-17 16:04:00 -     let sortedInput = input |> Array.map sortWord
2018-01-17 16:04:00 -     let setSortedInput = sortedInput |> Set.ofArray 
2018-01-17 16:04:00 -     
2018-01-17 16:04:00 -     Seq.length sortedInput = Seq.length setSortedInput
2018-01-17 16:04:00 - // Basically the same as part 1 with one more filter. Yay functional programming
2018-01-17 16:04:00 - let advOfCode4Part2 (inputFile:string) : int = 
2018-01-17 16:04:00 -     let initialData = inputFile |> parseFile
2018-01-17 16:04:00 -     
2018-01-17 16:04:00 -     initialData 
2018-01-17 16:04:00 -         |> Array.filter noDuplicates
2018-01-17 16:04:00 -         |> Array.filter noAnagrams
2018-01-17 16:04:00 -         |> Array.length
2018-01-17 16:04:00 -     
2018-01-17 16:04:00 - advOfCode4Part2 inputFile
2018-01-17 16:07:09 - // Getting the necessary libraries
2018-01-17 16:07:09 - open System.IO
2018-01-17 16:07:09 - open System
2018-01-17 16:07:09 - // Getting the raw data
2018-01-17 16:07:09 - let inputFile = "problem4.txt"
2018-01-17 16:07:09 - // Turning the raw data into an array of arrays of strings
2018-01-17 16:07:09 - let parseFile (input: string) : String[][]  = 
2018-01-17 16:07:09 -     File.ReadAllLines(input)
2018-01-17 16:07:09 -         |> Array.map (fun x -> x.Split(' '))
2018-01-17 16:07:09 - // acceots an array and returns true if no duplicates by seeing if original is same length as set 
2018-01-17 16:07:09 - let noDuplicates (original: string[]) : bool = 
2018-01-17 16:07:09 -     original
2018-01-17 16:07:09 -         |> Set.ofArray 
2018-01-17 16:07:09 -         |> fun setVersion -> Seq.length setVersion = Seq.length original
2018-01-17 16:07:09 -     
2018-01-17 16:07:09 - // filters the array using the noDuplicates function, then counts the remmaining arrays
2018-01-17 16:07:09 - let advOfCodePart4 (inputFile: string) : int = 
2018-01-17 16:07:09 -     let initialData = inputFile |> parseFile
2018-01-17 16:07:09 -     
2018-01-17 16:07:09 -     initialData 
2018-01-17 16:07:09 -         |> Array.filter noDuplicates
2018-01-17 16:07:09 -         |> Array.length
2018-01-17 16:07:09 -         
2018-01-17 16:07:09 - advOfCodePart4 inputFile
2018-01-17 16:07:09 - // sort the letters in a string
2018-01-17 16:07:09 - let sortWord (word:string) : string = 
2018-01-17 16:07:09 -         word 
2018-01-17 16:07:09 -             |> Seq.sort
2018-01-17 16:07:09 -             |> Seq.map string
2018-01-17 16:07:09 -             |> String.concat ""
2018-01-17 16:07:09 - // check if the word has anagrams by comparing the length of the set.
2018-01-17 16:07:09 - let noAnagrams (input: string[]) : bool = 
2018-01-17 16:07:09 -     let sortedInput = input |> Array.map sortWord
2018-01-17 16:07:09 -     let setSortedInput = sortedInput |> Set.ofArray 
2018-01-17 16:07:09 -     
2018-01-17 16:07:09 -     Seq.length sortedInput = Seq.length setSortedInput
2018-01-17 16:07:09 - // Basically the same as part 1 with one more filter. Yay functional programming
2018-01-17 16:07:09 - let advOfCode4Part2 (inputFile:string) : int = 
2018-01-17 16:07:09 -     let initialData = inputFile |> parseFile
2018-01-17 16:07:09 -     
2018-01-17 16:07:09 -     initialData 
2018-01-17 16:07:09 -         |> Array.filter noDuplicates
2018-01-17 16:07:09 -         |> Array.filter noAnagrams
2018-01-17 16:07:09 -         |> Array.length
2018-01-17 16:07:09 -     
2018-01-17 16:07:09 - advOfCode4Part2 inputFile
